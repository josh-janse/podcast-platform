"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ioredis@5.6.1";
exports.ids = ["vendor-chunks/ioredis@5.6.1"];
exports.modules = {

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js":
/*!************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js ***!
  \************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/../../node_modules/.pnpm/@ioredis+commands@1.2.0/node_modules/@ioredis/commands/built/index.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/../../node_modules/.pnpm/cluster-key-slot@1.1.2/node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\n/**\n * Command instance\n *\n * It's rare that you need to create a Command instance yourself.\n *\n * ```js\n * var infoCommand = new Command('info', null, function (err, result) {\n *   console.log('result', result);\n * });\n *\n * redis.sendCommand(infoCommand);\n *\n * // When no callback provided, Command instance will have a `promise` property,\n * // which will resolve/reject with the result of the command.\n * var getCommand = new Command('get', ['foo']);\n * getCommand.promise.then(function (result) {\n *   console.log('result', result);\n * });\n * ```\n */\nclass Command {\n    /**\n     * Creates an instance of Command.\n     * @param name Command name\n     * @param args An array of command arguments\n     * @param options\n     * @param callback The callback that handles the response.\n     * If omit, the response will be handled via Promise\n     */\n    constructor(name, args = [], options = {}, callback) {\n        this.name = name;\n        this.inTransaction = false;\n        this.isResolved = false;\n        this.transformed = false;\n        this.replyEncoding = options.replyEncoding;\n        this.errorStack = options.errorStack;\n        this.args = args.flat();\n        this.callback = callback;\n        this.initPromise();\n        if (options.keyPrefix) {\n            // @ts-expect-error\n            const isBufferKeyPrefix = options.keyPrefix instanceof Buffer;\n            // @ts-expect-error\n            let keyPrefixBuffer = isBufferKeyPrefix\n                ? options.keyPrefix\n                : null;\n            this._iterateKeys((key) => {\n                if (key instanceof Buffer) {\n                    if (keyPrefixBuffer === null) {\n                        keyPrefixBuffer = Buffer.from(options.keyPrefix);\n                    }\n                    return Buffer.concat([keyPrefixBuffer, key]);\n                }\n                else if (isBufferKeyPrefix) {\n                    // @ts-expect-error\n                    return Buffer.concat([options.keyPrefix, Buffer.from(String(key))]);\n                }\n                return options.keyPrefix + key;\n            });\n        }\n        if (options.readOnly) {\n            this.isReadOnly = true;\n        }\n    }\n    /**\n     * Check whether the command has the flag\n     */\n    static checkFlag(flagName, commandName) {\n        return !!this.getFlagMap()[flagName][commandName];\n    }\n    static setArgumentTransformer(name, func) {\n        this._transformer.argument[name] = func;\n    }\n    static setReplyTransformer(name, func) {\n        this._transformer.reply[name] = func;\n    }\n    static getFlagMap() {\n        if (!this.flagMap) {\n            this.flagMap = Object.keys(Command.FLAGS).reduce((map, flagName) => {\n                map[flagName] = {};\n                Command.FLAGS[flagName].forEach((commandName) => {\n                    map[flagName][commandName] = true;\n                });\n                return map;\n            }, {});\n        }\n        return this.flagMap;\n    }\n    getSlot() {\n        if (typeof this.slot === \"undefined\") {\n            const key = this.getKeys()[0];\n            this.slot = key == null ? null : calculateSlot(key);\n        }\n        return this.slot;\n    }\n    getKeys() {\n        return this._iterateKeys();\n    }\n    /**\n     * Convert command to writable buffer or string\n     */\n    toWritable(_socket) {\n        let result;\n        const commandStr = \"*\" +\n            (this.args.length + 1) +\n            \"\\r\\n$\" +\n            Buffer.byteLength(this.name) +\n            \"\\r\\n\" +\n            this.name +\n            \"\\r\\n\";\n        if (this.bufferMode) {\n            const buffers = new MixedBuffers();\n            buffers.push(commandStr);\n            for (let i = 0; i < this.args.length; ++i) {\n                const arg = this.args[i];\n                if (arg instanceof Buffer) {\n                    if (arg.length === 0) {\n                        buffers.push(\"$0\\r\\n\\r\\n\");\n                    }\n                    else {\n                        buffers.push(\"$\" + arg.length + \"\\r\\n\");\n                        buffers.push(arg);\n                        buffers.push(\"\\r\\n\");\n                    }\n                }\n                else {\n                    buffers.push(\"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\");\n                }\n            }\n            result = buffers.toBuffer();\n        }\n        else {\n            result = commandStr;\n            for (let i = 0; i < this.args.length; ++i) {\n                const arg = this.args[i];\n                result +=\n                    \"$\" +\n                        Buffer.byteLength(arg) +\n                        \"\\r\\n\" +\n                        arg +\n                        \"\\r\\n\";\n            }\n        }\n        return result;\n    }\n    stringifyArguments() {\n        for (let i = 0; i < this.args.length; ++i) {\n            const arg = this.args[i];\n            if (typeof arg === \"string\") {\n                // buffers and strings don't need any transformation\n            }\n            else if (arg instanceof Buffer) {\n                this.bufferMode = true;\n            }\n            else {\n                this.args[i] = (0, utils_1.toArg)(arg);\n            }\n        }\n    }\n    /**\n     * Convert buffer/buffer[] to string/string[],\n     * and apply reply transformer.\n     */\n    transformReply(result) {\n        if (this.replyEncoding) {\n            result = (0, utils_1.convertBufferToString)(result, this.replyEncoding);\n        }\n        const transformer = Command._transformer.reply[this.name];\n        if (transformer) {\n            result = transformer(result);\n        }\n        return result;\n    }\n    /**\n     * Set the wait time before terminating the attempt to execute a command\n     * and generating an error.\n     */\n    setTimeout(ms) {\n        if (!this._commandTimeoutTimer) {\n            this._commandTimeoutTimer = setTimeout(() => {\n                if (!this.isResolved) {\n                    this.reject(new Error(\"Command timed out\"));\n                }\n            }, ms);\n        }\n    }\n    initPromise() {\n        const promise = new Promise((resolve, reject) => {\n            if (!this.transformed) {\n                this.transformed = true;\n                const transformer = Command._transformer.argument[this.name];\n                if (transformer) {\n                    this.args = transformer(this.args);\n                }\n                this.stringifyArguments();\n            }\n            this.resolve = this._convertValue(resolve);\n            if (this.errorStack) {\n                this.reject = (err) => {\n                    reject((0, utils_1.optimizeErrorStack)(err, this.errorStack.stack, __dirname));\n                };\n            }\n            else {\n                this.reject = reject;\n            }\n        });\n        this.promise = (0, standard_as_callback_1.default)(promise, this.callback);\n    }\n    /**\n     * Iterate through the command arguments that are considered keys.\n     */\n    _iterateKeys(transform = (key) => key) {\n        if (typeof this.keys === \"undefined\") {\n            this.keys = [];\n            if ((0, commands_1.exists)(this.name)) {\n                // @ts-expect-error\n                const keyIndexes = (0, commands_1.getKeyIndexes)(this.name, this.args);\n                for (const index of keyIndexes) {\n                    this.args[index] = transform(this.args[index]);\n                    this.keys.push(this.args[index]);\n                }\n            }\n        }\n        return this.keys;\n    }\n    /**\n     * Convert the value from buffer to the target encoding.\n     */\n    _convertValue(resolve) {\n        return (value) => {\n            try {\n                const existingTimer = this._commandTimeoutTimer;\n                if (existingTimer) {\n                    clearTimeout(existingTimer);\n                    delete this._commandTimeoutTimer;\n                }\n                resolve(this.transformReply(value));\n                this.isResolved = true;\n            }\n            catch (err) {\n                this.reject(err);\n            }\n            return this.promise;\n        };\n    }\n}\nexports[\"default\"] = Command;\nCommand.FLAGS = {\n    VALID_IN_SUBSCRIBER_MODE: [\n        \"subscribe\",\n        \"psubscribe\",\n        \"unsubscribe\",\n        \"punsubscribe\",\n        \"ssubscribe\",\n        \"sunsubscribe\",\n        \"ping\",\n        \"quit\",\n    ],\n    VALID_IN_MONITOR_MODE: [\"monitor\", \"auth\"],\n    ENTER_SUBSCRIBER_MODE: [\"subscribe\", \"psubscribe\", \"ssubscribe\"],\n    EXIT_SUBSCRIBER_MODE: [\"unsubscribe\", \"punsubscribe\", \"sunsubscribe\"],\n    WILL_DISCONNECT: [\"quit\"],\n};\nCommand._transformer = {\n    argument: {},\n    reply: {},\n};\nconst msetArgumentTransformer = function (args) {\n    if (args.length === 1) {\n        if (args[0] instanceof Map) {\n            return (0, utils_1.convertMapToArray)(args[0]);\n        }\n        if (typeof args[0] === \"object\" && args[0] !== null) {\n            return (0, utils_1.convertObjectToArray)(args[0]);\n        }\n    }\n    return args;\n};\nconst hsetArgumentTransformer = function (args) {\n    if (args.length === 2) {\n        if (args[1] instanceof Map) {\n            return [args[0]].concat((0, utils_1.convertMapToArray)(args[1]));\n        }\n        if (typeof args[1] === \"object\" && args[1] !== null) {\n            return [args[0]].concat((0, utils_1.convertObjectToArray)(args[1]));\n        }\n    }\n    return args;\n};\nCommand.setArgumentTransformer(\"mset\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"msetnx\", msetArgumentTransformer);\nCommand.setArgumentTransformer(\"hset\", hsetArgumentTransformer);\nCommand.setArgumentTransformer(\"hmset\", hsetArgumentTransformer);\nCommand.setReplyTransformer(\"hgetall\", function (result) {\n    if (Array.isArray(result)) {\n        const obj = {};\n        for (let i = 0; i < result.length; i += 2) {\n            const key = result[i];\n            const value = result[i + 1];\n            if (key in obj) {\n                // can only be truthy if the property is special somehow, like '__proto__' or 'constructor'\n                // https://github.com/luin/ioredis/issues/1267\n                Object.defineProperty(obj, key, {\n                    value,\n                    configurable: true,\n                    enumerable: true,\n                    writable: true,\n                });\n            }\n            else {\n                obj[key] = value;\n            }\n        }\n        return obj;\n    }\n    return result;\n});\nclass MixedBuffers {\n    constructor() {\n        this.length = 0;\n        this.items = [];\n    }\n    push(x) {\n        this.length += Buffer.byteLength(x);\n        this.items.push(x);\n    }\n    toBuffer() {\n        const result = Buffer.allocUnsafe(this.length);\n        let offset = 0;\n        for (const item of this.items) {\n            const length = Buffer.byteLength(item);\n            Buffer.isBuffer(item)\n                ? item.copy(result, offset)\n                : result.write(item, offset, length);\n            offset += length;\n        }\n        return result;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvQ29tbWFuZC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQywrSEFBbUI7QUFDOUMsc0JBQXNCLG1CQUFPLENBQUMsMEhBQWtCO0FBQ2hELCtCQUErQixtQkFBTyxDQUFDLHdJQUFzQjtBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx1R0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYSxJQUFJO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0Isc0JBQXNCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixtQkFBbUI7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvQ29tbWFuZC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBjYWxjdWxhdGVTbG90ID0gcmVxdWlyZShcImNsdXN0ZXIta2V5LXNsb3RcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuLyoqXG4gKiBDb21tYW5kIGluc3RhbmNlXG4gKlxuICogSXQncyByYXJlIHRoYXQgeW91IG5lZWQgdG8gY3JlYXRlIGEgQ29tbWFuZCBpbnN0YW5jZSB5b3Vyc2VsZi5cbiAqXG4gKiBgYGBqc1xuICogdmFyIGluZm9Db21tYW5kID0gbmV3IENvbW1hbmQoJ2luZm8nLCBudWxsLCBmdW5jdGlvbiAoZXJyLCByZXN1bHQpIHtcbiAqICAgY29uc29sZS5sb2coJ3Jlc3VsdCcsIHJlc3VsdCk7XG4gKiB9KTtcbiAqXG4gKiByZWRpcy5zZW5kQ29tbWFuZChpbmZvQ29tbWFuZCk7XG4gKlxuICogLy8gV2hlbiBubyBjYWxsYmFjayBwcm92aWRlZCwgQ29tbWFuZCBpbnN0YW5jZSB3aWxsIGhhdmUgYSBgcHJvbWlzZWAgcHJvcGVydHksXG4gKiAvLyB3aGljaCB3aWxsIHJlc29sdmUvcmVqZWN0IHdpdGggdGhlIHJlc3VsdCBvZiB0aGUgY29tbWFuZC5cbiAqIHZhciBnZXRDb21tYW5kID0gbmV3IENvbW1hbmQoJ2dldCcsIFsnZm9vJ10pO1xuICogZ2V0Q29tbWFuZC5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICogICBjb25zb2xlLmxvZygncmVzdWx0JywgcmVzdWx0KTtcbiAqIH0pO1xuICogYGBgXG4gKi9cbmNsYXNzIENvbW1hbmQge1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYW4gaW5zdGFuY2Ugb2YgQ29tbWFuZC5cbiAgICAgKiBAcGFyYW0gbmFtZSBDb21tYW5kIG5hbWVcbiAgICAgKiBAcGFyYW0gYXJncyBBbiBhcnJheSBvZiBjb21tYW5kIGFyZ3VtZW50c1xuICAgICAqIEBwYXJhbSBvcHRpb25zXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayB0aGF0IGhhbmRsZXMgdGhlIHJlc3BvbnNlLlxuICAgICAqIElmIG9taXQsIHRoZSByZXNwb25zZSB3aWxsIGJlIGhhbmRsZWQgdmlhIFByb21pc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3RvcihuYW1lLCBhcmdzID0gW10sIG9wdGlvbnMgPSB7fSwgY2FsbGJhY2spIHtcbiAgICAgICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgdGhpcy5pblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIHRoaXMuaXNSZXNvbHZlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLnRyYW5zZm9ybWVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMucmVwbHlFbmNvZGluZyA9IG9wdGlvbnMucmVwbHlFbmNvZGluZztcbiAgICAgICAgdGhpcy5lcnJvclN0YWNrID0gb3B0aW9ucy5lcnJvclN0YWNrO1xuICAgICAgICB0aGlzLmFyZ3MgPSBhcmdzLmZsYXQoKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjayA9IGNhbGxiYWNrO1xuICAgICAgICB0aGlzLmluaXRQcm9taXNlKCk7XG4gICAgICAgIGlmIChvcHRpb25zLmtleVByZWZpeCkge1xuICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgY29uc3QgaXNCdWZmZXJLZXlQcmVmaXggPSBvcHRpb25zLmtleVByZWZpeCBpbnN0YW5jZW9mIEJ1ZmZlcjtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGxldCBrZXlQcmVmaXhCdWZmZXIgPSBpc0J1ZmZlcktleVByZWZpeFxuICAgICAgICAgICAgICAgID8gb3B0aW9ucy5rZXlQcmVmaXhcbiAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICB0aGlzLl9pdGVyYXRlS2V5cygoa2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGtleSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoa2V5UHJlZml4QnVmZmVyID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXlQcmVmaXhCdWZmZXIgPSBCdWZmZXIuZnJvbShvcHRpb25zLmtleVByZWZpeCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW2tleVByZWZpeEJ1ZmZlciwga2V5XSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGlzQnVmZmVyS2V5UHJlZml4KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIEJ1ZmZlci5jb25jYXQoW29wdGlvbnMua2V5UHJlZml4LCBCdWZmZXIuZnJvbShTdHJpbmcoa2V5KSldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIG9wdGlvbnMua2V5UHJlZml4ICsga2V5O1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMucmVhZE9ubHkpIHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWFkT25seSA9IHRydWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ2hlY2sgd2hldGhlciB0aGUgY29tbWFuZCBoYXMgdGhlIGZsYWdcbiAgICAgKi9cbiAgICBzdGF0aWMgY2hlY2tGbGFnKGZsYWdOYW1lLCBjb21tYW5kTmFtZSkge1xuICAgICAgICByZXR1cm4gISF0aGlzLmdldEZsYWdNYXAoKVtmbGFnTmFtZV1bY29tbWFuZE5hbWVdO1xuICAgIH1cbiAgICBzdGF0aWMgc2V0QXJndW1lbnRUcmFuc2Zvcm1lcihuYW1lLCBmdW5jKSB7XG4gICAgICAgIHRoaXMuX3RyYW5zZm9ybWVyLmFyZ3VtZW50W25hbWVdID0gZnVuYztcbiAgICB9XG4gICAgc3RhdGljIHNldFJlcGx5VHJhbnNmb3JtZXIobmFtZSwgZnVuYykge1xuICAgICAgICB0aGlzLl90cmFuc2Zvcm1lci5yZXBseVtuYW1lXSA9IGZ1bmM7XG4gICAgfVxuICAgIHN0YXRpYyBnZXRGbGFnTWFwKCkge1xuICAgICAgICBpZiAoIXRoaXMuZmxhZ01hcCkge1xuICAgICAgICAgICAgdGhpcy5mbGFnTWFwID0gT2JqZWN0LmtleXMoQ29tbWFuZC5GTEFHUykucmVkdWNlKChtYXAsIGZsYWdOYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgbWFwW2ZsYWdOYW1lXSA9IHt9O1xuICAgICAgICAgICAgICAgIENvbW1hbmQuRkxBR1NbZmxhZ05hbWVdLmZvckVhY2goKGNvbW1hbmROYW1lKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIG1hcFtmbGFnTmFtZV1bY29tbWFuZE5hbWVdID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm4gbWFwO1xuICAgICAgICAgICAgfSwge30pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmZsYWdNYXA7XG4gICAgfVxuICAgIGdldFNsb3QoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5zbG90ID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgICAgICBjb25zdCBrZXkgPSB0aGlzLmdldEtleXMoKVswXTtcbiAgICAgICAgICAgIHRoaXMuc2xvdCA9IGtleSA9PSBudWxsID8gbnVsbCA6IGNhbGN1bGF0ZVNsb3Qoa2V5KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5zbG90O1xuICAgIH1cbiAgICBnZXRLZXlzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faXRlcmF0ZUtleXMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBjb21tYW5kIHRvIHdyaXRhYmxlIGJ1ZmZlciBvciBzdHJpbmdcbiAgICAgKi9cbiAgICB0b1dyaXRhYmxlKF9zb2NrZXQpIHtcbiAgICAgICAgbGV0IHJlc3VsdDtcbiAgICAgICAgY29uc3QgY29tbWFuZFN0ciA9IFwiKlwiICtcbiAgICAgICAgICAgICh0aGlzLmFyZ3MubGVuZ3RoICsgMSkgK1xuICAgICAgICAgICAgXCJcXHJcXG4kXCIgK1xuICAgICAgICAgICAgQnVmZmVyLmJ5dGVMZW5ndGgodGhpcy5uYW1lKSArXG4gICAgICAgICAgICBcIlxcclxcblwiICtcbiAgICAgICAgICAgIHRoaXMubmFtZSArXG4gICAgICAgICAgICBcIlxcclxcblwiO1xuICAgICAgICBpZiAodGhpcy5idWZmZXJNb2RlKSB7XG4gICAgICAgICAgICBjb25zdCBidWZmZXJzID0gbmV3IE1peGVkQnVmZmVycygpO1xuICAgICAgICAgICAgYnVmZmVycy5wdXNoKGNvbW1hbmRTdHIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmFyZ3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBhcmcgPSB0aGlzLmFyZ3NbaV07XG4gICAgICAgICAgICAgICAgaWYgKGFyZyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKFwiJDBcXHJcXG5cXHJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goXCIkXCIgKyBhcmcubGVuZ3RoICsgXCJcXHJcXG5cIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goYXJnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMucHVzaChcIlxcclxcblwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKFwiJFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIEJ1ZmZlci5ieXRlTGVuZ3RoKGFyZykgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgXCJcXHJcXG5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzdWx0ID0gYnVmZmVycy50b0J1ZmZlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0ID0gY29tbWFuZFN0cjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5hcmdzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgYXJnID0gdGhpcy5hcmdzW2ldO1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPVxuICAgICAgICAgICAgICAgICAgICBcIiRcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICBCdWZmZXIuYnl0ZUxlbmd0aChhcmcpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxyXFxuXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgYXJnICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxyXFxuXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgc3RyaW5naWZ5QXJndW1lbnRzKCkge1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gdGhpcy5hcmdzW2ldO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAvLyBidWZmZXJzIGFuZCBzdHJpbmdzIGRvbid0IG5lZWQgYW55IHRyYW5zZm9ybWF0aW9uXG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChhcmcgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmJ1ZmZlck1vZGUgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hcmdzW2ldID0gKDAsIHV0aWxzXzEudG9BcmcpKGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCBidWZmZXIvYnVmZmVyW10gdG8gc3RyaW5nL3N0cmluZ1tdLFxuICAgICAqIGFuZCBhcHBseSByZXBseSB0cmFuc2Zvcm1lci5cbiAgICAgKi9cbiAgICB0cmFuc2Zvcm1SZXBseShyZXN1bHQpIHtcbiAgICAgICAgaWYgKHRoaXMucmVwbHlFbmNvZGluZykge1xuICAgICAgICAgICAgcmVzdWx0ID0gKDAsIHV0aWxzXzEuY29udmVydEJ1ZmZlclRvU3RyaW5nKShyZXN1bHQsIHRoaXMucmVwbHlFbmNvZGluZyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBDb21tYW5kLl90cmFuc2Zvcm1lci5yZXBseVt0aGlzLm5hbWVdO1xuICAgICAgICBpZiAodHJhbnNmb3JtZXIpIHtcbiAgICAgICAgICAgIHJlc3VsdCA9IHRyYW5zZm9ybWVyKHJlc3VsdCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IHRoZSB3YWl0IHRpbWUgYmVmb3JlIHRlcm1pbmF0aW5nIHRoZSBhdHRlbXB0IHRvIGV4ZWN1dGUgYSBjb21tYW5kXG4gICAgICogYW5kIGdlbmVyYXRpbmcgYW4gZXJyb3IuXG4gICAgICovXG4gICAgc2V0VGltZW91dChtcykge1xuICAgICAgICBpZiAoIXRoaXMuX2NvbW1hbmRUaW1lb3V0VGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbW1hbmRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuaXNSZXNvbHZlZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChuZXcgRXJyb3IoXCJDb21tYW5kIHRpbWVkIG91dFwiKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgbXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGluaXRQcm9taXNlKCkge1xuICAgICAgICBjb25zdCBwcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnRyYW5zZm9ybWVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy50cmFuc2Zvcm1lZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY29uc3QgdHJhbnNmb3JtZXIgPSBDb21tYW5kLl90cmFuc2Zvcm1lci5hcmd1bWVudFt0aGlzLm5hbWVdO1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc2Zvcm1lcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3MgPSB0cmFuc2Zvcm1lcih0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmluZ2lmeUFyZ3VtZW50cygpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gdGhpcy5fY29udmVydFZhbHVlKHJlc29sdmUpO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXJyb3JTdGFjaykge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoKDAsIHV0aWxzXzEub3B0aW1pemVFcnJvclN0YWNrKShlcnIsIHRoaXMuZXJyb3JTdGFjay5zdGFjaywgX19kaXJuYW1lKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkocHJvbWlzZSwgdGhpcy5jYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEl0ZXJhdGUgdGhyb3VnaCB0aGUgY29tbWFuZCBhcmd1bWVudHMgdGhhdCBhcmUgY29uc2lkZXJlZCBrZXlzLlxuICAgICAqL1xuICAgIF9pdGVyYXRlS2V5cyh0cmFuc2Zvcm0gPSAoa2V5KSA9PiBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmtleXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgICAgIHRoaXMua2V5cyA9IFtdO1xuICAgICAgICAgICAgaWYgKCgwLCBjb21tYW5kc18xLmV4aXN0cykodGhpcy5uYW1lKSkge1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICBjb25zdCBrZXlJbmRleGVzID0gKDAsIGNvbW1hbmRzXzEuZ2V0S2V5SW5kZXhlcykodGhpcy5uYW1lLCB0aGlzLmFyZ3MpO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgaW5kZXggb2Yga2V5SW5kZXhlcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbaW5kZXhdID0gdHJhbnNmb3JtKHRoaXMuYXJnc1tpbmRleF0pO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmtleXMucHVzaCh0aGlzLmFyZ3NbaW5kZXhdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMua2V5cztcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29udmVydCB0aGUgdmFsdWUgZnJvbSBidWZmZXIgdG8gdGhlIHRhcmdldCBlbmNvZGluZy5cbiAgICAgKi9cbiAgICBfY29udmVydFZhbHVlKHJlc29sdmUpIHtcbiAgICAgICAgcmV0dXJuICh2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCBleGlzdGluZ1RpbWVyID0gdGhpcy5fY29tbWFuZFRpbWVvdXRUaW1lcjtcbiAgICAgICAgICAgICAgICBpZiAoZXhpc3RpbmdUaW1lcikge1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoZXhpc3RpbmdUaW1lcik7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSB0aGlzLl9jb21tYW5kVGltZW91dFRpbWVyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXNvbHZlKHRoaXMudHJhbnNmb3JtUmVwbHkodmFsdWUpKTtcbiAgICAgICAgICAgICAgICB0aGlzLmlzUmVzb2x2ZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMucmVqZWN0KGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IENvbW1hbmQ7XG5Db21tYW5kLkZMQUdTID0ge1xuICAgIFZBTElEX0lOX1NVQlNDUklCRVJfTU9ERTogW1xuICAgICAgICBcInN1YnNjcmliZVwiLFxuICAgICAgICBcInBzdWJzY3JpYmVcIixcbiAgICAgICAgXCJ1bnN1YnNjcmliZVwiLFxuICAgICAgICBcInB1bnN1YnNjcmliZVwiLFxuICAgICAgICBcInNzdWJzY3JpYmVcIixcbiAgICAgICAgXCJzdW5zdWJzY3JpYmVcIixcbiAgICAgICAgXCJwaW5nXCIsXG4gICAgICAgIFwicXVpdFwiLFxuICAgIF0sXG4gICAgVkFMSURfSU5fTU9OSVRPUl9NT0RFOiBbXCJtb25pdG9yXCIsIFwiYXV0aFwiXSxcbiAgICBFTlRFUl9TVUJTQ1JJQkVSX01PREU6IFtcInN1YnNjcmliZVwiLCBcInBzdWJzY3JpYmVcIiwgXCJzc3Vic2NyaWJlXCJdLFxuICAgIEVYSVRfU1VCU0NSSUJFUl9NT0RFOiBbXCJ1bnN1YnNjcmliZVwiLCBcInB1bnN1YnNjcmliZVwiLCBcInN1bnN1YnNjcmliZVwiXSxcbiAgICBXSUxMX0RJU0NPTk5FQ1Q6IFtcInF1aXRcIl0sXG59O1xuQ29tbWFuZC5fdHJhbnNmb3JtZXIgPSB7XG4gICAgYXJndW1lbnQ6IHt9LFxuICAgIHJlcGx5OiB7fSxcbn07XG5jb25zdCBtc2V0QXJndW1lbnRUcmFuc2Zvcm1lciA9IGZ1bmN0aW9uIChhcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGlmIChhcmdzWzBdIGluc3RhbmNlb2YgTWFwKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29udmVydE1hcFRvQXJyYXkpKGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gXCJvYmplY3RcIiAmJiBhcmdzWzBdICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gKDAsIHV0aWxzXzEuY29udmVydE9iamVjdFRvQXJyYXkpKGFyZ3NbMF0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBhcmdzO1xufTtcbmNvbnN0IGhzZXRBcmd1bWVudFRyYW5zZm9ybWVyID0gZnVuY3Rpb24gKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDIpIHtcbiAgICAgICAgaWYgKGFyZ3NbMV0gaW5zdGFuY2VvZiBNYXApIHtcbiAgICAgICAgICAgIHJldHVybiBbYXJnc1swXV0uY29uY2F0KCgwLCB1dGlsc18xLmNvbnZlcnRNYXBUb0FycmF5KShhcmdzWzFdKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBhcmdzWzFdID09PSBcIm9iamVjdFwiICYmIGFyZ3NbMV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybiBbYXJnc1swXV0uY29uY2F0KCgwLCB1dGlsc18xLmNvbnZlcnRPYmplY3RUb0FycmF5KShhcmdzWzFdKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFyZ3M7XG59O1xuQ29tbWFuZC5zZXRBcmd1bWVudFRyYW5zZm9ybWVyKFwibXNldFwiLCBtc2V0QXJndW1lbnRUcmFuc2Zvcm1lcik7XG5Db21tYW5kLnNldEFyZ3VtZW50VHJhbnNmb3JtZXIoXCJtc2V0bnhcIiwgbXNldEFyZ3VtZW50VHJhbnNmb3JtZXIpO1xuQ29tbWFuZC5zZXRBcmd1bWVudFRyYW5zZm9ybWVyKFwiaHNldFwiLCBoc2V0QXJndW1lbnRUcmFuc2Zvcm1lcik7XG5Db21tYW5kLnNldEFyZ3VtZW50VHJhbnNmb3JtZXIoXCJobXNldFwiLCBoc2V0QXJndW1lbnRUcmFuc2Zvcm1lcik7XG5Db21tYW5kLnNldFJlcGx5VHJhbnNmb3JtZXIoXCJoZ2V0YWxsXCIsIGZ1bmN0aW9uIChyZXN1bHQpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShyZXN1bHQpKSB7XG4gICAgICAgIGNvbnN0IG9iaiA9IHt9O1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHJlc3VsdC5sZW5ndGg7IGkgKz0gMikge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gcmVzdWx0W2ldO1xuICAgICAgICAgICAgY29uc3QgdmFsdWUgPSByZXN1bHRbaSArIDFdO1xuICAgICAgICAgICAgaWYgKGtleSBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAvLyBjYW4gb25seSBiZSB0cnV0aHkgaWYgdGhlIHByb3BlcnR5IGlzIHNwZWNpYWwgc29tZWhvdywgbGlrZSAnX19wcm90b19fJyBvciAnY29uc3RydWN0b3InXG4gICAgICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2x1aW4vaW9yZWRpcy9pc3N1ZXMvMTI2N1xuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG9iajtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn0pO1xuY2xhc3MgTWl4ZWRCdWZmZXJzIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgdGhpcy5sZW5ndGggPSAwO1xuICAgICAgICB0aGlzLml0ZW1zID0gW107XG4gICAgfVxuICAgIHB1c2goeCkge1xuICAgICAgICB0aGlzLmxlbmd0aCArPSBCdWZmZXIuYnl0ZUxlbmd0aCh4KTtcbiAgICAgICAgdGhpcy5pdGVtcy5wdXNoKHgpO1xuICAgIH1cbiAgICB0b0J1ZmZlcigpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gQnVmZmVyLmFsbG9jVW5zYWZlKHRoaXMubGVuZ3RoKTtcbiAgICAgICAgbGV0IG9mZnNldCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgaXRlbSBvZiB0aGlzLml0ZW1zKSB7XG4gICAgICAgICAgICBjb25zdCBsZW5ndGggPSBCdWZmZXIuYnl0ZUxlbmd0aChpdGVtKTtcbiAgICAgICAgICAgIEJ1ZmZlci5pc0J1ZmZlcihpdGVtKVxuICAgICAgICAgICAgICAgID8gaXRlbS5jb3B5KHJlc3VsdCwgb2Zmc2V0KVxuICAgICAgICAgICAgICAgIDogcmVzdWx0LndyaXRlKGl0ZW0sIG9mZnNldCwgbGVuZ3RoKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/DataHandler.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/DataHandler.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst RedisParser = __webpack_require__(/*! redis-parser */ \"(rsc)/../../node_modules/.pnpm/redis-parser@3.0.0/node_modules/redis-parser/index.js\");\nconst SubscriptionSet_1 = __webpack_require__(/*! ./SubscriptionSet */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/SubscriptionSet.js\");\nconst debug = (0, utils_1.Debug)(\"dataHandler\");\nclass DataHandler {\n    constructor(redis, parserOptions) {\n        this.redis = redis;\n        const parser = new RedisParser({\n            stringNumbers: parserOptions.stringNumbers,\n            returnBuffers: true,\n            returnError: (err) => {\n                this.returnError(err);\n            },\n            returnFatalError: (err) => {\n                this.returnFatalError(err);\n            },\n            returnReply: (reply) => {\n                this.returnReply(reply);\n            },\n        });\n        // prependListener ensures the parser receives and processes data before socket timeout checks are performed\n        redis.stream.prependListener(\"data\", (data) => {\n            parser.execute(data);\n        });\n        // prependListener() doesn't enable flowing mode automatically - we need to resume the stream manually\n        redis.stream.resume();\n    }\n    returnFatalError(err) {\n        err.message += \". Please report this.\";\n        this.redis.recoverFromFatalError(err, err, { offlineQueue: false });\n    }\n    returnError(err) {\n        const item = this.shiftCommand(err);\n        if (!item) {\n            return;\n        }\n        err.command = {\n            name: item.command.name,\n            args: item.command.args,\n        };\n        this.redis.handleReconnection(err, item);\n    }\n    returnReply(reply) {\n        if (this.handleMonitorReply(reply)) {\n            return;\n        }\n        if (this.handleSubscriberReply(reply)) {\n            return;\n        }\n        const item = this.shiftCommand(reply);\n        if (!item) {\n            return;\n        }\n        if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", item.command.name)) {\n            this.redis.condition.subscriber = new SubscriptionSet_1.default();\n            this.redis.condition.subscriber.add(item.command.name, reply[1].toString());\n            if (!fillSubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        }\n        else if (Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", item.command.name)) {\n            if (!fillUnsubCommand(item.command, reply[2])) {\n                this.redis.commandQueue.unshift(item);\n            }\n        }\n        else {\n            item.command.resolve(reply);\n        }\n    }\n    handleSubscriberReply(reply) {\n        if (!this.redis.condition.subscriber) {\n            return false;\n        }\n        const replyType = Array.isArray(reply) ? reply[0].toString() : null;\n        debug('receive reply \"%s\" in subscriber mode', replyType);\n        switch (replyType) {\n            case \"message\":\n                if (this.redis.listeners(\"message\").length > 0) {\n                    // Check if there're listeners to avoid unnecessary `toString()`.\n                    this.redis.emit(\"message\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                }\n                this.redis.emit(\"messageBuffer\", reply[1], reply[2]);\n                break;\n            case \"pmessage\": {\n                const pattern = reply[1].toString();\n                if (this.redis.listeners(\"pmessage\").length > 0) {\n                    this.redis.emit(\"pmessage\", pattern, reply[2].toString(), reply[3].toString());\n                }\n                this.redis.emit(\"pmessageBuffer\", pattern, reply[2], reply[3]);\n                break;\n            }\n            case \"smessage\": {\n                if (this.redis.listeners(\"smessage\").length > 0) {\n                    this.redis.emit(\"smessage\", reply[1].toString(), reply[2] ? reply[2].toString() : \"\");\n                }\n                this.redis.emit(\"smessageBuffer\", reply[1], reply[2]);\n                break;\n            }\n            case \"ssubscribe\":\n            case \"subscribe\":\n            case \"psubscribe\": {\n                const channel = reply[1].toString();\n                this.redis.condition.subscriber.add(replyType, channel);\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                if (!fillSubCommand(item.command, reply[2])) {\n                    this.redis.commandQueue.unshift(item);\n                }\n                break;\n            }\n            case \"sunsubscribe\":\n            case \"unsubscribe\":\n            case \"punsubscribe\": {\n                const channel = reply[1] ? reply[1].toString() : null;\n                if (channel) {\n                    this.redis.condition.subscriber.del(replyType, channel);\n                }\n                const count = reply[2];\n                if (Number(count) === 0) {\n                    this.redis.condition.subscriber = false;\n                }\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                if (!fillUnsubCommand(item.command, count)) {\n                    this.redis.commandQueue.unshift(item);\n                }\n                break;\n            }\n            default: {\n                const item = this.shiftCommand(reply);\n                if (!item) {\n                    return;\n                }\n                item.command.resolve(reply);\n            }\n        }\n        return true;\n    }\n    handleMonitorReply(reply) {\n        if (this.redis.status !== \"monitoring\") {\n            return false;\n        }\n        const replyStr = reply.toString();\n        if (replyStr === \"OK\") {\n            // Valid commands in the monitoring mode are AUTH and MONITOR,\n            // both of which always reply with 'OK'.\n            // So if we got an 'OK', we can make certain that\n            // the reply is made to AUTH & MONITOR.\n            return false;\n        }\n        // Since commands sent in the monitoring mode will trigger an exception,\n        // any replies we received in the monitoring mode should consider to be\n        // realtime monitor data instead of result of commands.\n        const len = replyStr.indexOf(\" \");\n        const timestamp = replyStr.slice(0, len);\n        const argIndex = replyStr.indexOf('\"');\n        const args = replyStr\n            .slice(argIndex + 1, -1)\n            .split('\" \"')\n            .map((elem) => elem.replace(/\\\\\"/g, '\"'));\n        const dbAndSource = replyStr.slice(len + 2, argIndex - 2).split(\" \");\n        this.redis.emit(\"monitor\", timestamp, args, dbAndSource[1], dbAndSource[0]);\n        return true;\n    }\n    shiftCommand(reply) {\n        const item = this.redis.commandQueue.shift();\n        if (!item) {\n            const message = \"Command queue state error. If you can reproduce this, please report it.\";\n            const error = new Error(message +\n                (reply instanceof Error\n                    ? ` Last error: ${reply.message}`\n                    : ` Last reply: ${reply.toString()}`));\n            this.redis.emit(\"error\", error);\n            return null;\n        }\n        return item;\n    }\n}\nexports[\"default\"] = DataHandler;\nconst remainingRepliesMap = new WeakMap();\nfunction fillSubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command)\n        ? remainingRepliesMap.get(command)\n        : command.args.length;\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        remainingRepliesMap.delete(command);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\nfunction fillUnsubCommand(command, count) {\n    let remainingReplies = remainingRepliesMap.has(command)\n        ? remainingRepliesMap.get(command)\n        : command.args.length;\n    if (remainingReplies === 0) {\n        if (Number(count) === 0) {\n            remainingRepliesMap.delete(command);\n            command.resolve(count);\n            return true;\n        }\n        return false;\n    }\n    remainingReplies -= 1;\n    if (remainingReplies <= 0) {\n        command.resolve(count);\n        return true;\n    }\n    remainingRepliesMap.set(command, remainingReplies);\n    return false;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvRGF0YUhhbmRsZXIuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsa0JBQWtCLG1CQUFPLENBQUMscUdBQVc7QUFDckMsZ0JBQWdCLG1CQUFPLENBQUMsdUdBQVM7QUFDakMsb0JBQW9CLG1CQUFPLENBQUMsMEdBQWM7QUFDMUMsMEJBQTBCLG1CQUFPLENBQUMscUhBQW1CO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELHFCQUFxQjtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRCxzQ0FBc0MsaUJBQWlCO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L0RhdGFIYW5kbGVyLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IFJlZGlzUGFyc2VyID0gcmVxdWlyZShcInJlZGlzLXBhcnNlclwiKTtcbmNvbnN0IFN1YnNjcmlwdGlvblNldF8xID0gcmVxdWlyZShcIi4vU3Vic2NyaXB0aW9uU2V0XCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJkYXRhSGFuZGxlclwiKTtcbmNsYXNzIERhdGFIYW5kbGVyIHtcbiAgICBjb25zdHJ1Y3RvcihyZWRpcywgcGFyc2VyT3B0aW9ucykge1xuICAgICAgICB0aGlzLnJlZGlzID0gcmVkaXM7XG4gICAgICAgIGNvbnN0IHBhcnNlciA9IG5ldyBSZWRpc1BhcnNlcih7XG4gICAgICAgICAgICBzdHJpbmdOdW1iZXJzOiBwYXJzZXJPcHRpb25zLnN0cmluZ051bWJlcnMsXG4gICAgICAgICAgICByZXR1cm5CdWZmZXJzOiB0cnVlLFxuICAgICAgICAgICAgcmV0dXJuRXJyb3I6IChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVybkVycm9yKGVycik7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgcmV0dXJuRmF0YWxFcnJvcjogKGVycikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMucmV0dXJuRmF0YWxFcnJvcihlcnIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHJldHVyblJlcGx5OiAocmVwbHkpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJldHVyblJlcGx5KHJlcGx5KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBwcmVwZW5kTGlzdGVuZXIgZW5zdXJlcyB0aGUgcGFyc2VyIHJlY2VpdmVzIGFuZCBwcm9jZXNzZXMgZGF0YSBiZWZvcmUgc29ja2V0IHRpbWVvdXQgY2hlY2tzIGFyZSBwZXJmb3JtZWRcbiAgICAgICAgcmVkaXMuc3RyZWFtLnByZXBlbmRMaXN0ZW5lcihcImRhdGFcIiwgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHBhcnNlci5leGVjdXRlKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gcHJlcGVuZExpc3RlbmVyKCkgZG9lc24ndCBlbmFibGUgZmxvd2luZyBtb2RlIGF1dG9tYXRpY2FsbHkgLSB3ZSBuZWVkIHRvIHJlc3VtZSB0aGUgc3RyZWFtIG1hbnVhbGx5XG4gICAgICAgIHJlZGlzLnN0cmVhbS5yZXN1bWUoKTtcbiAgICB9XG4gICAgcmV0dXJuRmF0YWxFcnJvcihlcnIpIHtcbiAgICAgICAgZXJyLm1lc3NhZ2UgKz0gXCIuIFBsZWFzZSByZXBvcnQgdGhpcy5cIjtcbiAgICAgICAgdGhpcy5yZWRpcy5yZWNvdmVyRnJvbUZhdGFsRXJyb3IoZXJyLCBlcnIsIHsgb2ZmbGluZVF1ZXVlOiBmYWxzZSB9KTtcbiAgICB9XG4gICAgcmV0dXJuRXJyb3IoZXJyKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSB0aGlzLnNoaWZ0Q29tbWFuZChlcnIpO1xuICAgICAgICBpZiAoIWl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBlcnIuY29tbWFuZCA9IHtcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0uY29tbWFuZC5uYW1lLFxuICAgICAgICAgICAgYXJnczogaXRlbS5jb21tYW5kLmFyZ3MsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMucmVkaXMuaGFuZGxlUmVjb25uZWN0aW9uKGVyciwgaXRlbSk7XG4gICAgfVxuICAgIHJldHVyblJlcGx5KHJlcGx5KSB7XG4gICAgICAgIGlmICh0aGlzLmhhbmRsZU1vbml0b3JSZXBseShyZXBseSkpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oYW5kbGVTdWJzY3JpYmVyUmVwbHkocmVwbHkpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbSA9IHRoaXMuc2hpZnRDb21tYW5kKHJlcGx5KTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKENvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIkVOVEVSX1NVQlNDUklCRVJfTU9ERVwiLCBpdGVtLmNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIgPSBuZXcgU3Vic2NyaXB0aW9uU2V0XzEuZGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlci5hZGQoaXRlbS5jb21tYW5kLm5hbWUsIHJlcGx5WzFdLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgaWYgKCFmaWxsU3ViQ29tbWFuZChpdGVtLmNvbW1hbmQsIHJlcGx5WzJdKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29tbWFuZFF1ZXVlLnVuc2hpZnQoaXRlbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiRVhJVF9TVUJTQ1JJQkVSX01PREVcIiwgaXRlbS5jb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoIWZpbGxVbnN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlc29sdmUocmVwbHkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGhhbmRsZVN1YnNjcmliZXJSZXBseShyZXBseSkge1xuICAgICAgICBpZiAoIXRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseVR5cGUgPSBBcnJheS5pc0FycmF5KHJlcGx5KSA/IHJlcGx5WzBdLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICBkZWJ1ZygncmVjZWl2ZSByZXBseSBcIiVzXCIgaW4gc3Vic2NyaWJlciBtb2RlJywgcmVwbHlUeXBlKTtcbiAgICAgICAgc3dpdGNoIChyZXBseVR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJtZXNzYWdlXCI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwibWVzc2FnZVwiKS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZXJlJ3JlIGxpc3RlbmVycyB0byBhdm9pZCB1bm5lY2Vzc2FyeSBgdG9TdHJpbmcoKWAuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcIm1lc3NhZ2VcIiwgcmVwbHlbMV0udG9TdHJpbmcoKSwgcmVwbHlbMl0gPyByZXBseVsyXS50b1N0cmluZygpIDogXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZW1pdChcIm1lc3NhZ2VCdWZmZXJcIiwgcmVwbHlbMV0sIHJlcGx5WzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJwbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGF0dGVybiA9IHJlcGx5WzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwicG1lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJwbWVzc2FnZVwiLCBwYXR0ZXJuLCByZXBseVsyXS50b1N0cmluZygpLCByZXBseVszXS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwicG1lc3NhZ2VCdWZmZXJcIiwgcGF0dGVybiwgcmVwbHlbMl0sIHJlcGx5WzNdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzbWVzc2FnZVwiOiB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMucmVkaXMubGlzdGVuZXJzKFwic21lc3NhZ2VcIikubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJzbWVzc2FnZVwiLCByZXBseVsxXS50b1N0cmluZygpLCByZXBseVsyXSA/IHJlcGx5WzJdLnRvU3RyaW5nKCkgOiBcIlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwic21lc3NhZ2VCdWZmZXJcIiwgcmVwbHlbMV0sIHJlcGx5WzJdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJzc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwic3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwicHN1YnNjcmliZVwiOiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2hhbm5lbCA9IHJlcGx5WzFdLnRvU3RyaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlci5hZGQocmVwbHlUeXBlLCBjaGFubmVsKTtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlsbFN1YkNvbW1hbmQoaXRlbS5jb21tYW5kLCByZXBseVsyXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb21tYW5kUXVldWUudW5zaGlmdChpdGVtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwic3Vuc3Vic2NyaWJlXCI6XG4gICAgICAgICAgICBjYXNlIFwidW5zdWJzY3JpYmVcIjpcbiAgICAgICAgICAgIGNhc2UgXCJwdW5zdWJzY3JpYmVcIjoge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNoYW5uZWwgPSByZXBseVsxXSA/IHJlcGx5WzFdLnRvU3RyaW5nKCkgOiBudWxsO1xuICAgICAgICAgICAgICAgIGlmIChjaGFubmVsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuY29uZGl0aW9uLnN1YnNjcmliZXIuZGVsKHJlcGx5VHlwZSwgY2hhbm5lbCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvdW50ID0gcmVwbHlbMl07XG4gICAgICAgICAgICAgICAgaWYgKE51bWJlcihjb3VudCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZWRpcy5jb25kaXRpb24uc3Vic2NyaWJlciA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghZmlsbFVuc3ViQ29tbWFuZChpdGVtLmNvbW1hbmQsIGNvdW50KSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbW1hbmRRdWV1ZS51bnNoaWZ0KGl0ZW0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5zaGlmdENvbW1hbmQocmVwbHkpO1xuICAgICAgICAgICAgICAgIGlmICghaXRlbSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZXNvbHZlKHJlcGx5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgaGFuZGxlTW9uaXRvclJlcGx5KHJlcGx5KSB7XG4gICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyAhPT0gXCJtb25pdG9yaW5nXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXBseVN0ciA9IHJlcGx5LnRvU3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXBseVN0ciA9PT0gXCJPS1wiKSB7XG4gICAgICAgICAgICAvLyBWYWxpZCBjb21tYW5kcyBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIGFyZSBBVVRIIGFuZCBNT05JVE9SLFxuICAgICAgICAgICAgLy8gYm90aCBvZiB3aGljaCBhbHdheXMgcmVwbHkgd2l0aCAnT0snLlxuICAgICAgICAgICAgLy8gU28gaWYgd2UgZ290IGFuICdPSycsIHdlIGNhbiBtYWtlIGNlcnRhaW4gdGhhdFxuICAgICAgICAgICAgLy8gdGhlIHJlcGx5IGlzIG1hZGUgdG8gQVVUSCAmIE1PTklUT1IuXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2luY2UgY29tbWFuZHMgc2VudCBpbiB0aGUgbW9uaXRvcmluZyBtb2RlIHdpbGwgdHJpZ2dlciBhbiBleGNlcHRpb24sXG4gICAgICAgIC8vIGFueSByZXBsaWVzIHdlIHJlY2VpdmVkIGluIHRoZSBtb25pdG9yaW5nIG1vZGUgc2hvdWxkIGNvbnNpZGVyIHRvIGJlXG4gICAgICAgIC8vIHJlYWx0aW1lIG1vbml0b3IgZGF0YSBpbnN0ZWFkIG9mIHJlc3VsdCBvZiBjb21tYW5kcy5cbiAgICAgICAgY29uc3QgbGVuID0gcmVwbHlTdHIuaW5kZXhPZihcIiBcIik7XG4gICAgICAgIGNvbnN0IHRpbWVzdGFtcCA9IHJlcGx5U3RyLnNsaWNlKDAsIGxlbik7XG4gICAgICAgIGNvbnN0IGFyZ0luZGV4ID0gcmVwbHlTdHIuaW5kZXhPZignXCInKTtcbiAgICAgICAgY29uc3QgYXJncyA9IHJlcGx5U3RyXG4gICAgICAgICAgICAuc2xpY2UoYXJnSW5kZXggKyAxLCAtMSlcbiAgICAgICAgICAgIC5zcGxpdCgnXCIgXCInKVxuICAgICAgICAgICAgLm1hcCgoZWxlbSkgPT4gZWxlbS5yZXBsYWNlKC9cXFxcXCIvZywgJ1wiJykpO1xuICAgICAgICBjb25zdCBkYkFuZFNvdXJjZSA9IHJlcGx5U3RyLnNsaWNlKGxlbiArIDIsIGFyZ0luZGV4IC0gMikuc3BsaXQoXCIgXCIpO1xuICAgICAgICB0aGlzLnJlZGlzLmVtaXQoXCJtb25pdG9yXCIsIHRpbWVzdGFtcCwgYXJncywgZGJBbmRTb3VyY2VbMV0sIGRiQW5kU291cmNlWzBdKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHNoaWZ0Q29tbWFuZChyZXBseSkge1xuICAgICAgICBjb25zdCBpdGVtID0gdGhpcy5yZWRpcy5jb21tYW5kUXVldWUuc2hpZnQoKTtcbiAgICAgICAgaWYgKCFpdGVtKSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlID0gXCJDb21tYW5kIHF1ZXVlIHN0YXRlIGVycm9yLiBJZiB5b3UgY2FuIHJlcHJvZHVjZSB0aGlzLCBwbGVhc2UgcmVwb3J0IGl0LlwiO1xuICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgRXJyb3IobWVzc2FnZSArXG4gICAgICAgICAgICAgICAgKHJlcGx5IGluc3RhbmNlb2YgRXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBgIExhc3QgZXJyb3I6ICR7cmVwbHkubWVzc2FnZX1gXG4gICAgICAgICAgICAgICAgICAgIDogYCBMYXN0IHJlcGx5OiAke3JlcGx5LnRvU3RyaW5nKCl9YCkpO1xuICAgICAgICAgICAgdGhpcy5yZWRpcy5lbWl0KFwiZXJyb3JcIiwgZXJyb3IpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gRGF0YUhhbmRsZXI7XG5jb25zdCByZW1haW5pbmdSZXBsaWVzTWFwID0gbmV3IFdlYWtNYXAoKTtcbmZ1bmN0aW9uIGZpbGxTdWJDb21tYW5kKGNvbW1hbmQsIGNvdW50KSB7XG4gICAgbGV0IHJlbWFpbmluZ1JlcGxpZXMgPSByZW1haW5pbmdSZXBsaWVzTWFwLmhhcyhjb21tYW5kKVxuICAgICAgICA/IHJlbWFpbmluZ1JlcGxpZXNNYXAuZ2V0KGNvbW1hbmQpXG4gICAgICAgIDogY29tbWFuZC5hcmdzLmxlbmd0aDtcbiAgICByZW1haW5pbmdSZXBsaWVzIC09IDE7XG4gICAgaWYgKHJlbWFpbmluZ1JlcGxpZXMgPD0gMCkge1xuICAgICAgICBjb21tYW5kLnJlc29sdmUoY291bnQpO1xuICAgICAgICByZW1haW5pbmdSZXBsaWVzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHJlbWFpbmluZ1JlcGxpZXNNYXAuc2V0KGNvbW1hbmQsIHJlbWFpbmluZ1JlcGxpZXMpO1xuICAgIHJldHVybiBmYWxzZTtcbn1cbmZ1bmN0aW9uIGZpbGxVbnN1YkNvbW1hbmQoY29tbWFuZCwgY291bnQpIHtcbiAgICBsZXQgcmVtYWluaW5nUmVwbGllcyA9IHJlbWFpbmluZ1JlcGxpZXNNYXAuaGFzKGNvbW1hbmQpXG4gICAgICAgID8gcmVtYWluaW5nUmVwbGllc01hcC5nZXQoY29tbWFuZClcbiAgICAgICAgOiBjb21tYW5kLmFyZ3MubGVuZ3RoO1xuICAgIGlmIChyZW1haW5pbmdSZXBsaWVzID09PSAwKSB7XG4gICAgICAgIGlmIChOdW1iZXIoY291bnQpID09PSAwKSB7XG4gICAgICAgICAgICByZW1haW5pbmdSZXBsaWVzTWFwLmRlbGV0ZShjb21tYW5kKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJlbWFpbmluZ1JlcGxpZXMgLT0gMTtcbiAgICBpZiAocmVtYWluaW5nUmVwbGllcyA8PSAwKSB7XG4gICAgICAgIGNvbW1hbmQucmVzb2x2ZShjb3VudCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZW1haW5pbmdSZXBsaWVzTWFwLnNldChjb21tYW5kLCByZW1haW5pbmdSZXBsaWVzKTtcbiAgICByZXR1cm4gZmFsc2U7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/DataHandler.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Pipeline.js":
/*!*************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Pipeline.js ***!
  \*************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/../../node_modules/.pnpm/cluster-key-slot@1.1.2/node_modules/cluster-key-slot/lib/index.js\");\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/../../node_modules/.pnpm/@ioredis+commands@1.2.0/node_modules/@ioredis/commands/built/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/Commander.js\");\n/*\n  This function derives from the cluster-key-slot implementation.\n  Instead of checking that all keys have the same slot, it checks that all slots are served by the same set of nodes.\n  If this is satisfied, it returns the first key's slot.\n*/\nfunction generateMultiWithNodes(redis, keys) {\n    const slot = calculateSlot(keys[0]);\n    const target = redis._groupsBySlot[slot];\n    for (let i = 1; i < keys.length; i++) {\n        if (redis._groupsBySlot[calculateSlot(keys[i])] !== target) {\n            return -1;\n        }\n    }\n    return slot;\n}\nclass Pipeline extends Commander_1.default {\n    constructor(redis) {\n        super();\n        this.redis = redis;\n        this.isPipeline = true;\n        this.replyPending = 0;\n        this._queue = [];\n        this._result = [];\n        this._transactions = 0;\n        this._shaToScript = {};\n        this.isCluster =\n            this.redis.constructor.name === \"Cluster\" || this.redis.isCluster;\n        this.options = redis.options;\n        Object.keys(redis.scriptsSet).forEach((name) => {\n            const script = redis.scriptsSet[name];\n            this._shaToScript[script.sha] = script;\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        redis.addedBuiltinSet.forEach((name) => {\n            this[name] = redis[name];\n            this[name + \"Buffer\"] = redis[name + \"Buffer\"];\n        });\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = resolve;\n            this.reject = reject;\n        });\n        const _this = this;\n        Object.defineProperty(this, \"length\", {\n            get: function () {\n                return _this._queue.length;\n            },\n        });\n    }\n    fillResult(value, position) {\n        if (this._queue[position].name === \"exec\" && Array.isArray(value[1])) {\n            const execLength = value[1].length;\n            for (let i = 0; i < execLength; i++) {\n                if (value[1][i] instanceof Error) {\n                    continue;\n                }\n                const cmd = this._queue[position - (execLength - i)];\n                try {\n                    value[1][i] = cmd.transformReply(value[1][i]);\n                }\n                catch (err) {\n                    value[1][i] = err;\n                }\n            }\n        }\n        this._result[position] = value;\n        if (--this.replyPending) {\n            return;\n        }\n        if (this.isCluster) {\n            let retriable = true;\n            let commonError;\n            for (let i = 0; i < this._result.length; ++i) {\n                const error = this._result[i][0];\n                const command = this._queue[i];\n                if (error) {\n                    if (command.name === \"exec\" &&\n                        error.message ===\n                            \"EXECABORT Transaction discarded because of previous errors.\") {\n                        continue;\n                    }\n                    if (!commonError) {\n                        commonError = {\n                            name: error.name,\n                            message: error.message,\n                        };\n                    }\n                    else if (commonError.name !== error.name ||\n                        commonError.message !== error.message) {\n                        retriable = false;\n                        break;\n                    }\n                }\n                else if (!command.inTransaction) {\n                    const isReadOnly = (0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\");\n                    if (!isReadOnly) {\n                        retriable = false;\n                        break;\n                    }\n                }\n            }\n            if (commonError && retriable) {\n                const _this = this;\n                const errv = commonError.message.split(\" \");\n                const queue = this._queue;\n                let inTransaction = false;\n                this._queue = [];\n                for (let i = 0; i < queue.length; ++i) {\n                    if (errv[0] === \"ASK\" &&\n                        !inTransaction &&\n                        queue[i].name !== \"asking\" &&\n                        (!queue[i - 1] || queue[i - 1].name !== \"asking\")) {\n                        const asking = new Command_1.default(\"asking\");\n                        asking.ignore = true;\n                        this.sendCommand(asking);\n                    }\n                    queue[i].initPromise();\n                    this.sendCommand(queue[i]);\n                    inTransaction = queue[i].inTransaction;\n                }\n                let matched = true;\n                if (typeof this.leftRedirections === \"undefined\") {\n                    this.leftRedirections = {};\n                }\n                const exec = function () {\n                    _this.exec();\n                };\n                const cluster = this.redis;\n                cluster.handleError(commonError, this.leftRedirections, {\n                    moved: function (_slot, key) {\n                        _this.preferKey = key;\n                        cluster.slots[errv[1]] = [key];\n                        cluster._groupsBySlot[errv[1]] =\n                            cluster._groupsIds[cluster.slots[errv[1]].join(\";\")];\n                        cluster.refreshSlotsCache();\n                        _this.exec();\n                    },\n                    ask: function (_slot, key) {\n                        _this.preferKey = key;\n                        _this.exec();\n                    },\n                    tryagain: exec,\n                    clusterDown: exec,\n                    connectionClosed: exec,\n                    maxRedirections: () => {\n                        matched = false;\n                    },\n                    defaults: () => {\n                        matched = false;\n                    },\n                });\n                if (matched) {\n                    return;\n                }\n            }\n        }\n        let ignoredCount = 0;\n        for (let i = 0; i < this._queue.length - ignoredCount; ++i) {\n            if (this._queue[i + ignoredCount].ignore) {\n                ignoredCount += 1;\n            }\n            this._result[i] = this._result[i + ignoredCount];\n        }\n        this.resolve(this._result.slice(0, this._result.length - ignoredCount));\n    }\n    sendCommand(command) {\n        if (this._transactions > 0) {\n            command.inTransaction = true;\n        }\n        const position = this._queue.length;\n        command.pipelineIndex = position;\n        command.promise\n            .then((result) => {\n            this.fillResult([null, result], position);\n        })\n            .catch((error) => {\n            this.fillResult([error], position);\n        });\n        this._queue.push(command);\n        return this;\n    }\n    addBatch(commands) {\n        let command, commandName, args;\n        for (let i = 0; i < commands.length; ++i) {\n            command = commands[i];\n            commandName = command[0];\n            args = command.slice(1);\n            this[commandName].apply(this, args);\n        }\n        return this;\n    }\n}\nexports[\"default\"] = Pipeline;\n// @ts-expect-error\nconst multi = Pipeline.prototype.multi;\n// @ts-expect-error\nPipeline.prototype.multi = function () {\n    this._transactions += 1;\n    return multi.apply(this, arguments);\n};\n// @ts-expect-error\nconst execBuffer = Pipeline.prototype.execBuffer;\n// @ts-expect-error\nPipeline.prototype.execBuffer = (0, util_1.deprecate)(function () {\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n    }\n    return execBuffer.apply(this, arguments);\n}, \"Pipeline#execBuffer: Use Pipeline#exec instead\");\n// NOTE: To avoid an unhandled promise rejection, this will unconditionally always return this.promise,\n// which always has the rejection handled by standard-as-callback\n// adding the provided rejection callback.\n//\n// If a different promise instance were returned, that promise would cause its own unhandled promise rejection\n// errors, even if that promise unconditionally resolved to **the resolved value of** this.promise.\nPipeline.prototype.exec = function (callback) {\n    // Wait for the cluster to be connected, since we need nodes information before continuing\n    if (this.isCluster && !this.redis.slots.length) {\n        if (this.redis.status === \"wait\")\n            this.redis.connect().catch(utils_1.noop);\n        if (callback && !this.nodeifiedPromise) {\n            this.nodeifiedPromise = true;\n            (0, standard_as_callback_1.default)(this.promise, callback);\n        }\n        this.redis.delayUntilReady((err) => {\n            if (err) {\n                this.reject(err);\n                return;\n            }\n            this.exec(callback);\n        });\n        return this.promise;\n    }\n    if (this._transactions > 0) {\n        this._transactions -= 1;\n        return execBuffer.apply(this, arguments);\n    }\n    if (!this.nodeifiedPromise) {\n        this.nodeifiedPromise = true;\n        (0, standard_as_callback_1.default)(this.promise, callback);\n    }\n    if (!this._queue.length) {\n        this.resolve([]);\n    }\n    let pipelineSlot;\n    if (this.isCluster) {\n        // List of the first key for each command\n        const sampleKeys = [];\n        for (let i = 0; i < this._queue.length; i++) {\n            const keys = this._queue[i].getKeys();\n            if (keys.length) {\n                sampleKeys.push(keys[0]);\n            }\n            // For each command, check that the keys belong to the same slot\n            if (keys.length && calculateSlot.generateMulti(keys) < 0) {\n                this.reject(new Error(\"All the keys in a pipeline command should belong to the same slot\"));\n                return this.promise;\n            }\n        }\n        if (sampleKeys.length) {\n            pipelineSlot = generateMultiWithNodes(this.redis, sampleKeys);\n            if (pipelineSlot < 0) {\n                this.reject(new Error(\"All keys in the pipeline should belong to the same slots allocation group\"));\n                return this.promise;\n            }\n        }\n        else {\n            // Send the pipeline to a random node\n            pipelineSlot = (Math.random() * 16384) | 0;\n        }\n    }\n    const _this = this;\n    execPipeline();\n    return this.promise;\n    function execPipeline() {\n        let writePending = (_this.replyPending = _this._queue.length);\n        let node;\n        if (_this.isCluster) {\n            node = {\n                slot: pipelineSlot,\n                redis: _this.redis.connectionPool.nodes.all[_this.preferKey],\n            };\n        }\n        let data = \"\";\n        let buffers;\n        const stream = {\n            isPipeline: true,\n            destination: _this.isCluster ? node : { redis: _this.redis },\n            write(writable) {\n                if (typeof writable !== \"string\") {\n                    if (!buffers) {\n                        buffers = [];\n                    }\n                    if (data) {\n                        buffers.push(Buffer.from(data, \"utf8\"));\n                        data = \"\";\n                    }\n                    buffers.push(writable);\n                }\n                else {\n                    data += writable;\n                }\n                if (!--writePending) {\n                    if (buffers) {\n                        if (data) {\n                            buffers.push(Buffer.from(data, \"utf8\"));\n                        }\n                        stream.destination.redis.stream.write(Buffer.concat(buffers));\n                    }\n                    else {\n                        stream.destination.redis.stream.write(data);\n                    }\n                    // Reset writePending for resending\n                    writePending = _this._queue.length;\n                    data = \"\";\n                    buffers = undefined;\n                }\n            },\n        };\n        for (let i = 0; i < _this._queue.length; ++i) {\n            _this.redis.sendCommand(_this._queue[i], stream, node);\n        }\n        return _this.promise;\n    }\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvUGlwZWxpbmUuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0Qsc0JBQXNCLG1CQUFPLENBQUMsMEhBQWtCO0FBQ2hELG1CQUFtQixtQkFBTyxDQUFDLCtIQUFtQjtBQUM5QywrQkFBK0IsbUJBQU8sQ0FBQyx3SUFBc0I7QUFDN0QsZUFBZSxtQkFBTyxDQUFDLGtCQUFNO0FBQzdCLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3JDLGdCQUFnQixtQkFBTyxDQUFDLHVHQUFTO0FBQ2pDLG9CQUFvQixtQkFBTyxDQUFDLHFIQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsZ0JBQWdCO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHlCQUF5QjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkU7QUFDN0U7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsdUNBQXVDO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLHdCQUF3QjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELG9CQUFvQjtBQUN4RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0Esd0JBQXdCLHlCQUF5QjtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9QaXBlbGluZS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNhbGN1bGF0ZVNsb3QgPSByZXF1aXJlKFwiY2x1c3Rlci1rZXktc2xvdFwiKTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuY29uc3QgdXRpbF8xID0gcmVxdWlyZShcInV0aWxcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuL3V0aWxzXCIpO1xuY29uc3QgQ29tbWFuZGVyXzEgPSByZXF1aXJlKFwiLi91dGlscy9Db21tYW5kZXJcIik7XG4vKlxuICBUaGlzIGZ1bmN0aW9uIGRlcml2ZXMgZnJvbSB0aGUgY2x1c3Rlci1rZXktc2xvdCBpbXBsZW1lbnRhdGlvbi5cbiAgSW5zdGVhZCBvZiBjaGVja2luZyB0aGF0IGFsbCBrZXlzIGhhdmUgdGhlIHNhbWUgc2xvdCwgaXQgY2hlY2tzIHRoYXQgYWxsIHNsb3RzIGFyZSBzZXJ2ZWQgYnkgdGhlIHNhbWUgc2V0IG9mIG5vZGVzLlxuICBJZiB0aGlzIGlzIHNhdGlzZmllZCwgaXQgcmV0dXJucyB0aGUgZmlyc3Qga2V5J3Mgc2xvdC5cbiovXG5mdW5jdGlvbiBnZW5lcmF0ZU11bHRpV2l0aE5vZGVzKHJlZGlzLCBrZXlzKSB7XG4gICAgY29uc3Qgc2xvdCA9IGNhbGN1bGF0ZVNsb3Qoa2V5c1swXSk7XG4gICAgY29uc3QgdGFyZ2V0ID0gcmVkaXMuX2dyb3Vwc0J5U2xvdFtzbG90XTtcbiAgICBmb3IgKGxldCBpID0gMTsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKHJlZGlzLl9ncm91cHNCeVNsb3RbY2FsY3VsYXRlU2xvdChrZXlzW2ldKV0gIT09IHRhcmdldCkge1xuICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzbG90O1xufVxuY2xhc3MgUGlwZWxpbmUgZXh0ZW5kcyBDb21tYW5kZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihyZWRpcykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZGlzID0gcmVkaXM7XG4gICAgICAgIHRoaXMuaXNQaXBlbGluZSA9IHRydWU7XG4gICAgICAgIHRoaXMucmVwbHlQZW5kaW5nID0gMDtcbiAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgdGhpcy5fcmVzdWx0ID0gW107XG4gICAgICAgIHRoaXMuX3RyYW5zYWN0aW9ucyA9IDA7XG4gICAgICAgIHRoaXMuX3NoYVRvU2NyaXB0ID0ge307XG4gICAgICAgIHRoaXMuaXNDbHVzdGVyID1cbiAgICAgICAgICAgIHRoaXMucmVkaXMuY29uc3RydWN0b3IubmFtZSA9PT0gXCJDbHVzdGVyXCIgfHwgdGhpcy5yZWRpcy5pc0NsdXN0ZXI7XG4gICAgICAgIHRoaXMub3B0aW9ucyA9IHJlZGlzLm9wdGlvbnM7XG4gICAgICAgIE9iamVjdC5rZXlzKHJlZGlzLnNjcmlwdHNTZXQpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHNjcmlwdCA9IHJlZGlzLnNjcmlwdHNTZXRbbmFtZV07XG4gICAgICAgICAgICB0aGlzLl9zaGFUb1NjcmlwdFtzY3JpcHQuc2hhXSA9IHNjcmlwdDtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSByZWRpc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXNbbmFtZSArIFwiQnVmZmVyXCJdID0gcmVkaXNbbmFtZSArIFwiQnVmZmVyXCJdO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVkaXMuYWRkZWRCdWlsdGluU2V0LmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgIHRoaXNbbmFtZV0gPSByZWRpc1tuYW1lXTtcbiAgICAgICAgICAgIHRoaXNbbmFtZSArIFwiQnVmZmVyXCJdID0gcmVkaXNbbmFtZSArIFwiQnVmZmVyXCJdO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlID0gcmVzb2x2ZTtcbiAgICAgICAgICAgIHRoaXMucmVqZWN0ID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJsZW5ndGhcIiwge1xuICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZmlsbFJlc3VsdCh2YWx1ZSwgcG9zaXRpb24pIHtcbiAgICAgICAgaWYgKHRoaXMuX3F1ZXVlW3Bvc2l0aW9uXS5uYW1lID09PSBcImV4ZWNcIiAmJiBBcnJheS5pc0FycmF5KHZhbHVlWzFdKSkge1xuICAgICAgICAgICAgY29uc3QgZXhlY0xlbmd0aCA9IHZhbHVlWzFdLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXhlY0xlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlWzFdW2ldIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNtZCA9IHRoaXMuX3F1ZXVlW3Bvc2l0aW9uIC0gKGV4ZWNMZW5ndGggLSBpKV07XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVbMV1baV0gPSBjbWQudHJhbnNmb3JtUmVwbHkodmFsdWVbMV1baV0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlWzFdW2ldID0gZXJyO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZXN1bHRbcG9zaXRpb25dID0gdmFsdWU7XG4gICAgICAgIGlmICgtLXRoaXMucmVwbHlQZW5kaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNDbHVzdGVyKSB7XG4gICAgICAgICAgICBsZXQgcmV0cmlhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgIGxldCBjb21tb25FcnJvcjtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGhpcy5fcmVzdWx0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSB0aGlzLl9yZXN1bHRbaV1bMF07XG4gICAgICAgICAgICAgICAgY29uc3QgY29tbWFuZCA9IHRoaXMuX3F1ZXVlW2ldO1xuICAgICAgICAgICAgICAgIGlmIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcImV4ZWNcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3IubWVzc2FnZSA9PT1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIkVYRUNBQk9SVCBUcmFuc2FjdGlvbiBkaXNjYXJkZWQgYmVjYXVzZSBvZiBwcmV2aW91cyBlcnJvcnMuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICghY29tbW9uRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbW1vbkVycm9yID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IGVycm9yLm5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoY29tbW9uRXJyb3IubmFtZSAhPT0gZXJyb3IubmFtZSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgY29tbW9uRXJyb3IubWVzc2FnZSAhPT0gZXJyb3IubWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0cmlhYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghY29tbWFuZC5pblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGlzUmVhZE9ubHkgPSAoMCwgY29tbWFuZHNfMS5leGlzdHMpKGNvbW1hbmQubmFtZSkgJiYgKDAsIGNvbW1hbmRzXzEuaGFzRmxhZykoY29tbWFuZC5uYW1lLCBcInJlYWRvbmx5XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWlzUmVhZE9ubHkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHJpYWJsZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoY29tbW9uRXJyb3IgJiYgcmV0cmlhYmxlKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycnYgPSBjb21tb25FcnJvci5tZXNzYWdlLnNwbGl0KFwiIFwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMuX3F1ZXVlO1xuICAgICAgICAgICAgICAgIGxldCBpblRyYW5zYWN0aW9uID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgdGhpcy5fcXVldWUgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnJ2WzBdID09PSBcIkFTS1wiICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhaW5UcmFuc2FjdGlvbiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgcXVldWVbaV0ubmFtZSAhPT0gXCJhc2tpbmdcIiAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKCFxdWV1ZVtpIC0gMV0gfHwgcXVldWVbaSAtIDFdLm5hbWUgIT09IFwiYXNraW5nXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBhc2tpbmcgPSBuZXcgQ29tbWFuZF8xLmRlZmF1bHQoXCJhc2tpbmdcIik7XG4gICAgICAgICAgICAgICAgICAgICAgICBhc2tpbmcuaWdub3JlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VuZENvbW1hbmQoYXNraW5nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBxdWV1ZVtpXS5pbml0UHJvbWlzZSgpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKHF1ZXVlW2ldKTtcbiAgICAgICAgICAgICAgICAgICAgaW5UcmFuc2FjdGlvbiA9IHF1ZXVlW2ldLmluVHJhbnNhY3Rpb247XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxldCBtYXRjaGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRoaXMubGVmdFJlZGlyZWN0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmxlZnRSZWRpcmVjdGlvbnMgPSB7fTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgZXhlYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXhlYygpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgY29uc3QgY2x1c3RlciA9IHRoaXMucmVkaXM7XG4gICAgICAgICAgICAgICAgY2x1c3Rlci5oYW5kbGVFcnJvcihjb21tb25FcnJvciwgdGhpcy5sZWZ0UmVkaXJlY3Rpb25zLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkOiBmdW5jdGlvbiAoX3Nsb3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucHJlZmVyS2V5ID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5zbG90c1tlcnJ2WzFdXSA9IFtrZXldO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2x1c3Rlci5fZ3JvdXBzQnlTbG90W2VycnZbMV1dID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLl9ncm91cHNJZHNbY2x1c3Rlci5zbG90c1tlcnJ2WzFdXS5qb2luKFwiO1wiKV07XG4gICAgICAgICAgICAgICAgICAgICAgICBjbHVzdGVyLnJlZnJlc2hTbG90c0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzazogZnVuY3Rpb24gKF9zbG90LCBrZXkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnByZWZlcktleSA9IGtleTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgdHJ5YWdhaW46IGV4ZWMsXG4gICAgICAgICAgICAgICAgICAgIGNsdXN0ZXJEb3duOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uQ2xvc2VkOiBleGVjLFxuICAgICAgICAgICAgICAgICAgICBtYXhSZWRpcmVjdGlvbnM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdHM6ICgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoZWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICBpZiAobWF0Y2hlZCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGxldCBpZ25vcmVkQ291bnQgPSAwO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHRoaXMuX3F1ZXVlLmxlbmd0aCAtIGlnbm9yZWRDb3VudDsgKytpKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fcXVldWVbaSArIGlnbm9yZWRDb3VudF0uaWdub3JlKSB7XG4gICAgICAgICAgICAgICAgaWdub3JlZENvdW50ICs9IDE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLl9yZXN1bHRbaV0gPSB0aGlzLl9yZXN1bHRbaSArIGlnbm9yZWRDb3VudF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5yZXNvbHZlKHRoaXMuX3Jlc3VsdC5zbGljZSgwLCB0aGlzLl9yZXN1bHQubGVuZ3RoIC0gaWdub3JlZENvdW50KSk7XG4gICAgfVxuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQpIHtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgICAgIGNvbW1hbmQuaW5UcmFuc2FjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSB0aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgIGNvbW1hbmQucGlwZWxpbmVJbmRleCA9IHBvc2l0aW9uO1xuICAgICAgICBjb21tYW5kLnByb21pc2VcbiAgICAgICAgICAgIC50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZmlsbFJlc3VsdChbbnVsbCwgcmVzdWx0XSwgcG9zaXRpb24pO1xuICAgICAgICB9KVxuICAgICAgICAgICAgLmNhdGNoKChlcnJvcikgPT4ge1xuICAgICAgICAgICAgdGhpcy5maWxsUmVzdWx0KFtlcnJvcl0sIHBvc2l0aW9uKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3F1ZXVlLnB1c2goY29tbWFuZCk7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgICBhZGRCYXRjaChjb21tYW5kcykge1xuICAgICAgICBsZXQgY29tbWFuZCwgY29tbWFuZE5hbWUsIGFyZ3M7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgIGNvbW1hbmQgPSBjb21tYW5kc1tpXTtcbiAgICAgICAgICAgIGNvbW1hbmROYW1lID0gY29tbWFuZFswXTtcbiAgICAgICAgICAgIGFyZ3MgPSBjb21tYW5kLnNsaWNlKDEpO1xuICAgICAgICAgICAgdGhpc1tjb21tYW5kTmFtZV0uYXBwbHkodGhpcywgYXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gUGlwZWxpbmU7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBtdWx0aSA9IFBpcGVsaW5lLnByb3RvdHlwZS5tdWx0aTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcblBpcGVsaW5lLnByb3RvdHlwZS5tdWx0aSA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLl90cmFuc2FjdGlvbnMgKz0gMTtcbiAgICByZXR1cm4gbXVsdGkuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbn07XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5jb25zdCBleGVjQnVmZmVyID0gUGlwZWxpbmUucHJvdG90eXBlLmV4ZWNCdWZmZXI7XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5QaXBlbGluZS5wcm90b3R5cGUuZXhlY0J1ZmZlciA9ICgwLCB1dGlsXzEuZGVwcmVjYXRlKShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKHRoaXMuX3RyYW5zYWN0aW9ucyA+IDApIHtcbiAgICAgICAgdGhpcy5fdHJhbnNhY3Rpb25zIC09IDE7XG4gICAgfVxuICAgIHJldHVybiBleGVjQnVmZmVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG59LCBcIlBpcGVsaW5lI2V4ZWNCdWZmZXI6IFVzZSBQaXBlbGluZSNleGVjIGluc3RlYWRcIik7XG4vLyBOT1RFOiBUbyBhdm9pZCBhbiB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb24sIHRoaXMgd2lsbCB1bmNvbmRpdGlvbmFsbHkgYWx3YXlzIHJldHVybiB0aGlzLnByb21pc2UsXG4vLyB3aGljaCBhbHdheXMgaGFzIHRoZSByZWplY3Rpb24gaGFuZGxlZCBieSBzdGFuZGFyZC1hcy1jYWxsYmFja1xuLy8gYWRkaW5nIHRoZSBwcm92aWRlZCByZWplY3Rpb24gY2FsbGJhY2suXG4vL1xuLy8gSWYgYSBkaWZmZXJlbnQgcHJvbWlzZSBpbnN0YW5jZSB3ZXJlIHJldHVybmVkLCB0aGF0IHByb21pc2Ugd291bGQgY2F1c2UgaXRzIG93biB1bmhhbmRsZWQgcHJvbWlzZSByZWplY3Rpb25cbi8vIGVycm9ycywgZXZlbiBpZiB0aGF0IHByb21pc2UgdW5jb25kaXRpb25hbGx5IHJlc29sdmVkIHRvICoqdGhlIHJlc29sdmVkIHZhbHVlIG9mKiogdGhpcy5wcm9taXNlLlxuUGlwZWxpbmUucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAvLyBXYWl0IGZvciB0aGUgY2x1c3RlciB0byBiZSBjb25uZWN0ZWQsIHNpbmNlIHdlIG5lZWQgbm9kZXMgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICBpZiAodGhpcy5pc0NsdXN0ZXIgJiYgIXRoaXMucmVkaXMuc2xvdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmICh0aGlzLnJlZGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpXG4gICAgICAgICAgICB0aGlzLnJlZGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICBpZiAoY2FsbGJhY2sgJiYgIXRoaXMubm9kZWlmaWVkUHJvbWlzZSkge1xuICAgICAgICAgICAgdGhpcy5ub2RlaWZpZWRQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgICAgICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKHRoaXMucHJvbWlzZSwgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVkaXMuZGVsYXlVbnRpbFJlYWR5KChlcnIpID0+IHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuZXhlYyhjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICBpZiAodGhpcy5fdHJhbnNhY3Rpb25zID4gMCkge1xuICAgICAgICB0aGlzLl90cmFuc2FjdGlvbnMgLT0gMTtcbiAgICAgICAgcmV0dXJuIGV4ZWNCdWZmZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLm5vZGVpZmllZFByb21pc2UpIHtcbiAgICAgICAgdGhpcy5ub2RlaWZpZWRQcm9taXNlID0gdHJ1ZTtcbiAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkodGhpcy5wcm9taXNlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGlmICghdGhpcy5fcXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHRoaXMucmVzb2x2ZShbXSk7XG4gICAgfVxuICAgIGxldCBwaXBlbGluZVNsb3Q7XG4gICAgaWYgKHRoaXMuaXNDbHVzdGVyKSB7XG4gICAgICAgIC8vIExpc3Qgb2YgdGhlIGZpcnN0IGtleSBmb3IgZWFjaCBjb21tYW5kXG4gICAgICAgIGNvbnN0IHNhbXBsZUtleXMgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLl9xdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgY29uc3Qga2V5cyA9IHRoaXMuX3F1ZXVlW2ldLmdldEtleXMoKTtcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNhbXBsZUtleXMucHVzaChrZXlzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZvciBlYWNoIGNvbW1hbmQsIGNoZWNrIHRoYXQgdGhlIGtleXMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RcbiAgICAgICAgICAgIGlmIChrZXlzLmxlbmd0aCAmJiBjYWxjdWxhdGVTbG90LmdlbmVyYXRlTXVsdGkoa2V5cykgPCAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QobmV3IEVycm9yKFwiQWxsIHRoZSBrZXlzIGluIGEgcGlwZWxpbmUgY29tbWFuZCBzaG91bGQgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3RcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNhbXBsZUtleXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBwaXBlbGluZVNsb3QgPSBnZW5lcmF0ZU11bHRpV2l0aE5vZGVzKHRoaXMucmVkaXMsIHNhbXBsZUtleXMpO1xuICAgICAgICAgICAgaWYgKHBpcGVsaW5lU2xvdCA8IDApIHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlamVjdChuZXcgRXJyb3IoXCJBbGwga2V5cyBpbiB0aGUgcGlwZWxpbmUgc2hvdWxkIGJlbG9uZyB0byB0aGUgc2FtZSBzbG90cyBhbGxvY2F0aW9uIGdyb3VwXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gU2VuZCB0aGUgcGlwZWxpbmUgdG8gYSByYW5kb20gbm9kZVxuICAgICAgICAgICAgcGlwZWxpbmVTbG90ID0gKE1hdGgucmFuZG9tKCkgKiAxNjM4NCkgfCAwO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICBleGVjUGlwZWxpbmUoKTtcbiAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIGZ1bmN0aW9uIGV4ZWNQaXBlbGluZSgpIHtcbiAgICAgICAgbGV0IHdyaXRlUGVuZGluZyA9IChfdGhpcy5yZXBseVBlbmRpbmcgPSBfdGhpcy5fcXVldWUubGVuZ3RoKTtcbiAgICAgICAgbGV0IG5vZGU7XG4gICAgICAgIGlmIChfdGhpcy5pc0NsdXN0ZXIpIHtcbiAgICAgICAgICAgIG5vZGUgPSB7XG4gICAgICAgICAgICAgICAgc2xvdDogcGlwZWxpbmVTbG90LFxuICAgICAgICAgICAgICAgIHJlZGlzOiBfdGhpcy5yZWRpcy5jb25uZWN0aW9uUG9vbC5ub2Rlcy5hbGxbX3RoaXMucHJlZmVyS2V5XSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgbGV0IGRhdGEgPSBcIlwiO1xuICAgICAgICBsZXQgYnVmZmVycztcbiAgICAgICAgY29uc3Qgc3RyZWFtID0ge1xuICAgICAgICAgICAgaXNQaXBlbGluZTogdHJ1ZSxcbiAgICAgICAgICAgIGRlc3RpbmF0aW9uOiBfdGhpcy5pc0NsdXN0ZXIgPyBub2RlIDogeyByZWRpczogX3RoaXMucmVkaXMgfSxcbiAgICAgICAgICAgIHdyaXRlKHdyaXRhYmxlKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiB3cml0YWJsZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWJ1ZmZlcnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJ1ZmZlcnMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnVmZmVycy5wdXNoKEJ1ZmZlci5mcm9tKGRhdGEsIFwidXRmOFwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBkYXRhID0gXCJcIjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2god3JpdGFibGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSArPSB3cml0YWJsZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCEtLXdyaXRlUGVuZGluZykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoYnVmZmVycykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBidWZmZXJzLnB1c2goQnVmZmVyLmZyb20oZGF0YSwgXCJ1dGY4XCIpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0aW5hdGlvbi5yZWRpcy5zdHJlYW0ud3JpdGUoQnVmZmVyLmNvbmNhdChidWZmZXJzKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdGluYXRpb24ucmVkaXMuc3RyZWFtLndyaXRlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlc2V0IHdyaXRlUGVuZGluZyBmb3IgcmVzZW5kaW5nXG4gICAgICAgICAgICAgICAgICAgIHdyaXRlUGVuZGluZyA9IF90aGlzLl9xdWV1ZS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICAgIGRhdGEgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBidWZmZXJzID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH07XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgX3RoaXMuX3F1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICBfdGhpcy5yZWRpcy5zZW5kQ29tbWFuZChfdGhpcy5fcXVldWVbaV0sIHN0cmVhbSwgbm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzLnByb21pc2U7XG4gICAgfVxufTtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Pipeline.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js ***!
  \**********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/../../node_modules/.pnpm/@ioredis+commands@1.2.0/node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nconst cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/index.js\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst connectors_1 = __webpack_require__(/*! ./connectors */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/index.js\");\nconst SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nconst eventHandler = __webpack_require__(/*! ./redis/event_handler */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/event_handler.js\");\nconst RedisOptions_1 = __webpack_require__(/*! ./redis/RedisOptions */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/RedisOptions.js\");\nconst ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ./transaction */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ./utils/applyMixin */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ./utils/Commander */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/Commander.js\");\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/lodash.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/../../node_modules/.pnpm/denque@2.1.0/node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"redis\");\n/**\n * This is the major component of ioredis.\n * Use it to connect to a standalone Redis server or Sentinels.\n *\n * ```typescript\n * const redis = new Redis(); // Default port is 6379\n * async function main() {\n *   redis.set(\"foo\", \"bar\");\n *   redis.get(\"foo\", (err, result) => {\n *     // `result` should be \"bar\"\n *     console.log(err, result);\n *   });\n *   // Or use Promise\n *   const result = await redis.get(\"foo\");\n * }\n * ```\n */\nclass Redis extends Commander_1.default {\n    constructor(arg1, arg2, arg3) {\n        super();\n        this.status = \"wait\";\n        /**\n         * @ignore\n         */\n        this.isCluster = false;\n        this.reconnectTimeout = null;\n        this.connectionEpoch = 0;\n        this.retryAttempts = 0;\n        this.manuallyClosing = false;\n        // Prepare autopipelines structures\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this.parseOptions(arg1, arg2, arg3);\n        events_1.EventEmitter.call(this);\n        this.resetCommandQueue();\n        this.resetOfflineQueue();\n        if (this.options.Connector) {\n            this.connector = new this.options.Connector(this.options);\n        }\n        else if (this.options.sentinels) {\n            const sentinelConnector = new SentinelConnector_1.default(this.options);\n            sentinelConnector.emitter = this;\n            this.connector = sentinelConnector;\n        }\n        else {\n            this.connector = new connectors_1.StandaloneConnector(this.options);\n        }\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        // end(or wait) -> connecting -> connect -> ready -> end\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch(lodash_1.noop);\n        }\n    }\n    /**\n     * Create a Redis instance.\n     * This is the same as `new Redis()` but is included for compatibility with node-redis.\n     */\n    static createClient(...args) {\n        return new Redis(...args);\n    }\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Create a connection to Redis.\n     * This method will be invoked automatically when creating a new Redis instance\n     * unless `lazyConnect: true` is passed.\n     *\n     * When calling this method manually, a Promise is returned, which will\n     * be resolved when the connection status is ready.\n     */\n    connect(callback) {\n        const promise = new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            this.connectionEpoch += 1;\n            this.setStatus(\"connecting\");\n            const { options } = this;\n            this.condition = {\n                select: options.db,\n                auth: options.username\n                    ? [options.username, options.password]\n                    : options.password,\n                subscriber: false,\n            };\n            const _this = this;\n            (0, standard_as_callback_1.default)(this.connector.connect(function (type, err) {\n                _this.silentEmit(type, err);\n            }), function (err, stream) {\n                if (err) {\n                    _this.flushQueue(err);\n                    _this.silentEmit(\"error\", err);\n                    reject(err);\n                    _this.setStatus(\"end\");\n                    return;\n                }\n                let CONNECT_EVENT = options.tls ? \"secureConnect\" : \"connect\";\n                if (\"sentinels\" in options &&\n                    options.sentinels &&\n                    !options.enableTLSForSentinelMode) {\n                    CONNECT_EVENT = \"connect\";\n                }\n                _this.stream = stream;\n                if (options.noDelay) {\n                    stream.setNoDelay(true);\n                }\n                // Node ignores setKeepAlive before connect, therefore we wait for the event:\n                // https://github.com/nodejs/node/issues/31663\n                if (typeof options.keepAlive === \"number\") {\n                    if (stream.connecting) {\n                        stream.once(CONNECT_EVENT, () => {\n                            stream.setKeepAlive(true, options.keepAlive);\n                        });\n                    }\n                    else {\n                        stream.setKeepAlive(true, options.keepAlive);\n                    }\n                }\n                if (stream.connecting) {\n                    stream.once(CONNECT_EVENT, eventHandler.connectHandler(_this));\n                    if (options.connectTimeout) {\n                        /*\n                         * Typically, Socket#setTimeout(0) will clear the timer\n                         * set before. However, in some platforms (Electron 3.x~4.x),\n                         * the timer will not be cleared. So we introduce a variable here.\n                         *\n                         * See https://github.com/electron/electron/issues/14915\n                         */\n                        let connectTimeoutCleared = false;\n                        stream.setTimeout(options.connectTimeout, function () {\n                            if (connectTimeoutCleared) {\n                                return;\n                            }\n                            stream.setTimeout(0);\n                            stream.destroy();\n                            const err = new Error(\"connect ETIMEDOUT\");\n                            // @ts-expect-error\n                            err.errorno = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.code = \"ETIMEDOUT\";\n                            // @ts-expect-error\n                            err.syscall = \"connect\";\n                            eventHandler.errorHandler(_this)(err);\n                        });\n                        stream.once(CONNECT_EVENT, function () {\n                            connectTimeoutCleared = true;\n                            stream.setTimeout(0);\n                        });\n                    }\n                }\n                else if (stream.destroyed) {\n                    const firstError = _this.connector.firstError;\n                    if (firstError) {\n                        process.nextTick(() => {\n                            eventHandler.errorHandler(_this)(firstError);\n                        });\n                    }\n                    process.nextTick(eventHandler.closeHandler(_this));\n                }\n                else {\n                    process.nextTick(eventHandler.connectHandler(_this));\n                }\n                if (!stream.destroyed) {\n                    stream.once(\"error\", eventHandler.errorHandler(_this));\n                    stream.once(\"close\", eventHandler.closeHandler(_this));\n                }\n                const connectionReadyHandler = function () {\n                    _this.removeListener(\"close\", connectionCloseHandler);\n                    resolve();\n                };\n                var connectionCloseHandler = function () {\n                    _this.removeListener(\"ready\", connectionReadyHandler);\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                };\n                _this.once(\"ready\", connectionReadyHandler);\n                _this.once(\"close\", connectionCloseHandler);\n            });\n        });\n        return (0, standard_as_callback_1.default)(promise, callback);\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * This method closes the connection immediately,\n     * and may lose some pending replies that haven't written to client.\n     * If you want to wait for the pending replies, use Redis#quit instead.\n     */\n    disconnect(reconnect = false) {\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        if (this.status === \"wait\") {\n            eventHandler.closeHandler(this)();\n        }\n        else {\n            this.connector.disconnect();\n        }\n    }\n    /**\n     * Disconnect from Redis.\n     *\n     * @deprecated\n     */\n    end() {\n        this.disconnect();\n    }\n    /**\n     * Create a new instance with the same options as the current one.\n     *\n     * @example\n     * ```js\n     * var redis = new Redis(6380);\n     * var anotherRedis = redis.duplicate();\n     * ```\n     */\n    duplicate(override) {\n        return new Redis({ ...this.options, ...override });\n    }\n    /**\n     * Mode of the connection.\n     *\n     * One of `\"normal\"`, `\"subscriber\"`, or `\"monitor\"`. When the connection is\n     * not in `\"normal\"` mode, certain commands are not allowed.\n     */\n    get mode() {\n        var _a;\n        return this.options.monitor\n            ? \"monitor\"\n            : ((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber)\n                ? \"subscriber\"\n                : \"normal\";\n    }\n    /**\n     * Listen for all requests received by the server in real time.\n     *\n     * This command will create a new connection to Redis and send a\n     * MONITOR command via the new connection in order to avoid disturbing\n     * the current connection.\n     *\n     * @param callback The callback function. If omit, a promise will be returned.\n     * @example\n     * ```js\n     * var redis = new Redis();\n     * redis.monitor(function (err, monitor) {\n     *   // Entering monitoring mode.\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     *\n     * // supports promise as well as other commands\n     * redis.monitor().then(function (monitor) {\n     *   monitor.on('monitor', function (time, args, source, database) {\n     *     console.log(time + \": \" + util.inspect(args));\n     *   });\n     * });\n     * ```\n     */\n    monitor(callback) {\n        const monitorInstance = this.duplicate({\n            monitor: true,\n            lazyConnect: false,\n        });\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            monitorInstance.once(\"error\", reject);\n            monitorInstance.once(\"monitoring\", function () {\n                resolve(monitorInstance);\n            });\n        }), callback);\n    }\n    /**\n     * Send a command to Redis\n     *\n     * This method is used internally and in most cases you should not\n     * use it directly. If you need to send a command that is not supported\n     * by the library, you can use the `call` method:\n     *\n     * ```js\n     * const redis = new Redis();\n     *\n     * redis.call('set', 'foo', 'bar');\n     * // or\n     * redis.call(['set', 'foo', 'bar']);\n     * ```\n     *\n     * @ignore\n     */\n    sendCommand(command, stream) {\n        var _a, _b;\n        if (this.status === \"wait\") {\n            this.connect().catch(lodash_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.subscriber) &&\n            !Command_1.default.checkFlag(\"VALID_IN_SUBSCRIBER_MODE\", command.name)) {\n            command.reject(new Error(\"Connection in subscriber mode, only subscriber commands may be used\"));\n            return command.promise;\n        }\n        if (typeof this.options.commandTimeout === \"number\") {\n            command.setTimeout(this.options.commandTimeout);\n        }\n        let writable = this.status === \"ready\" ||\n            (!stream &&\n                this.status === \"connect\" &&\n                (0, commands_1.exists)(command.name) &&\n                (0, commands_1.hasFlag)(command.name, \"loading\"));\n        if (!this.stream) {\n            writable = false;\n        }\n        else if (!this.stream.writable) {\n            writable = false;\n            // @ts-expect-error\n        }\n        else if (this.stream._writableState && this.stream._writableState.ended) {\n            // TODO: We should be able to remove this as the PR has already been merged.\n            // https://github.com/iojs/io.js/pull/1217\n            writable = false;\n        }\n        if (!writable) {\n            if (!this.options.enableOfflineQueue) {\n                command.reject(new Error(\"Stream isn't writeable and enableOfflineQueue options is false\"));\n                return command.promise;\n            }\n            if (command.name === \"quit\" && this.offlineQueue.length === 0) {\n                this.disconnect();\n                command.resolve(Buffer.from(\"OK\"));\n                return command.promise;\n            }\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"queue command[%s]: %d -> %s(%o)\", this._getDescription(), this.condition.select, command.name, command.args);\n            }\n            this.offlineQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n        }\n        else {\n            // @ts-expect-error\n            if (debug.enabled) {\n                debug(\"write command[%s]: %d -> %s(%o)\", this._getDescription(), (_b = this.condition) === null || _b === void 0 ? void 0 : _b.select, command.name, command.args);\n            }\n            if (stream) {\n                if (\"isPipeline\" in stream && stream.isPipeline) {\n                    stream.write(command.toWritable(stream.destination.redis.stream));\n                }\n                else {\n                    stream.write(command.toWritable(stream));\n                }\n            }\n            else {\n                this.stream.write(command.toWritable(this.stream));\n            }\n            this.commandQueue.push({\n                command: command,\n                stream: stream,\n                select: this.condition.select,\n            });\n            if (Command_1.default.checkFlag(\"WILL_DISCONNECT\", command.name)) {\n                this.manuallyClosing = true;\n            }\n            if (this.options.socketTimeout !== undefined && this.socketTimeoutTimer === undefined) {\n                this.setSocketTimeout();\n            }\n        }\n        if (command.name === \"select\" && (0, utils_1.isInt)(command.args[0])) {\n            const db = parseInt(command.args[0], 10);\n            if (this.condition.select !== db) {\n                this.condition.select = db;\n                this.emit(\"select\", db);\n                debug(\"switch to db [%d]\", this.condition.select);\n            }\n        }\n        return command.promise;\n    }\n    setSocketTimeout() {\n        this.socketTimeoutTimer = setTimeout(() => {\n            this.stream.destroy(new Error(`Socket timeout. Expecting data, but didn't receive any in ${this.options.socketTimeout}ms.`));\n            this.socketTimeoutTimer = undefined;\n        }, this.options.socketTimeout);\n        // this handler must run after the \"data\" handler in \"DataHandler\"\n        // so that `this.commandQueue.length` will be updated\n        this.stream.once(\"data\", () => {\n            clearTimeout(this.socketTimeoutTimer);\n            this.socketTimeoutTimer = undefined;\n            if (this.commandQueue.length === 0)\n                return;\n            this.setSocketTimeout();\n        });\n    }\n    scanStream(options) {\n        return this.createScanStream(\"scan\", { options });\n    }\n    scanBufferStream(options) {\n        return this.createScanStream(\"scanBuffer\", { options });\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * Emit only when there's at least one listener.\n     *\n     * @ignore\n     */\n    silentEmit(eventName, arg) {\n        let error;\n        if (eventName === \"error\") {\n            error = arg;\n            if (this.status === \"end\") {\n                return;\n            }\n            if (this.manuallyClosing) {\n                // ignore connection related errors when manually disconnecting\n                if (error instanceof Error &&\n                    (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG ||\n                        // @ts-expect-error\n                        error.syscall === \"connect\" ||\n                        // @ts-expect-error\n                        error.syscall === \"read\")) {\n                    return;\n                }\n            }\n        }\n        if (this.listeners(eventName).length > 0) {\n            return this.emit.apply(this, arguments);\n        }\n        if (error && error instanceof Error) {\n            console.error(\"[ioredis] Unhandled error event:\", error.stack);\n        }\n        return false;\n    }\n    /**\n     * @ignore\n     */\n    recoverFromFatalError(_commandError, err, options) {\n        this.flushQueue(err, options);\n        this.silentEmit(\"error\", err);\n        this.disconnect(true);\n    }\n    /**\n     * @ignore\n     */\n    handleReconnection(err, item) {\n        var _a;\n        let needReconnect = false;\n        if (this.options.reconnectOnError) {\n            needReconnect = this.options.reconnectOnError(err);\n        }\n        switch (needReconnect) {\n            case 1:\n            case true:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                item.command.reject(err);\n                break;\n            case 2:\n                if (this.status !== \"reconnecting\") {\n                    this.disconnect(true);\n                }\n                if (((_a = this.condition) === null || _a === void 0 ? void 0 : _a.select) !== item.select &&\n                    item.command.name !== \"select\") {\n                    this.select(item.select);\n                }\n                // TODO\n                // @ts-expect-error\n                this.sendCommand(item.command);\n                break;\n            default:\n                item.command.reject(err);\n        }\n    }\n    /**\n     * Get description of the connection. Used for debugging.\n     */\n    _getDescription() {\n        let description;\n        if (\"path\" in this.options && this.options.path) {\n            description = this.options.path;\n        }\n        else if (this.stream &&\n            this.stream.remoteAddress &&\n            this.stream.remotePort) {\n            description = this.stream.remoteAddress + \":\" + this.stream.remotePort;\n        }\n        else if (\"host\" in this.options && this.options.host) {\n            description = this.options.host + \":\" + this.options.port;\n        }\n        else {\n            // Unexpected\n            description = \"\";\n        }\n        if (this.options.connectionName) {\n            description += ` (${this.options.connectionName})`;\n        }\n        return description;\n    }\n    resetCommandQueue() {\n        this.commandQueue = new Deque();\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    parseOptions(...args) {\n        const options = {};\n        let isTls = false;\n        for (let i = 0; i < args.length; ++i) {\n            const arg = args[i];\n            if (arg === null || typeof arg === \"undefined\") {\n                continue;\n            }\n            if (typeof arg === \"object\") {\n                (0, lodash_1.defaults)(options, arg);\n            }\n            else if (typeof arg === \"string\") {\n                (0, lodash_1.defaults)(options, (0, utils_1.parseURL)(arg));\n                if (arg.startsWith(\"rediss://\")) {\n                    isTls = true;\n                }\n            }\n            else if (typeof arg === \"number\") {\n                options.port = arg;\n            }\n            else {\n                throw new Error(\"Invalid argument \" + arg);\n            }\n        }\n        if (isTls) {\n            (0, lodash_1.defaults)(options, { tls: true });\n        }\n        (0, lodash_1.defaults)(options, Redis.defaultOptions);\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        if (typeof options.db === \"string\") {\n            options.db = parseInt(options.db, 10);\n        }\n        // @ts-expect-error\n        this.options = (0, utils_1.resolveTLSProfile)(options);\n    }\n    /**\n     * Change instance's status\n     */\n    setStatus(status, arg) {\n        // @ts-expect-error\n        if (debug.enabled) {\n            debug(\"status[%s]: %s -> %s\", this._getDescription(), this.status || \"[empty]\", status);\n        }\n        this.status = status;\n        process.nextTick(this.emit.bind(this, status, arg));\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n    /**\n     * Flush offline queue and command queue with error.\n     *\n     * @param error The error object to send to the commands\n     * @param options options\n     */\n    flushQueue(error, options) {\n        options = (0, lodash_1.defaults)({}, options, {\n            offlineQueue: true,\n            commandQueue: true,\n        });\n        let item;\n        if (options.offlineQueue) {\n            while ((item = this.offlineQueue.shift())) {\n                item.command.reject(error);\n            }\n        }\n        if (options.commandQueue) {\n            if (this.commandQueue.length > 0) {\n                if (this.stream) {\n                    this.stream.removeAllListeners(\"data\");\n                }\n                while ((item = this.commandQueue.shift())) {\n                    item.command.reject(error);\n                }\n            }\n        }\n    }\n    /**\n     * Check whether Redis has finished loading the persistent data and is able to\n     * process commands.\n     */\n    _readyCheck(callback) {\n        const _this = this;\n        this.info(function (err, res) {\n            if (err) {\n                if (err.message && err.message.includes(\"NOPERM\")) {\n                    console.warn(`Skipping the ready check because INFO command fails: \"${err.message}\". You can disable ready check with \"enableReadyCheck\". More: https://github.com/luin/ioredis/wiki/Disable-ready-check.`);\n                    return callback(null, {});\n                }\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback(null, res);\n            }\n            const info = {};\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const [fieldName, ...fieldValueParts] = lines[i].split(\":\");\n                const fieldValue = fieldValueParts.join(\":\");\n                if (fieldValue) {\n                    info[fieldName] = fieldValue;\n                }\n            }\n            if (!info.loading || info.loading === \"0\") {\n                callback(null, info);\n            }\n            else {\n                const loadingEtaMs = (info.loading_eta_seconds || 1) * 1000;\n                const retryTime = _this.options.maxLoadingRetryTime &&\n                    _this.options.maxLoadingRetryTime < loadingEtaMs\n                    ? _this.options.maxLoadingRetryTime\n                    : loadingEtaMs;\n                debug(\"Redis server still loading, trying again in \" + retryTime + \"ms\");\n                setTimeout(function () {\n                    _this._readyCheck(callback);\n                }, retryTime);\n            }\n        }).catch(lodash_1.noop);\n    }\n}\nRedis.Cluster = cluster_1.default;\nRedis.Command = Command_1.default;\n/**\n * Default options\n */\nRedis.defaultOptions = RedisOptions_1.DEFAULT_REDIS_OPTIONS;\n(0, applyMixin_1.default)(Redis, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Redis.prototype);\nexports[\"default\"] = Redis;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvUmVkaXMuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsbUJBQW1CLG1CQUFPLENBQUMsK0hBQW1CO0FBQzlDLGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLCtCQUErQixtQkFBTyxDQUFDLHdJQUFzQjtBQUM3RCxrQkFBa0IsbUJBQU8sQ0FBQywyR0FBVztBQUNyQyxrQkFBa0IsbUJBQU8sQ0FBQyxxR0FBVztBQUNyQyxxQkFBcUIsbUJBQU8sQ0FBQyxpSEFBYztBQUMzQyw0QkFBNEIsbUJBQU8sQ0FBQyxxSkFBZ0M7QUFDcEUscUJBQXFCLG1CQUFPLENBQUMsNkhBQXVCO0FBQ3BELHVCQUF1QixtQkFBTyxDQUFDLDJIQUFzQjtBQUNyRCxxQkFBcUIsbUJBQU8sQ0FBQywyR0FBYztBQUMzQyxzQkFBc0IsbUJBQU8sQ0FBQyw2R0FBZTtBQUM3QyxnQkFBZ0IsbUJBQU8sQ0FBQyx1R0FBUztBQUNqQyxxQkFBcUIsbUJBQU8sQ0FBQyx1SEFBb0I7QUFDakQsb0JBQW9CLG1CQUFPLENBQUMscUhBQW1CO0FBQy9DLGlCQUFpQixtQkFBTyxDQUFDLCtHQUFnQjtBQUN6QyxjQUFjLG1CQUFPLENBQUMsd0ZBQVE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQiw4QkFBOEI7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RywyQkFBMkI7QUFDbEk7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsK0NBQStDLFNBQVM7QUFDeEQ7QUFDQTtBQUNBLHFEQUFxRCxTQUFTO0FBQzlEO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsNEJBQTRCO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixpQkFBaUI7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFdBQVc7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDO0FBQzNDO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBGQUEwRixZQUFZO0FBQ3RHLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLGtCQUFrQjtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvUmVkaXMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCBjb21tYW5kc18xID0gcmVxdWlyZShcIkBpb3JlZGlzL2NvbW1hbmRzXCIpO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3Qgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMSA9IHJlcXVpcmUoXCJzdGFuZGFyZC1hcy1jYWxsYmFja1wiKTtcbmNvbnN0IGNsdXN0ZXJfMSA9IHJlcXVpcmUoXCIuL2NsdXN0ZXJcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi9Db21tYW5kXCIpO1xuY29uc3QgY29ubmVjdG9yc18xID0gcmVxdWlyZShcIi4vY29ubmVjdG9yc1wiKTtcbmNvbnN0IFNlbnRpbmVsQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JzL1NlbnRpbmVsQ29ubmVjdG9yXCIpO1xuY29uc3QgZXZlbnRIYW5kbGVyID0gcmVxdWlyZShcIi4vcmVkaXMvZXZlbnRfaGFuZGxlclwiKTtcbmNvbnN0IFJlZGlzT3B0aW9uc18xID0gcmVxdWlyZShcIi4vcmVkaXMvUmVkaXNPcHRpb25zXCIpO1xuY29uc3QgU2NhblN0cmVhbV8xID0gcmVxdWlyZShcIi4vU2NhblN0cmVhbVwiKTtcbmNvbnN0IHRyYW5zYWN0aW9uXzEgPSByZXF1aXJlKFwiLi90cmFuc2FjdGlvblwiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IGFwcGx5TWl4aW5fMSA9IHJlcXVpcmUoXCIuL3V0aWxzL2FwcGx5TWl4aW5cIik7XG5jb25zdCBDb21tYW5kZXJfMSA9IHJlcXVpcmUoXCIuL3V0aWxzL0NvbW1hbmRlclwiKTtcbmNvbnN0IGxvZGFzaF8xID0gcmVxdWlyZShcIi4vdXRpbHMvbG9kYXNoXCIpO1xuY29uc3QgRGVxdWUgPSByZXF1aXJlKFwiZGVucXVlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJyZWRpc1wiKTtcbi8qKlxuICogVGhpcyBpcyB0aGUgbWFqb3IgY29tcG9uZW50IG9mIGlvcmVkaXMuXG4gKiBVc2UgaXQgdG8gY29ubmVjdCB0byBhIHN0YW5kYWxvbmUgUmVkaXMgc2VydmVyIG9yIFNlbnRpbmVscy5cbiAqXG4gKiBgYGB0eXBlc2NyaXB0XG4gKiBjb25zdCByZWRpcyA9IG5ldyBSZWRpcygpOyAvLyBEZWZhdWx0IHBvcnQgaXMgNjM3OVxuICogYXN5bmMgZnVuY3Rpb24gbWFpbigpIHtcbiAqICAgcmVkaXMuc2V0KFwiZm9vXCIsIFwiYmFyXCIpO1xuICogICByZWRpcy5nZXQoXCJmb29cIiwgKGVyciwgcmVzdWx0KSA9PiB7XG4gKiAgICAgLy8gYHJlc3VsdGAgc2hvdWxkIGJlIFwiYmFyXCJcbiAqICAgICBjb25zb2xlLmxvZyhlcnIsIHJlc3VsdCk7XG4gKiAgIH0pO1xuICogICAvLyBPciB1c2UgUHJvbWlzZVxuICogICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWRpcy5nZXQoXCJmb29cIik7XG4gKiB9XG4gKiBgYGBcbiAqL1xuY2xhc3MgUmVkaXMgZXh0ZW5kcyBDb21tYW5kZXJfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihhcmcxLCBhcmcyLCBhcmczKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc3RhdHVzID0gXCJ3YWl0XCI7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLmlzQ2x1c3RlciA9IGZhbHNlO1xuICAgICAgICB0aGlzLnJlY29ubmVjdFRpbWVvdXQgPSBudWxsO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25FcG9jaCA9IDA7XG4gICAgICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgIC8vIFByZXBhcmUgYXV0b3BpcGVsaW5lcyBzdHJ1Y3R1cmVzXG4gICAgICAgIHRoaXMuX2F1dG9QaXBlbGluZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3J1bm5pbmdBdXRvUGlwZWxpbmVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLnBhcnNlT3B0aW9ucyhhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgZXZlbnRzXzEuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMucmVzZXRDb21tYW5kUXVldWUoKTtcbiAgICAgICAgdGhpcy5yZXNldE9mZmxpbmVRdWV1ZSgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLkNvbm5lY3Rvcikge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgdGhpcy5vcHRpb25zLkNvbm5lY3Rvcih0aGlzLm9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMub3B0aW9ucy5zZW50aW5lbHMpIHtcbiAgICAgICAgICAgIGNvbnN0IHNlbnRpbmVsQ29ubmVjdG9yID0gbmV3IFNlbnRpbmVsQ29ubmVjdG9yXzEuZGVmYXVsdCh0aGlzLm9wdGlvbnMpO1xuICAgICAgICAgICAgc2VudGluZWxDb25uZWN0b3IuZW1pdHRlciA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RvciA9IHNlbnRpbmVsQ29ubmVjdG9yO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0b3IgPSBuZXcgY29ubmVjdG9yc18xLlN0YW5kYWxvbmVDb25uZWN0b3IodGhpcy5vcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNjcmlwdHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5lbnRyaWVzKHRoaXMub3B0aW9ucy5zY3JpcHRzKS5mb3JFYWNoKChbbmFtZSwgZGVmaW5pdGlvbl0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlZmluZUNvbW1hbmQobmFtZSwgZGVmaW5pdGlvbik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICAvLyBlbmQob3Igd2FpdCkgLT4gY29ubmVjdGluZyAtPiBjb25uZWN0IC0+IHJlYWR5IC0+IGVuZFxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmxhenlDb25uZWN0KSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcIndhaXRcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaChsb2Rhc2hfMS5ub29wKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBSZWRpcyBpbnN0YW5jZS5cbiAgICAgKiBUaGlzIGlzIHRoZSBzYW1lIGFzIGBuZXcgUmVkaXMoKWAgYnV0IGlzIGluY2x1ZGVkIGZvciBjb21wYXRpYmlsaXR5IHdpdGggbm9kZS1yZWRpcy5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlQ2xpZW50KC4uLmFyZ3MpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBSZWRpcyguLi5hcmdzKTtcbiAgICB9XG4gICAgZ2V0IGF1dG9QaXBlbGluZVF1ZXVlU2l6ZSgpIHtcbiAgICAgICAgbGV0IHF1ZXVlZCA9IDA7XG4gICAgICAgIGZvciAoY29uc3QgcGlwZWxpbmUgb2YgdGhpcy5fYXV0b1BpcGVsaW5lcy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcXVldWVkICs9IHBpcGVsaW5lLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcXVldWVkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBjb25uZWN0aW9uIHRvIFJlZGlzLlxuICAgICAqIFRoaXMgbWV0aG9kIHdpbGwgYmUgaW52b2tlZCBhdXRvbWF0aWNhbGx5IHdoZW4gY3JlYXRpbmcgYSBuZXcgUmVkaXMgaW5zdGFuY2VcbiAgICAgKiB1bmxlc3MgYGxhenlDb25uZWN0OiB0cnVlYCBpcyBwYXNzZWQuXG4gICAgICpcbiAgICAgKiBXaGVuIGNhbGxpbmcgdGhpcyBtZXRob2QgbWFudWFsbHksIGEgUHJvbWlzZSBpcyByZXR1cm5lZCwgd2hpY2ggd2lsbFxuICAgICAqIGJlIHJlc29sdmVkIHdoZW4gdGhlIGNvbm5lY3Rpb24gc3RhdHVzIGlzIHJlYWR5LlxuICAgICAqL1xuICAgIGNvbm5lY3QoY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0aW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjb25uZWN0XCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihcIlJlZGlzIGlzIGFscmVhZHkgY29ubmVjdGluZy9jb25uZWN0ZWRcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbkVwb2NoICs9IDE7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNvbm5lY3RpbmdcIik7XG4gICAgICAgICAgICBjb25zdCB7IG9wdGlvbnMgfSA9IHRoaXM7XG4gICAgICAgICAgICB0aGlzLmNvbmRpdGlvbiA9IHtcbiAgICAgICAgICAgICAgICBzZWxlY3Q6IG9wdGlvbnMuZGIsXG4gICAgICAgICAgICAgICAgYXV0aDogb3B0aW9ucy51c2VybmFtZVxuICAgICAgICAgICAgICAgICAgICA/IFtvcHRpb25zLnVzZXJuYW1lLCBvcHRpb25zLnBhc3N3b3JkXVxuICAgICAgICAgICAgICAgICAgICA6IG9wdGlvbnMucGFzc3dvcmQsXG4gICAgICAgICAgICAgICAgc3Vic2NyaWJlcjogZmFsc2UsXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkodGhpcy5jb25uZWN0b3IuY29ubmVjdChmdW5jdGlvbiAodHlwZSwgZXJyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuc2lsZW50RW1pdCh0eXBlLCBlcnIpO1xuICAgICAgICAgICAgfSksIGZ1bmN0aW9uIChlcnIsIHN0cmVhbSkge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZmx1c2hRdWV1ZShlcnIpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zaWxlbnRFbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnNldFN0YXR1cyhcImVuZFwiKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsZXQgQ09OTkVDVF9FVkVOVCA9IG9wdGlvbnMudGxzID8gXCJzZWN1cmVDb25uZWN0XCIgOiBcImNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICBpZiAoXCJzZW50aW5lbHNcIiBpbiBvcHRpb25zICYmXG4gICAgICAgICAgICAgICAgICAgIG9wdGlvbnMuc2VudGluZWxzICYmXG4gICAgICAgICAgICAgICAgICAgICFvcHRpb25zLmVuYWJsZVRMU0ZvclNlbnRpbmVsTW9kZSkge1xuICAgICAgICAgICAgICAgICAgICBDT05ORUNUX0VWRU5UID0gXCJjb25uZWN0XCI7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF90aGlzLnN0cmVhbSA9IHN0cmVhbTtcbiAgICAgICAgICAgICAgICBpZiAob3B0aW9ucy5ub0RlbGF5KSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXROb0RlbGF5KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvLyBOb2RlIGlnbm9yZXMgc2V0S2VlcEFsaXZlIGJlZm9yZSBjb25uZWN0LCB0aGVyZWZvcmUgd2Ugd2FpdCBmb3IgdGhlIGV2ZW50OlxuICAgICAgICAgICAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9ub2RlanMvbm9kZS9pc3N1ZXMvMzE2NjNcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMua2VlcEFsaXZlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzdHJlYW0uY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoQ09OTkVDVF9FVkVOVCwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN0cmVhbS5zZXRLZWVwQWxpdmUodHJ1ZSwgb3B0aW9ucy5rZWVwQWxpdmUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0S2VlcEFsaXZlKHRydWUsIG9wdGlvbnMua2VlcEFsaXZlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoc3RyZWFtLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoQ09OTkVDVF9FVkVOVCwgZXZlbnRIYW5kbGVyLmNvbm5lY3RIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChvcHRpb25zLmNvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogVHlwaWNhbGx5LCBTb2NrZXQjc2V0VGltZW91dCgwKSB3aWxsIGNsZWFyIHRoZSB0aW1lclxuICAgICAgICAgICAgICAgICAgICAgICAgICogc2V0IGJlZm9yZS4gSG93ZXZlciwgaW4gc29tZSBwbGF0Zm9ybXMgKEVsZWN0cm9uIDMueH40LngpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICogdGhlIHRpbWVyIHdpbGwgbm90IGJlIGNsZWFyZWQuIFNvIHdlIGludHJvZHVjZSBhIHZhcmlhYmxlIGhlcmUuXG4gICAgICAgICAgICAgICAgICAgICAgICAgKlxuICAgICAgICAgICAgICAgICAgICAgICAgICogU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9lbGVjdHJvbi9lbGVjdHJvbi9pc3N1ZXMvMTQ5MTVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IGNvbm5lY3RUaW1lb3V0Q2xlYXJlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgc3RyZWFtLnNldFRpbWVvdXQob3B0aW9ucy5jb25uZWN0VGltZW91dCwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb25uZWN0VGltZW91dENsZWFyZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0VGltZW91dCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uZGVzdHJveSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcihcImNvbm5lY3QgRVRJTUVET1VUXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnIuZXJyb3JubyA9IFwiRVRJTUVET1VUXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVyci5jb2RlID0gXCJFVElNRURPVVRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXJyLnN5c2NhbGwgPSBcImNvbm5lY3RcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBldmVudEhhbmRsZXIuZXJyb3JIYW5kbGVyKF90aGlzKShlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShDT05ORUNUX0VWRU5ULCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdFRpbWVvdXRDbGVhcmVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdHJlYW0uc2V0VGltZW91dCgwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHN0cmVhbS5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlyc3RFcnJvciA9IF90aGlzLmNvbm5lY3Rvci5maXJzdEVycm9yO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZmlyc3RFcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRIYW5kbGVyLmVycm9ySGFuZGxlcihfdGhpcykoZmlyc3RFcnJvcik7XG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGV2ZW50SGFuZGxlci5jbG9zZUhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHByb2Nlc3MubmV4dFRpY2soZXZlbnRIYW5kbGVyLmNvbm5lY3RIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghc3RyZWFtLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ub25jZShcImVycm9yXCIsIGV2ZW50SGFuZGxlci5lcnJvckhhbmRsZXIoX3RoaXMpKTtcbiAgICAgICAgICAgICAgICAgICAgc3RyZWFtLm9uY2UoXCJjbG9zZVwiLCBldmVudEhhbmRsZXIuY2xvc2VIYW5kbGVyKF90aGlzKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IGNvbm5lY3Rpb25SZWFkeUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY29ubmVjdGlvbkNsb3NlSGFuZGxlcik7XG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUoKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHZhciBjb25uZWN0aW9uQ2xvc2VIYW5kbGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZW1vdmVMaXN0ZW5lcihcInJlYWR5XCIsIGNvbm5lY3Rpb25SZWFkeUhhbmRsZXIpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKFwicmVhZHlcIiwgY29ubmVjdGlvblJlYWR5SGFuZGxlcik7XG4gICAgICAgICAgICAgICAgX3RoaXMub25jZShcImNsb3NlXCIsIGNvbm5lY3Rpb25DbG9zZUhhbmRsZXIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkocHJvbWlzZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGZyb20gUmVkaXMuXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBjbG9zZXMgdGhlIGNvbm5lY3Rpb24gaW1tZWRpYXRlbHksXG4gICAgICogYW5kIG1heSBsb3NlIHNvbWUgcGVuZGluZyByZXBsaWVzIHRoYXQgaGF2ZW4ndCB3cml0dGVuIHRvIGNsaWVudC5cbiAgICAgKiBJZiB5b3Ugd2FudCB0byB3YWl0IGZvciB0aGUgcGVuZGluZyByZXBsaWVzLCB1c2UgUmVkaXMjcXVpdCBpbnN0ZWFkLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QocmVjb25uZWN0ID0gZmFsc2UpIHtcbiAgICAgICAgaWYgKCFyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0ICYmICFyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICBldmVudEhhbmRsZXIuY2xvc2VIYW5kbGVyKHRoaXMpKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rvci5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGlzY29ubmVjdCBmcm9tIFJlZGlzLlxuICAgICAqXG4gICAgICogQGRlcHJlY2F0ZWRcbiAgICAgKi9cbiAgICBlbmQoKSB7XG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBuZXcgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBvcHRpb25zIGFzIHRoZSBjdXJyZW50IG9uZS5cbiAgICAgKlxuICAgICAqIEBleGFtcGxlXG4gICAgICogYGBganNcbiAgICAgKiB2YXIgcmVkaXMgPSBuZXcgUmVkaXMoNjM4MCk7XG4gICAgICogdmFyIGFub3RoZXJSZWRpcyA9IHJlZGlzLmR1cGxpY2F0ZSgpO1xuICAgICAqIGBgYFxuICAgICAqL1xuICAgIGR1cGxpY2F0ZShvdmVycmlkZSkge1xuICAgICAgICByZXR1cm4gbmV3IFJlZGlzKHsgLi4udGhpcy5vcHRpb25zLCAuLi5vdmVycmlkZSB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTW9kZSBvZiB0aGUgY29ubmVjdGlvbi5cbiAgICAgKlxuICAgICAqIE9uZSBvZiBgXCJub3JtYWxcImAsIGBcInN1YnNjcmliZXJcImAsIG9yIGBcIm1vbml0b3JcImAuIFdoZW4gdGhlIGNvbm5lY3Rpb24gaXNcbiAgICAgKiBub3QgaW4gYFwibm9ybWFsXCJgIG1vZGUsIGNlcnRhaW4gY29tbWFuZHMgYXJlIG5vdCBhbGxvd2VkLlxuICAgICAqL1xuICAgIGdldCBtb2RlKCkge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIHJldHVybiB0aGlzLm9wdGlvbnMubW9uaXRvclxuICAgICAgICAgICAgPyBcIm1vbml0b3JcIlxuICAgICAgICAgICAgOiAoKF9hID0gdGhpcy5jb25kaXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmVyKVxuICAgICAgICAgICAgICAgID8gXCJzdWJzY3JpYmVyXCJcbiAgICAgICAgICAgICAgICA6IFwibm9ybWFsXCI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIExpc3RlbiBmb3IgYWxsIHJlcXVlc3RzIHJlY2VpdmVkIGJ5IHRoZSBzZXJ2ZXIgaW4gcmVhbCB0aW1lLlxuICAgICAqXG4gICAgICogVGhpcyBjb21tYW5kIHdpbGwgY3JlYXRlIGEgbmV3IGNvbm5lY3Rpb24gdG8gUmVkaXMgYW5kIHNlbmQgYVxuICAgICAqIE1PTklUT1IgY29tbWFuZCB2aWEgdGhlIG5ldyBjb25uZWN0aW9uIGluIG9yZGVyIHRvIGF2b2lkIGRpc3R1cmJpbmdcbiAgICAgKiB0aGUgY3VycmVudCBjb25uZWN0aW9uLlxuICAgICAqXG4gICAgICogQHBhcmFtIGNhbGxiYWNrIFRoZSBjYWxsYmFjayBmdW5jdGlvbi4gSWYgb21pdCwgYSBwcm9taXNlIHdpbGwgYmUgcmV0dXJuZWQuXG4gICAgICogQGV4YW1wbGVcbiAgICAgKiBgYGBqc1xuICAgICAqIHZhciByZWRpcyA9IG5ldyBSZWRpcygpO1xuICAgICAqIHJlZGlzLm1vbml0b3IoZnVuY3Rpb24gKGVyciwgbW9uaXRvcikge1xuICAgICAqICAgLy8gRW50ZXJpbmcgbW9uaXRvcmluZyBtb2RlLlxuICAgICAqICAgbW9uaXRvci5vbignbW9uaXRvcicsIGZ1bmN0aW9uICh0aW1lLCBhcmdzLCBzb3VyY2UsIGRhdGFiYXNlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHRpbWUgKyBcIjogXCIgKyB1dGlsLmluc3BlY3QoYXJncykpO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICpcbiAgICAgKiAvLyBzdXBwb3J0cyBwcm9taXNlIGFzIHdlbGwgYXMgb3RoZXIgY29tbWFuZHNcbiAgICAgKiByZWRpcy5tb25pdG9yKCkudGhlbihmdW5jdGlvbiAobW9uaXRvcikge1xuICAgICAqICAgbW9uaXRvci5vbignbW9uaXRvcicsIGZ1bmN0aW9uICh0aW1lLCBhcmdzLCBzb3VyY2UsIGRhdGFiYXNlKSB7XG4gICAgICogICAgIGNvbnNvbGUubG9nKHRpbWUgKyBcIjogXCIgKyB1dGlsLmluc3BlY3QoYXJncykpO1xuICAgICAqICAgfSk7XG4gICAgICogfSk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgbW9uaXRvcihjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBtb25pdG9ySW5zdGFuY2UgPSB0aGlzLmR1cGxpY2F0ZSh7XG4gICAgICAgICAgICBtb25pdG9yOiB0cnVlLFxuICAgICAgICAgICAgbGF6eUNvbm5lY3Q6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuICgwLCBzdGFuZGFyZF9hc19jYWxsYmFja18xLmRlZmF1bHQpKG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICAgIG1vbml0b3JJbnN0YW5jZS5vbmNlKFwiZXJyb3JcIiwgcmVqZWN0KTtcbiAgICAgICAgICAgIG1vbml0b3JJbnN0YW5jZS5vbmNlKFwibW9uaXRvcmluZ1wiLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZShtb25pdG9ySW5zdGFuY2UpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNlbmQgYSBjb21tYW5kIHRvIFJlZGlzXG4gICAgICpcbiAgICAgKiBUaGlzIG1ldGhvZCBpcyB1c2VkIGludGVybmFsbHkgYW5kIGluIG1vc3QgY2FzZXMgeW91IHNob3VsZCBub3RcbiAgICAgKiB1c2UgaXQgZGlyZWN0bHkuIElmIHlvdSBuZWVkIHRvIHNlbmQgYSBjb21tYW5kIHRoYXQgaXMgbm90IHN1cHBvcnRlZFxuICAgICAqIGJ5IHRoZSBsaWJyYXJ5LCB5b3UgY2FuIHVzZSB0aGUgYGNhbGxgIG1ldGhvZDpcbiAgICAgKlxuICAgICAqIGBgYGpzXG4gICAgICogY29uc3QgcmVkaXMgPSBuZXcgUmVkaXMoKTtcbiAgICAgKlxuICAgICAqIHJlZGlzLmNhbGwoJ3NldCcsICdmb28nLCAnYmFyJyk7XG4gICAgICogLy8gb3JcbiAgICAgKiByZWRpcy5jYWxsKFsnc2V0JywgJ2ZvbycsICdiYXInXSk7XG4gICAgICogYGBgXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgc2VuZENvbW1hbmQoY29tbWFuZCwgc3RyZWFtKSB7XG4gICAgICAgIHZhciBfYSwgX2I7XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJ3YWl0XCIpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKGxvZGFzaF8xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICgoKF9hID0gdGhpcy5jb25kaXRpb24pID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5zdWJzY3JpYmVyKSAmJlxuICAgICAgICAgICAgIUNvbW1hbmRfMS5kZWZhdWx0LmNoZWNrRmxhZyhcIlZBTElEX0lOX1NVQlNDUklCRVJfTU9ERVwiLCBjb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgRXJyb3IoXCJDb25uZWN0aW9uIGluIHN1YnNjcmliZXIgbW9kZSwgb25seSBzdWJzY3JpYmVyIGNvbW1hbmRzIG1heSBiZSB1c2VkXCIpKTtcbiAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuY29tbWFuZFRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGNvbW1hbmQuc2V0VGltZW91dCh0aGlzLm9wdGlvbnMuY29tbWFuZFRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICAgIGxldCB3cml0YWJsZSA9IHRoaXMuc3RhdHVzID09PSBcInJlYWR5XCIgfHxcbiAgICAgICAgICAgICghc3RyZWFtICYmXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwiY29ubmVjdFwiICYmXG4gICAgICAgICAgICAgICAgKDAsIGNvbW1hbmRzXzEuZXhpc3RzKShjb21tYW5kLm5hbWUpICYmXG4gICAgICAgICAgICAgICAgKDAsIGNvbW1hbmRzXzEuaGFzRmxhZykoY29tbWFuZC5uYW1lLCBcImxvYWRpbmdcIikpO1xuICAgICAgICBpZiAoIXRoaXMuc3RyZWFtKSB7XG4gICAgICAgICAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLnN0cmVhbS53cml0YWJsZSkge1xuICAgICAgICAgICAgd3JpdGFibGUgPSBmYWxzZTtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0cmVhbS5fd3JpdGFibGVTdGF0ZSAmJiB0aGlzLnN0cmVhbS5fd3JpdGFibGVTdGF0ZS5lbmRlZCkge1xuICAgICAgICAgICAgLy8gVE9ETzogV2Ugc2hvdWxkIGJlIGFibGUgdG8gcmVtb3ZlIHRoaXMgYXMgdGhlIFBSIGhhcyBhbHJlYWR5IGJlZW4gbWVyZ2VkLlxuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2lvanMvaW8uanMvcHVsbC8xMjE3XG4gICAgICAgICAgICB3cml0YWJsZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICghd3JpdGFibGUpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5vcHRpb25zLmVuYWJsZU9mZmxpbmVRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KG5ldyBFcnJvcihcIlN0cmVhbSBpc24ndCB3cml0ZWFibGUgYW5kIGVuYWJsZU9mZmxpbmVRdWV1ZSBvcHRpb25zIGlzIGZhbHNlXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGNvbW1hbmQubmFtZSA9PT0gXCJxdWl0XCIgJiYgdGhpcy5vZmZsaW5lUXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZXNvbHZlKEJ1ZmZlci5mcm9tKFwiT0tcIikpO1xuICAgICAgICAgICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwicXVldWUgY29tbWFuZFslc106ICVkIC0+ICVzKCVvKVwiLCB0aGlzLl9nZXREZXNjcmlwdGlvbigpLCB0aGlzLmNvbmRpdGlvbi5zZWxlY3QsIGNvbW1hbmQubmFtZSwgY29tbWFuZC5hcmdzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMub2ZmbGluZVF1ZXVlLnB1c2goe1xuICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgc3RyZWFtOiBzdHJlYW0sXG4gICAgICAgICAgICAgICAgc2VsZWN0OiB0aGlzLmNvbmRpdGlvbi5zZWxlY3QsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgIGlmIChkZWJ1Zy5lbmFibGVkKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJ3cml0ZSBjb21tYW5kWyVzXTogJWQgLT4gJXMoJW8pXCIsIHRoaXMuX2dldERlc2NyaXB0aW9uKCksIChfYiA9IHRoaXMuY29uZGl0aW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Iuc2VsZWN0LCBjb21tYW5kLm5hbWUsIGNvbW1hbmQuYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RyZWFtKSB7XG4gICAgICAgICAgICAgICAgaWYgKFwiaXNQaXBlbGluZVwiIGluIHN0cmVhbSAmJiBzdHJlYW0uaXNQaXBlbGluZSkge1xuICAgICAgICAgICAgICAgICAgICBzdHJlYW0ud3JpdGUoY29tbWFuZC50b1dyaXRhYmxlKHN0cmVhbS5kZXN0aW5hdGlvbi5yZWRpcy5zdHJlYW0pKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbS53cml0ZShjb21tYW5kLnRvV3JpdGFibGUoc3RyZWFtKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ud3JpdGUoY29tbWFuZC50b1dyaXRhYmxlKHRoaXMuc3RyZWFtKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbW1hbmRRdWV1ZS5wdXNoKHtcbiAgICAgICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgICAgIHN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgIHNlbGVjdDogdGhpcy5jb25kaXRpb24uc2VsZWN0LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoQ29tbWFuZF8xLmRlZmF1bHQuY2hlY2tGbGFnKFwiV0lMTF9ESVNDT05ORUNUXCIsIGNvbW1hbmQubmFtZSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXQgIT09IHVuZGVmaW5lZCAmJiB0aGlzLnNvY2tldFRpbWVvdXRUaW1lciA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTb2NrZXRUaW1lb3V0KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbW1hbmQubmFtZSA9PT0gXCJzZWxlY3RcIiAmJiAoMCwgdXRpbHNfMS5pc0ludCkoY29tbWFuZC5hcmdzWzBdKSkge1xuICAgICAgICAgICAgY29uc3QgZGIgPSBwYXJzZUludChjb21tYW5kLmFyZ3NbMF0sIDEwKTtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbmRpdGlvbi5zZWxlY3QgIT09IGRiKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25kaXRpb24uc2VsZWN0ID0gZGI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwic2VsZWN0XCIsIGRiKTtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInN3aXRjaCB0byBkYiBbJWRdXCIsIHRoaXMuY29uZGl0aW9uLnNlbGVjdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbW1hbmQucHJvbWlzZTtcbiAgICB9XG4gICAgc2V0U29ja2V0VGltZW91dCgpIHtcbiAgICAgICAgdGhpcy5zb2NrZXRUaW1lb3V0VGltZXIgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3RyZWFtLmRlc3Ryb3kobmV3IEVycm9yKGBTb2NrZXQgdGltZW91dC4gRXhwZWN0aW5nIGRhdGEsIGJ1dCBkaWRuJ3QgcmVjZWl2ZSBhbnkgaW4gJHt0aGlzLm9wdGlvbnMuc29ja2V0VGltZW91dH1tcy5gKSk7XG4gICAgICAgICAgICB0aGlzLnNvY2tldFRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgfSwgdGhpcy5vcHRpb25zLnNvY2tldFRpbWVvdXQpO1xuICAgICAgICAvLyB0aGlzIGhhbmRsZXIgbXVzdCBydW4gYWZ0ZXIgdGhlIFwiZGF0YVwiIGhhbmRsZXIgaW4gXCJEYXRhSGFuZGxlclwiXG4gICAgICAgIC8vIHNvIHRoYXQgYHRoaXMuY29tbWFuZFF1ZXVlLmxlbmd0aGAgd2lsbCBiZSB1cGRhdGVkXG4gICAgICAgIHRoaXMuc3RyZWFtLm9uY2UoXCJkYXRhXCIsICgpID0+IHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnNvY2tldFRpbWVvdXRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnNvY2tldFRpbWVvdXRUaW1lciA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIGlmICh0aGlzLmNvbW1hbmRRdWV1ZS5sZW5ndGggPT09IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zZXRTb2NrZXRUaW1lb3V0KCk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBzY2FuU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNjYW5cIiwgeyBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzY2FuQnVmZmVyU3RyZWFtKG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNjYW5CdWZmZXJcIiwgeyBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBzc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInNzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICBoc2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcImhzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhblN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICB6c2NhbkJ1ZmZlclN0cmVhbShrZXksIG9wdGlvbnMpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlU2NhblN0cmVhbShcInpzY2FuQnVmZmVyXCIsIHsga2V5LCBvcHRpb25zIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBFbWl0IG9ubHkgd2hlbiB0aGVyZSdzIGF0IGxlYXN0IG9uZSBsaXN0ZW5lci5cbiAgICAgKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBzaWxlbnRFbWl0KGV2ZW50TmFtZSwgYXJnKSB7XG4gICAgICAgIGxldCBlcnJvcjtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJlcnJvclwiKSB7XG4gICAgICAgICAgICBlcnJvciA9IGFyZztcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLm1hbnVhbGx5Q2xvc2luZykge1xuICAgICAgICAgICAgICAgIC8vIGlnbm9yZSBjb25uZWN0aW9uIHJlbGF0ZWQgZXJyb3JzIHdoZW4gbWFudWFsbHkgZGlzY29ubmVjdGluZ1xuICAgICAgICAgICAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIChlcnJvci5tZXNzYWdlID09PSB1dGlsc18xLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgZXJyb3Iuc3lzY2FsbCA9PT0gXCJjb25uZWN0XCIgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yLnN5c2NhbGwgPT09IFwicmVhZFwiKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmxpc3RlbmVycyhldmVudE5hbWUpLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXJyb3IgJiYgZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIltpb3JlZGlzXSBVbmhhbmRsZWQgZXJyb3IgZXZlbnQ6XCIsIGVycm9yLnN0YWNrKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICByZWNvdmVyRnJvbUZhdGFsRXJyb3IoX2NvbW1hbmRFcnJvciwgZXJyLCBvcHRpb25zKSB7XG4gICAgICAgIHRoaXMuZmx1c2hRdWV1ZShlcnIsIG9wdGlvbnMpO1xuICAgICAgICB0aGlzLnNpbGVudEVtaXQoXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBoYW5kbGVSZWNvbm5lY3Rpb24oZXJyLCBpdGVtKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgbGV0IG5lZWRSZWNvbm5lY3QgPSBmYWxzZTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWNvbm5lY3RPbkVycm9yKSB7XG4gICAgICAgICAgICBuZWVkUmVjb25uZWN0ID0gdGhpcy5vcHRpb25zLnJlY29ubmVjdE9uRXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG5lZWRSZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIGNhc2UgMTpcbiAgICAgICAgICAgIGNhc2UgdHJ1ZTpcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwicmVjb25uZWN0aW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0KHRydWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQucmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDI6XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzICE9PSBcInJlY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdCh0cnVlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCgoX2EgPSB0aGlzLmNvbmRpdGlvbikgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlbGVjdCkgIT09IGl0ZW0uc2VsZWN0ICYmXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5uYW1lICE9PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0KGl0ZW0uc2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgLy8gVE9ET1xuICAgICAgICAgICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGl0ZW0uY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgZGVzY3JpcHRpb24gb2YgdGhlIGNvbm5lY3Rpb24uIFVzZWQgZm9yIGRlYnVnZ2luZy5cbiAgICAgKi9cbiAgICBfZ2V0RGVzY3JpcHRpb24oKSB7XG4gICAgICAgIGxldCBkZXNjcmlwdGlvbjtcbiAgICAgICAgaWYgKFwicGF0aFwiIGluIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLm9wdGlvbnMucGF0aDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnN0cmVhbSAmJlxuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVtb3RlQWRkcmVzcyAmJlxuICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVtb3RlUG9ydCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLnN0cmVhbS5yZW1vdGVBZGRyZXNzICsgXCI6XCIgKyB0aGlzLnN0cmVhbS5yZW1vdGVQb3J0O1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFwiaG9zdFwiIGluIHRoaXMub3B0aW9ucyAmJiB0aGlzLm9wdGlvbnMuaG9zdCkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gPSB0aGlzLm9wdGlvbnMuaG9zdCArIFwiOlwiICsgdGhpcy5vcHRpb25zLnBvcnQ7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBVbmV4cGVjdGVkXG4gICAgICAgICAgICBkZXNjcmlwdGlvbiA9IFwiXCI7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5jb25uZWN0aW9uTmFtZSkge1xuICAgICAgICAgICAgZGVzY3JpcHRpb24gKz0gYCAoJHt0aGlzLm9wdGlvbnMuY29ubmVjdGlvbk5hbWV9KWA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICAgIH1cbiAgICByZXNldENvbW1hbmRRdWV1ZSgpIHtcbiAgICAgICAgdGhpcy5jb21tYW5kUXVldWUgPSBuZXcgRGVxdWUoKTtcbiAgICB9XG4gICAgcmVzZXRPZmZsaW5lUXVldWUoKSB7XG4gICAgICAgIHRoaXMub2ZmbGluZVF1ZXVlID0gbmV3IERlcXVlKCk7XG4gICAgfVxuICAgIHBhcnNlT3B0aW9ucyguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7fTtcbiAgICAgICAgbGV0IGlzVGxzID0gZmFsc2U7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgY29uc3QgYXJnID0gYXJnc1tpXTtcbiAgICAgICAgICAgIGlmIChhcmcgPT09IG51bGwgfHwgdHlwZW9mIGFyZyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKG9wdGlvbnMsIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgKDAsIGxvZGFzaF8xLmRlZmF1bHRzKShvcHRpb25zLCAoMCwgdXRpbHNfMS5wYXJzZVVSTCkoYXJnKSk7XG4gICAgICAgICAgICAgICAgaWYgKGFyZy5zdGFydHNXaXRoKFwicmVkaXNzOi8vXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlzVGxzID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXJnID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5wb3J0ID0gYXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBcIiArIGFyZyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGlzVGxzKSB7XG4gICAgICAgICAgICAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKG9wdGlvbnMsIHsgdGxzOiB0cnVlIH0pO1xuICAgICAgICB9XG4gICAgICAgICgwLCBsb2Rhc2hfMS5kZWZhdWx0cykob3B0aW9ucywgUmVkaXMuZGVmYXVsdE9wdGlvbnMpO1xuICAgICAgICBpZiAodHlwZW9mIG9wdGlvbnMucG9ydCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgb3B0aW9ucy5wb3J0ID0gcGFyc2VJbnQob3B0aW9ucy5wb3J0LCAxMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zLmRiID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLmRiID0gcGFyc2VJbnQob3B0aW9ucy5kYiwgMTApO1xuICAgICAgICB9XG4gICAgICAgIC8vIEB0cy1leHBlY3QtZXJyb3JcbiAgICAgICAgdGhpcy5vcHRpb25zID0gKDAsIHV0aWxzXzEucmVzb2x2ZVRMU1Byb2ZpbGUpKG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgaW5zdGFuY2UncyBzdGF0dXNcbiAgICAgKi9cbiAgICBzZXRTdGF0dXMoc3RhdHVzLCBhcmcpIHtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBpZiAoZGVidWcuZW5hYmxlZCkge1xuICAgICAgICAgICAgZGVidWcoXCJzdGF0dXNbJXNdOiAlcyAtPiAlc1wiLCB0aGlzLl9nZXREZXNjcmlwdGlvbigpLCB0aGlzLnN0YXR1cyB8fCBcIltlbXB0eV1cIiwgc3RhdHVzKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljayh0aGlzLmVtaXQuYmluZCh0aGlzLCBzdGF0dXMsIGFyZykpO1xuICAgIH1cbiAgICBjcmVhdGVTY2FuU3RyZWFtKGNvbW1hbmQsIHsga2V5LCBvcHRpb25zID0ge30gfSkge1xuICAgICAgICByZXR1cm4gbmV3IFNjYW5TdHJlYW1fMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIG9iamVjdE1vZGU6IHRydWUsXG4gICAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICAgIHJlZGlzOiB0aGlzLFxuICAgICAgICAgICAgY29tbWFuZDogY29tbWFuZCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBGbHVzaCBvZmZsaW5lIHF1ZXVlIGFuZCBjb21tYW5kIHF1ZXVlIHdpdGggZXJyb3IuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gZXJyb3IgVGhlIGVycm9yIG9iamVjdCB0byBzZW5kIHRvIHRoZSBjb21tYW5kc1xuICAgICAqIEBwYXJhbSBvcHRpb25zIG9wdGlvbnNcbiAgICAgKi9cbiAgICBmbHVzaFF1ZXVlKGVycm9yLCBvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKHt9LCBvcHRpb25zLCB7XG4gICAgICAgICAgICBvZmZsaW5lUXVldWU6IHRydWUsXG4gICAgICAgICAgICBjb21tYW5kUXVldWU6IHRydWUsXG4gICAgICAgIH0pO1xuICAgICAgICBsZXQgaXRlbTtcbiAgICAgICAgaWYgKG9wdGlvbnMub2ZmbGluZVF1ZXVlKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSB0aGlzLm9mZmxpbmVRdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNvbW1hbmRRdWV1ZSkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY29tbWFuZFF1ZXVlLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0ucmVtb3ZlQWxsTGlzdGVuZXJzKFwiZGF0YVwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgd2hpbGUgKChpdGVtID0gdGhpcy5jb21tYW5kUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnJvcik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENoZWNrIHdoZXRoZXIgUmVkaXMgaGFzIGZpbmlzaGVkIGxvYWRpbmcgdGhlIHBlcnNpc3RlbnQgZGF0YSBhbmQgaXMgYWJsZSB0b1xuICAgICAqIHByb2Nlc3MgY29tbWFuZHMuXG4gICAgICovXG4gICAgX3JlYWR5Q2hlY2soY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmluZm8oZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlICYmIGVyci5tZXNzYWdlLmluY2x1ZGVzKFwiTk9QRVJNXCIpKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgU2tpcHBpbmcgdGhlIHJlYWR5IGNoZWNrIGJlY2F1c2UgSU5GTyBjb21tYW5kIGZhaWxzOiBcIiR7ZXJyLm1lc3NhZ2V9XCIuIFlvdSBjYW4gZGlzYWJsZSByZWFkeSBjaGVjayB3aXRoIFwiZW5hYmxlUmVhZHlDaGVja1wiLiBNb3JlOiBodHRwczovL2dpdGh1Yi5jb20vbHVpbi9pb3JlZGlzL3dpa2kvRGlzYWJsZS1yZWFkeS1jaGVjay5gKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKG51bGwsIHt9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhudWxsLCByZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgaW5mbyA9IHt9O1xuICAgICAgICAgICAgY29uc3QgbGluZXMgPSByZXMuc3BsaXQoXCJcXHJcXG5cIik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxpbmVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgW2ZpZWxkTmFtZSwgLi4uZmllbGRWYWx1ZVBhcnRzXSA9IGxpbmVzW2ldLnNwbGl0KFwiOlwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gZmllbGRWYWx1ZVBhcnRzLmpvaW4oXCI6XCIpO1xuICAgICAgICAgICAgICAgIGlmIChmaWVsZFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgICAgIGluZm9bZmllbGROYW1lXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFpbmZvLmxvYWRpbmcgfHwgaW5mby5sb2FkaW5nID09PSBcIjBcIikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGluZm8pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9hZGluZ0V0YU1zID0gKGluZm8ubG9hZGluZ19ldGFfc2Vjb25kcyB8fCAxKSAqIDEwMDA7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlUaW1lID0gX3RoaXMub3B0aW9ucy5tYXhMb2FkaW5nUmV0cnlUaW1lICYmXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9wdGlvbnMubWF4TG9hZGluZ1JldHJ5VGltZSA8IGxvYWRpbmdFdGFNc1xuICAgICAgICAgICAgICAgICAgICA/IF90aGlzLm9wdGlvbnMubWF4TG9hZGluZ1JldHJ5VGltZVxuICAgICAgICAgICAgICAgICAgICA6IGxvYWRpbmdFdGFNcztcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIlJlZGlzIHNlcnZlciBzdGlsbCBsb2FkaW5nLCB0cnlpbmcgYWdhaW4gaW4gXCIgKyByZXRyeVRpbWUgKyBcIm1zXCIpO1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fcmVhZHlDaGVjayhjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSwgcmV0cnlUaW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSkuY2F0Y2gobG9kYXNoXzEubm9vcCk7XG4gICAgfVxufVxuUmVkaXMuQ2x1c3RlciA9IGNsdXN0ZXJfMS5kZWZhdWx0O1xuUmVkaXMuQ29tbWFuZCA9IENvbW1hbmRfMS5kZWZhdWx0O1xuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnNcbiAqL1xuUmVkaXMuZGVmYXVsdE9wdGlvbnMgPSBSZWRpc09wdGlvbnNfMS5ERUZBVUxUX1JFRElTX09QVElPTlM7XG4oMCwgYXBwbHlNaXhpbl8xLmRlZmF1bHQpKFJlZGlzLCBldmVudHNfMS5FdmVudEVtaXR0ZXIpO1xuKDAsIHRyYW5zYWN0aW9uXzEuYWRkVHJhbnNhY3Rpb25TdXBwb3J0KShSZWRpcy5wcm90b3R5cGUpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVkaXM7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/ScanStream.js":
/*!***************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/ScanStream.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\n/**\n * Convenient class to convert the process of scanning keys to a readable stream.\n */\nclass ScanStream extends stream_1.Readable {\n    constructor(opt) {\n        super(opt);\n        this.opt = opt;\n        this._redisCursor = \"0\";\n        this._redisDrained = false;\n    }\n    _read() {\n        if (this._redisDrained) {\n            this.push(null);\n            return;\n        }\n        const args = [this._redisCursor];\n        if (this.opt.key) {\n            args.unshift(this.opt.key);\n        }\n        if (this.opt.match) {\n            args.push(\"MATCH\", this.opt.match);\n        }\n        if (this.opt.type) {\n            args.push(\"TYPE\", this.opt.type);\n        }\n        if (this.opt.count) {\n            args.push(\"COUNT\", String(this.opt.count));\n        }\n        if (this.opt.noValues) {\n            args.push(\"NOVALUES\");\n        }\n        this.opt.redis[this.opt.command](args, (err, res) => {\n            if (err) {\n                this.emit(\"error\", err);\n                return;\n            }\n            this._redisCursor = res[0] instanceof Buffer ? res[0].toString() : res[0];\n            if (this._redisCursor === \"0\") {\n                this._redisDrained = true;\n            }\n            this.push(res[1]);\n        });\n    }\n    close() {\n        this._redisDrained = true;\n    }\n}\nexports[\"default\"] = ScanStream;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NhblN0cmVhbS5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NhblN0cmVhbS5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHN0cmVhbV8xID0gcmVxdWlyZShcInN0cmVhbVwiKTtcbi8qKlxuICogQ29udmVuaWVudCBjbGFzcyB0byBjb252ZXJ0IHRoZSBwcm9jZXNzIG9mIHNjYW5uaW5nIGtleXMgdG8gYSByZWFkYWJsZSBzdHJlYW0uXG4gKi9cbmNsYXNzIFNjYW5TdHJlYW0gZXh0ZW5kcyBzdHJlYW1fMS5SZWFkYWJsZSB7XG4gICAgY29uc3RydWN0b3Iob3B0KSB7XG4gICAgICAgIHN1cGVyKG9wdCk7XG4gICAgICAgIHRoaXMub3B0ID0gb3B0O1xuICAgICAgICB0aGlzLl9yZWRpc0N1cnNvciA9IFwiMFwiO1xuICAgICAgICB0aGlzLl9yZWRpc0RyYWluZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgX3JlYWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9yZWRpc0RyYWluZWQpIHtcbiAgICAgICAgICAgIHRoaXMucHVzaChudWxsKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBhcmdzID0gW3RoaXMuX3JlZGlzQ3Vyc29yXTtcbiAgICAgICAgaWYgKHRoaXMub3B0LmtleSkge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KHRoaXMub3B0LmtleSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0Lm1hdGNoKSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCJNQVRDSFwiLCB0aGlzLm9wdC5tYXRjaCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0LnR5cGUpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIlRZUEVcIiwgdGhpcy5vcHQudHlwZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMub3B0LmNvdW50KSB7XG4gICAgICAgICAgICBhcmdzLnB1c2goXCJDT1VOVFwiLCBTdHJpbmcodGhpcy5vcHQuY291bnQpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHQubm9WYWx1ZXMpIHtcbiAgICAgICAgICAgIGFyZ3MucHVzaChcIk5PVkFMVUVTXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub3B0LnJlZGlzW3RoaXMub3B0LmNvbW1hbmRdKGFyZ3MsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChcImVycm9yXCIsIGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVkaXNDdXJzb3IgPSByZXNbMF0gaW5zdGFuY2VvZiBCdWZmZXIgPyByZXNbMF0udG9TdHJpbmcoKSA6IHJlc1swXTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9yZWRpc0N1cnNvciA9PT0gXCIwXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl9yZWRpc0RyYWluZWQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5wdXNoKHJlc1sxXSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fcmVkaXNEcmFpbmVkID0gdHJ1ZTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTY2FuU3RyZWFtO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/ScanStream.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Script.js":
/*!***********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Script.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst crypto_1 = __webpack_require__(/*! crypto */ \"crypto\");\nconst Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nclass Script {\n    constructor(lua, numberOfKeys = null, keyPrefix = \"\", readOnly = false) {\n        this.lua = lua;\n        this.numberOfKeys = numberOfKeys;\n        this.keyPrefix = keyPrefix;\n        this.readOnly = readOnly;\n        this.sha = (0, crypto_1.createHash)(\"sha1\").update(lua).digest(\"hex\");\n        const sha = this.sha;\n        const socketHasScriptLoaded = new WeakSet();\n        this.Command = class CustomScriptCommand extends Command_1.default {\n            toWritable(socket) {\n                const origReject = this.reject;\n                this.reject = (err) => {\n                    if (err.message.indexOf(\"NOSCRIPT\") !== -1) {\n                        socketHasScriptLoaded.delete(socket);\n                    }\n                    origReject.call(this, err);\n                };\n                if (!socketHasScriptLoaded.has(socket)) {\n                    socketHasScriptLoaded.add(socket);\n                    this.name = \"eval\";\n                    this.args[0] = lua;\n                }\n                else if (this.name === \"eval\") {\n                    this.name = \"evalsha\";\n                    this.args[0] = sha;\n                }\n                return super.toWritable(socket);\n            }\n        };\n    }\n    execute(container, args, options, callback) {\n        if (typeof this.numberOfKeys === \"number\") {\n            args.unshift(this.numberOfKeys);\n        }\n        if (this.keyPrefix) {\n            options.keyPrefix = this.keyPrefix;\n        }\n        if (this.readOnly) {\n            options.readOnly = true;\n        }\n        const evalsha = new this.Command(\"evalsha\", [this.sha, ...args], options);\n        evalsha.promise = evalsha.promise.catch((err) => {\n            if (err.message.indexOf(\"NOSCRIPT\") === -1) {\n                throw err;\n            }\n            // Resend the same custom evalsha command that gets transformed\n            // to an eval in case it's not loaded yet on the connection.\n            const resend = new this.Command(\"evalsha\", [this.sha, ...args], options);\n            const client = container.isPipeline ? container.redis : container;\n            return client.sendCommand(resend);\n        });\n        (0, standard_as_callback_1.default)(evalsha.promise, callback);\n        return container.sendCommand(evalsha);\n    }\n}\nexports[\"default\"] = Script;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NyaXB0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlCQUFpQixtQkFBTyxDQUFDLHNCQUFRO0FBQ2pDLGtCQUFrQixtQkFBTyxDQUFDLHFHQUFXO0FBQ3JDLCtCQUErQixtQkFBTyxDQUFDLHdJQUFzQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU2NyaXB0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY3J5cHRvXzEgPSByZXF1aXJlKFwiY3J5cHRvXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jbGFzcyBTY3JpcHQge1xuICAgIGNvbnN0cnVjdG9yKGx1YSwgbnVtYmVyT2ZLZXlzID0gbnVsbCwga2V5UHJlZml4ID0gXCJcIiwgcmVhZE9ubHkgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmx1YSA9IGx1YTtcbiAgICAgICAgdGhpcy5udW1iZXJPZktleXMgPSBudW1iZXJPZktleXM7XG4gICAgICAgIHRoaXMua2V5UHJlZml4ID0ga2V5UHJlZml4O1xuICAgICAgICB0aGlzLnJlYWRPbmx5ID0gcmVhZE9ubHk7XG4gICAgICAgIHRoaXMuc2hhID0gKDAsIGNyeXB0b18xLmNyZWF0ZUhhc2gpKFwic2hhMVwiKS51cGRhdGUobHVhKS5kaWdlc3QoXCJoZXhcIik7XG4gICAgICAgIGNvbnN0IHNoYSA9IHRoaXMuc2hhO1xuICAgICAgICBjb25zdCBzb2NrZXRIYXNTY3JpcHRMb2FkZWQgPSBuZXcgV2Vha1NldCgpO1xuICAgICAgICB0aGlzLkNvbW1hbmQgPSBjbGFzcyBDdXN0b21TY3JpcHRDb21tYW5kIGV4dGVuZHMgQ29tbWFuZF8xLmRlZmF1bHQge1xuICAgICAgICAgICAgdG9Xcml0YWJsZShzb2NrZXQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcmlnUmVqZWN0ID0gdGhpcy5yZWplY3Q7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWplY3QgPSAoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwiTk9TQ1JJUFRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzb2NrZXRIYXNTY3JpcHRMb2FkZWQuZGVsZXRlKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgb3JpZ1JlamVjdC5jYWxsKHRoaXMsIGVycik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoIXNvY2tldEhhc1NjcmlwdExvYWRlZC5oYXMoc29ja2V0KSkge1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXRIYXNTY3JpcHRMb2FkZWQuYWRkKHNvY2tldCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSA9IFwiZXZhbFwiO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmFyZ3NbMF0gPSBsdWE7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRoaXMubmFtZSA9PT0gXCJldmFsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lID0gXCJldmFsc2hhXCI7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuYXJnc1swXSA9IHNoYTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN1cGVyLnRvV3JpdGFibGUoc29ja2V0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgZXhlY3V0ZShjb250YWluZXIsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5udW1iZXJPZktleXMgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIGFyZ3MudW5zaGlmdCh0aGlzLm51bWJlck9mS2V5cyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMua2V5UHJlZml4KSB7XG4gICAgICAgICAgICBvcHRpb25zLmtleVByZWZpeCA9IHRoaXMua2V5UHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnJlYWRPbmx5KSB7XG4gICAgICAgICAgICBvcHRpb25zLnJlYWRPbmx5ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBldmFsc2hhID0gbmV3IHRoaXMuQ29tbWFuZChcImV2YWxzaGFcIiwgW3RoaXMuc2hhLCAuLi5hcmdzXSwgb3B0aW9ucyk7XG4gICAgICAgIGV2YWxzaGEucHJvbWlzZSA9IGV2YWxzaGEucHJvbWlzZS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UuaW5kZXhPZihcIk5PU0NSSVBUXCIpID09PSAtMSkge1xuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlc2VuZCB0aGUgc2FtZSBjdXN0b20gZXZhbHNoYSBjb21tYW5kIHRoYXQgZ2V0cyB0cmFuc2Zvcm1lZFxuICAgICAgICAgICAgLy8gdG8gYW4gZXZhbCBpbiBjYXNlIGl0J3Mgbm90IGxvYWRlZCB5ZXQgb24gdGhlIGNvbm5lY3Rpb24uXG4gICAgICAgICAgICBjb25zdCByZXNlbmQgPSBuZXcgdGhpcy5Db21tYW5kKFwiZXZhbHNoYVwiLCBbdGhpcy5zaGEsIC4uLmFyZ3NdLCBvcHRpb25zKTtcbiAgICAgICAgICAgIGNvbnN0IGNsaWVudCA9IGNvbnRhaW5lci5pc1BpcGVsaW5lID8gY29udGFpbmVyLnJlZGlzIDogY29udGFpbmVyO1xuICAgICAgICAgICAgcmV0dXJuIGNsaWVudC5zZW5kQ29tbWFuZChyZXNlbmQpO1xuICAgICAgICB9KTtcbiAgICAgICAgKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkoZXZhbHNoYS5wcm9taXNlLCBjYWxsYmFjayk7XG4gICAgICAgIHJldHVybiBjb250YWluZXIuc2VuZENvbW1hbmQoZXZhbHNoYSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU2NyaXB0O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Script.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/SubscriptionSet.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/SubscriptionSet.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * Tiny class to simplify dealing with subscription set\n */\nclass SubscriptionSet {\n    constructor() {\n        this.set = {\n            subscribe: {},\n            psubscribe: {},\n            ssubscribe: {},\n        };\n    }\n    add(set, channel) {\n        this.set[mapSet(set)][channel] = true;\n    }\n    del(set, channel) {\n        delete this.set[mapSet(set)][channel];\n    }\n    channels(set) {\n        return Object.keys(this.set[mapSet(set)]);\n    }\n    isEmpty() {\n        return (this.channels(\"subscribe\").length === 0 &&\n            this.channels(\"psubscribe\").length === 0 &&\n            this.channels(\"ssubscribe\").length === 0);\n    }\n}\nexports[\"default\"] = SubscriptionSet;\nfunction mapSet(set) {\n    if (set === \"unsubscribe\") {\n        return \"subscribe\";\n    }\n    if (set === \"punsubscribe\") {\n        return \"psubscribe\";\n    }\n    if (set === \"sunsubscribe\") {\n        return \"ssubscribe\";\n    }\n    return set;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU3Vic2NyaXB0aW9uU2V0LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QiwwQkFBMEI7QUFDMUIsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvU3Vic2NyaXB0aW9uU2V0LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqXG4gKiBUaW55IGNsYXNzIHRvIHNpbXBsaWZ5IGRlYWxpbmcgd2l0aCBzdWJzY3JpcHRpb24gc2V0XG4gKi9cbmNsYXNzIFN1YnNjcmlwdGlvblNldCB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHRoaXMuc2V0ID0ge1xuICAgICAgICAgICAgc3Vic2NyaWJlOiB7fSxcbiAgICAgICAgICAgIHBzdWJzY3JpYmU6IHt9LFxuICAgICAgICAgICAgc3N1YnNjcmliZToge30sXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFkZChzZXQsIGNoYW5uZWwpIHtcbiAgICAgICAgdGhpcy5zZXRbbWFwU2V0KHNldCldW2NoYW5uZWxdID0gdHJ1ZTtcbiAgICB9XG4gICAgZGVsKHNldCwgY2hhbm5lbCkge1xuICAgICAgICBkZWxldGUgdGhpcy5zZXRbbWFwU2V0KHNldCldW2NoYW5uZWxdO1xuICAgIH1cbiAgICBjaGFubmVscyhzZXQpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2V0W21hcFNldChzZXQpXSk7XG4gICAgfVxuICAgIGlzRW1wdHkoKSB7XG4gICAgICAgIHJldHVybiAodGhpcy5jaGFubmVscyhcInN1YnNjcmliZVwiKS5sZW5ndGggPT09IDAgJiZcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpLmxlbmd0aCA9PT0gMCAmJlxuICAgICAgICAgICAgdGhpcy5jaGFubmVscyhcInNzdWJzY3JpYmVcIikubGVuZ3RoID09PSAwKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTdWJzY3JpcHRpb25TZXQ7XG5mdW5jdGlvbiBtYXBTZXQoc2V0KSB7XG4gICAgaWYgKHNldCA9PT0gXCJ1bnN1YnNjcmliZVwiKSB7XG4gICAgICAgIHJldHVybiBcInN1YnNjcmliZVwiO1xuICAgIH1cbiAgICBpZiAoc2V0ID09PSBcInB1bnN1YnNjcmliZVwiKSB7XG4gICAgICAgIHJldHVybiBcInBzdWJzY3JpYmVcIjtcbiAgICB9XG4gICAgaWYgKHNldCA9PT0gXCJzdW5zdWJzY3JpYmVcIikge1xuICAgICAgICByZXR1cm4gXCJzc3Vic2NyaWJlXCI7XG4gICAgfVxuICAgIHJldHVybiBzZXQ7XG59XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/SubscriptionSet.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/autoPipelining.js":
/*!*******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/autoPipelining.js ***!
  \*******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.executeWithAutoPipelining = exports.getFirstValueInFlattenedArray = exports.shouldUseAutoPipelining = exports.notAllowedAutoPipelineCommands = exports.kCallbacks = exports.kExec = void 0;\nconst lodash_1 = __webpack_require__(/*! ./utils/lodash */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/lodash.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/../../node_modules/.pnpm/cluster-key-slot@1.1.2/node_modules/cluster-key-slot/lib/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nexports.kExec = Symbol(\"exec\");\nexports.kCallbacks = Symbol(\"callbacks\");\nexports.notAllowedAutoPipelineCommands = [\n    \"auth\",\n    \"info\",\n    \"script\",\n    \"quit\",\n    \"cluster\",\n    \"pipeline\",\n    \"multi\",\n    \"subscribe\",\n    \"psubscribe\",\n    \"unsubscribe\",\n    \"unpsubscribe\",\n    \"select\",\n];\nfunction executeAutoPipeline(client, slotKey) {\n    /*\n      If a pipeline is already executing, keep queueing up commands\n      since ioredis won't serve two pipelines at the same time\n    */\n    if (client._runningAutoPipelines.has(slotKey)) {\n        return;\n    }\n    if (!client._autoPipelines.has(slotKey)) {\n        /*\n          Rare edge case. Somehow, something has deleted this running autopipeline in an immediate\n          call to executeAutoPipeline.\n         \n          Maybe the callback in the pipeline.exec is sometimes called in the same tick,\n          e.g. if redis is disconnected?\n        */\n        return;\n    }\n    client._runningAutoPipelines.add(slotKey);\n    // Get the pipeline and immediately delete it so that new commands are queued on a new pipeline\n    const pipeline = client._autoPipelines.get(slotKey);\n    client._autoPipelines.delete(slotKey);\n    const callbacks = pipeline[exports.kCallbacks];\n    // Stop keeping a reference to callbacks immediately after the callbacks stop being used.\n    // This allows the GC to reclaim objects referenced by callbacks, especially with 16384 slots\n    // in Redis.Cluster\n    pipeline[exports.kCallbacks] = null;\n    // Perform the call\n    pipeline.exec(function (err, results) {\n        client._runningAutoPipelines.delete(slotKey);\n        /*\n          Invoke all callback in nextTick so the stack is cleared\n          and callbacks can throw errors without affecting other callbacks.\n        */\n        if (err) {\n            for (let i = 0; i < callbacks.length; i++) {\n                process.nextTick(callbacks[i], err);\n            }\n        }\n        else {\n            for (let i = 0; i < callbacks.length; i++) {\n                process.nextTick(callbacks[i], ...results[i]);\n            }\n        }\n        // If there is another pipeline on the same node, immediately execute it without waiting for nextTick\n        if (client._autoPipelines.has(slotKey)) {\n            executeAutoPipeline(client, slotKey);\n        }\n    });\n}\nfunction shouldUseAutoPipelining(client, functionName, commandName) {\n    return (functionName &&\n        client.options.enableAutoPipelining &&\n        !client.isPipeline &&\n        !exports.notAllowedAutoPipelineCommands.includes(commandName) &&\n        !client.options.autoPipeliningIgnoredCommands.includes(commandName));\n}\nexports.shouldUseAutoPipelining = shouldUseAutoPipelining;\nfunction getFirstValueInFlattenedArray(args) {\n    for (let i = 0; i < args.length; i++) {\n        const arg = args[i];\n        if (typeof arg === \"string\") {\n            return arg;\n        }\n        else if (Array.isArray(arg) || (0, lodash_1.isArguments)(arg)) {\n            if (arg.length === 0) {\n                continue;\n            }\n            return arg[0];\n        }\n        const flattened = [arg].flat();\n        if (flattened.length > 0) {\n            return flattened[0];\n        }\n    }\n    return undefined;\n}\nexports.getFirstValueInFlattenedArray = getFirstValueInFlattenedArray;\nfunction executeWithAutoPipelining(client, functionName, commandName, args, callback) {\n    // On cluster mode let's wait for slots to be available\n    if (client.isCluster && !client.slots.length) {\n        if (client.status === \"wait\")\n            client.connect().catch(lodash_1.noop);\n        return (0, standard_as_callback_1.default)(new Promise(function (resolve, reject) {\n            client.delayUntilReady((err) => {\n                if (err) {\n                    reject(err);\n                    return;\n                }\n                executeWithAutoPipelining(client, functionName, commandName, args, null).then(resolve, reject);\n            });\n        }), callback);\n    }\n    // If we have slot information, we can improve routing by grouping slots served by the same subset of nodes\n    // Note that the first value in args may be a (possibly empty) array.\n    // ioredis will only flatten one level of the array, in the Command constructor.\n    const prefix = client.options.keyPrefix || \"\";\n    const slotKey = client.isCluster\n        ? client.slots[calculateSlot(`${prefix}${getFirstValueInFlattenedArray(args)}`)].join(\",\")\n        : \"main\";\n    if (!client._autoPipelines.has(slotKey)) {\n        const pipeline = client.pipeline();\n        pipeline[exports.kExec] = false;\n        pipeline[exports.kCallbacks] = [];\n        client._autoPipelines.set(slotKey, pipeline);\n    }\n    const pipeline = client._autoPipelines.get(slotKey);\n    /*\n      Mark the pipeline as scheduled.\n      The symbol will make sure that the pipeline is only scheduled once per tick.\n      New commands are appended to an already scheduled pipeline.\n    */\n    if (!pipeline[exports.kExec]) {\n        pipeline[exports.kExec] = true;\n        /*\n          Deferring with setImmediate so we have a chance to capture multiple\n          commands that can be scheduled by I/O events already in the event loop queue.\n        */\n        setImmediate(executeAutoPipeline, client, slotKey);\n    }\n    // Create the promise which will execute the command in the pipeline.\n    const autoPipelinePromise = new Promise(function (resolve, reject) {\n        pipeline[exports.kCallbacks].push(function (err, value) {\n            if (err) {\n                reject(err);\n                return;\n            }\n            resolve(value);\n        });\n        if (functionName === \"call\") {\n            args.unshift(commandName);\n        }\n        pipeline[functionName](...args);\n    });\n    return (0, standard_as_callback_1.default)(autoPipelinePromise, callback);\n}\nexports.executeWithAutoPipelining = executeWithAutoPipelining;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvYXV0b1BpcGVsaW5pbmcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsaUNBQWlDLEdBQUcscUNBQXFDLEdBQUcsK0JBQStCLEdBQUcsc0NBQXNDLEdBQUcsa0JBQWtCLEdBQUcsYUFBYTtBQUN6TCxpQkFBaUIsbUJBQU8sQ0FBQywrR0FBZ0I7QUFDekMsc0JBQXNCLG1CQUFPLENBQUMsMEhBQWtCO0FBQ2hELCtCQUErQixtQkFBTyxDQUFDLHdJQUFzQjtBQUM3RCxhQUFhO0FBQ2Isa0JBQWtCO0FBQ2xCLHNDQUFzQztBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsc0JBQXNCO0FBQ2xEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHNCQUFzQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLE9BQU8sRUFBRSxvQ0FBb0M7QUFDckY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsaUNBQWlDIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9hdXRvUGlwZWxpbmluZy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyA9IGV4cG9ydHMuZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXkgPSBleHBvcnRzLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nID0gZXhwb3J0cy5ub3RBbGxvd2VkQXV0b1BpcGVsaW5lQ29tbWFuZHMgPSBleHBvcnRzLmtDYWxsYmFja3MgPSBleHBvcnRzLmtFeGVjID0gdm9pZCAwO1xuY29uc3QgbG9kYXNoXzEgPSByZXF1aXJlKFwiLi91dGlscy9sb2Rhc2hcIik7XG5jb25zdCBjYWxjdWxhdGVTbG90ID0gcmVxdWlyZShcImNsdXN0ZXIta2V5LXNsb3RcIik7XG5jb25zdCBzdGFuZGFyZF9hc19jYWxsYmFja18xID0gcmVxdWlyZShcInN0YW5kYXJkLWFzLWNhbGxiYWNrXCIpO1xuZXhwb3J0cy5rRXhlYyA9IFN5bWJvbChcImV4ZWNcIik7XG5leHBvcnRzLmtDYWxsYmFja3MgPSBTeW1ib2woXCJjYWxsYmFja3NcIik7XG5leHBvcnRzLm5vdEFsbG93ZWRBdXRvUGlwZWxpbmVDb21tYW5kcyA9IFtcbiAgICBcImF1dGhcIixcbiAgICBcImluZm9cIixcbiAgICBcInNjcmlwdFwiLFxuICAgIFwicXVpdFwiLFxuICAgIFwiY2x1c3RlclwiLFxuICAgIFwicGlwZWxpbmVcIixcbiAgICBcIm11bHRpXCIsXG4gICAgXCJzdWJzY3JpYmVcIixcbiAgICBcInBzdWJzY3JpYmVcIixcbiAgICBcInVuc3Vic2NyaWJlXCIsXG4gICAgXCJ1bnBzdWJzY3JpYmVcIixcbiAgICBcInNlbGVjdFwiLFxuXTtcbmZ1bmN0aW9uIGV4ZWN1dGVBdXRvUGlwZWxpbmUoY2xpZW50LCBzbG90S2V5KSB7XG4gICAgLypcbiAgICAgIElmIGEgcGlwZWxpbmUgaXMgYWxyZWFkeSBleGVjdXRpbmcsIGtlZXAgcXVldWVpbmcgdXAgY29tbWFuZHNcbiAgICAgIHNpbmNlIGlvcmVkaXMgd29uJ3Qgc2VydmUgdHdvIHBpcGVsaW5lcyBhdCB0aGUgc2FtZSB0aW1lXG4gICAgKi9cbiAgICBpZiAoY2xpZW50Ll9ydW5uaW5nQXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIWNsaWVudC5fYXV0b1BpcGVsaW5lcy5oYXMoc2xvdEtleSkpIHtcbiAgICAgICAgLypcbiAgICAgICAgICBSYXJlIGVkZ2UgY2FzZS4gU29tZWhvdywgc29tZXRoaW5nIGhhcyBkZWxldGVkIHRoaXMgcnVubmluZyBhdXRvcGlwZWxpbmUgaW4gYW4gaW1tZWRpYXRlXG4gICAgICAgICAgY2FsbCB0byBleGVjdXRlQXV0b1BpcGVsaW5lLlxuICAgICAgICAgXG4gICAgICAgICAgTWF5YmUgdGhlIGNhbGxiYWNrIGluIHRoZSBwaXBlbGluZS5leGVjIGlzIHNvbWV0aW1lcyBjYWxsZWQgaW4gdGhlIHNhbWUgdGljayxcbiAgICAgICAgICBlLmcuIGlmIHJlZGlzIGlzIGRpc2Nvbm5lY3RlZD9cbiAgICAgICAgKi9cbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjbGllbnQuX3J1bm5pbmdBdXRvUGlwZWxpbmVzLmFkZChzbG90S2V5KTtcbiAgICAvLyBHZXQgdGhlIHBpcGVsaW5lIGFuZCBpbW1lZGlhdGVseSBkZWxldGUgaXQgc28gdGhhdCBuZXcgY29tbWFuZHMgYXJlIHF1ZXVlZCBvbiBhIG5ldyBwaXBlbGluZVxuICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50Ll9hdXRvUGlwZWxpbmVzLmdldChzbG90S2V5KTtcbiAgICBjbGllbnQuX2F1dG9QaXBlbGluZXMuZGVsZXRlKHNsb3RLZXkpO1xuICAgIGNvbnN0IGNhbGxiYWNrcyA9IHBpcGVsaW5lW2V4cG9ydHMua0NhbGxiYWNrc107XG4gICAgLy8gU3RvcCBrZWVwaW5nIGEgcmVmZXJlbmNlIHRvIGNhbGxiYWNrcyBpbW1lZGlhdGVseSBhZnRlciB0aGUgY2FsbGJhY2tzIHN0b3AgYmVpbmcgdXNlZC5cbiAgICAvLyBUaGlzIGFsbG93cyB0aGUgR0MgdG8gcmVjbGFpbSBvYmplY3RzIHJlZmVyZW5jZWQgYnkgY2FsbGJhY2tzLCBlc3BlY2lhbGx5IHdpdGggMTYzODQgc2xvdHNcbiAgICAvLyBpbiBSZWRpcy5DbHVzdGVyXG4gICAgcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXSA9IG51bGw7XG4gICAgLy8gUGVyZm9ybSB0aGUgY2FsbFxuICAgIHBpcGVsaW5lLmV4ZWMoZnVuY3Rpb24gKGVyciwgcmVzdWx0cykge1xuICAgICAgICBjbGllbnQuX3J1bm5pbmdBdXRvUGlwZWxpbmVzLmRlbGV0ZShzbG90S2V5KTtcbiAgICAgICAgLypcbiAgICAgICAgICBJbnZva2UgYWxsIGNhbGxiYWNrIGluIG5leHRUaWNrIHNvIHRoZSBzdGFjayBpcyBjbGVhcmVkXG4gICAgICAgICAgYW5kIGNhbGxiYWNrcyBjYW4gdGhyb3cgZXJyb3JzIHdpdGhvdXQgYWZmZWN0aW5nIG90aGVyIGNhbGxiYWNrcy5cbiAgICAgICAgKi9cbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBjYWxsYmFja3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKGNhbGxiYWNrc1tpXSwgZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY2FsbGJhY2tzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjYWxsYmFja3NbaV0sIC4uLnJlc3VsdHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGFub3RoZXIgcGlwZWxpbmUgb24gdGhlIHNhbWUgbm9kZSwgaW1tZWRpYXRlbHkgZXhlY3V0ZSBpdCB3aXRob3V0IHdhaXRpbmcgZm9yIG5leHRUaWNrXG4gICAgICAgIGlmIChjbGllbnQuX2F1dG9QaXBlbGluZXMuaGFzKHNsb3RLZXkpKSB7XG4gICAgICAgICAgICBleGVjdXRlQXV0b1BpcGVsaW5lKGNsaWVudCwgc2xvdEtleSk7XG4gICAgICAgIH1cbiAgICB9KTtcbn1cbmZ1bmN0aW9uIHNob3VsZFVzZUF1dG9QaXBlbGluaW5nKGNsaWVudCwgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSkge1xuICAgIHJldHVybiAoZnVuY3Rpb25OYW1lICYmXG4gICAgICAgIGNsaWVudC5vcHRpb25zLmVuYWJsZUF1dG9QaXBlbGluaW5nICYmXG4gICAgICAgICFjbGllbnQuaXNQaXBlbGluZSAmJlxuICAgICAgICAhZXhwb3J0cy5ub3RBbGxvd2VkQXV0b1BpcGVsaW5lQ29tbWFuZHMuaW5jbHVkZXMoY29tbWFuZE5hbWUpICYmXG4gICAgICAgICFjbGllbnQub3B0aW9ucy5hdXRvUGlwZWxpbmluZ0lnbm9yZWRDb21tYW5kcy5pbmNsdWRlcyhjb21tYW5kTmFtZSkpO1xufVxuZXhwb3J0cy5zaG91bGRVc2VBdXRvUGlwZWxpbmluZyA9IHNob3VsZFVzZUF1dG9QaXBlbGluaW5nO1xuZnVuY3Rpb24gZ2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXkoYXJncykge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJncy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBhcmcgPSBhcmdzW2ldO1xuICAgICAgICBpZiAodHlwZW9mIGFyZyA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGFyZztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykgfHwgKDAsIGxvZGFzaF8xLmlzQXJndW1lbnRzKShhcmcpKSB7XG4gICAgICAgICAgICBpZiAoYXJnLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGFyZ1swXTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmbGF0dGVuZWQgPSBbYXJnXS5mbGF0KCk7XG4gICAgICAgIGlmIChmbGF0dGVuZWQubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgcmV0dXJuIGZsYXR0ZW5lZFswXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5nZXRGaXJzdFZhbHVlSW5GbGF0dGVuZWRBcnJheSA9IGdldEZpcnN0VmFsdWVJbkZsYXR0ZW5lZEFycmF5O1xuZnVuY3Rpb24gZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZyhjbGllbnQsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIGFyZ3MsIGNhbGxiYWNrKSB7XG4gICAgLy8gT24gY2x1c3RlciBtb2RlIGxldCdzIHdhaXQgZm9yIHNsb3RzIHRvIGJlIGF2YWlsYWJsZVxuICAgIGlmIChjbGllbnQuaXNDbHVzdGVyICYmICFjbGllbnQuc2xvdHMubGVuZ3RoKSB7XG4gICAgICAgIGlmIChjbGllbnQuc3RhdHVzID09PSBcIndhaXRcIilcbiAgICAgICAgICAgIGNsaWVudC5jb25uZWN0KCkuY2F0Y2gobG9kYXNoXzEubm9vcCk7XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgICBjbGllbnQuZGVsYXlVbnRpbFJlYWR5KChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcoY2xpZW50LCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lLCBhcmdzLCBudWxsKS50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLy8gSWYgd2UgaGF2ZSBzbG90IGluZm9ybWF0aW9uLCB3ZSBjYW4gaW1wcm92ZSByb3V0aW5nIGJ5IGdyb3VwaW5nIHNsb3RzIHNlcnZlZCBieSB0aGUgc2FtZSBzdWJzZXQgb2Ygbm9kZXNcbiAgICAvLyBOb3RlIHRoYXQgdGhlIGZpcnN0IHZhbHVlIGluIGFyZ3MgbWF5IGJlIGEgKHBvc3NpYmx5IGVtcHR5KSBhcnJheS5cbiAgICAvLyBpb3JlZGlzIHdpbGwgb25seSBmbGF0dGVuIG9uZSBsZXZlbCBvZiB0aGUgYXJyYXksIGluIHRoZSBDb21tYW5kIGNvbnN0cnVjdG9yLlxuICAgIGNvbnN0IHByZWZpeCA9IGNsaWVudC5vcHRpb25zLmtleVByZWZpeCB8fCBcIlwiO1xuICAgIGNvbnN0IHNsb3RLZXkgPSBjbGllbnQuaXNDbHVzdGVyXG4gICAgICAgID8gY2xpZW50LnNsb3RzW2NhbGN1bGF0ZVNsb3QoYCR7cHJlZml4fSR7Z2V0Rmlyc3RWYWx1ZUluRmxhdHRlbmVkQXJyYXkoYXJncyl9YCldLmpvaW4oXCIsXCIpXG4gICAgICAgIDogXCJtYWluXCI7XG4gICAgaWYgKCFjbGllbnQuX2F1dG9QaXBlbGluZXMuaGFzKHNsb3RLZXkpKSB7XG4gICAgICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50LnBpcGVsaW5lKCk7XG4gICAgICAgIHBpcGVsaW5lW2V4cG9ydHMua0V4ZWNdID0gZmFsc2U7XG4gICAgICAgIHBpcGVsaW5lW2V4cG9ydHMua0NhbGxiYWNrc10gPSBbXTtcbiAgICAgICAgY2xpZW50Ll9hdXRvUGlwZWxpbmVzLnNldChzbG90S2V5LCBwaXBlbGluZSk7XG4gICAgfVxuICAgIGNvbnN0IHBpcGVsaW5lID0gY2xpZW50Ll9hdXRvUGlwZWxpbmVzLmdldChzbG90S2V5KTtcbiAgICAvKlxuICAgICAgTWFyayB0aGUgcGlwZWxpbmUgYXMgc2NoZWR1bGVkLlxuICAgICAgVGhlIHN5bWJvbCB3aWxsIG1ha2Ugc3VyZSB0aGF0IHRoZSBwaXBlbGluZSBpcyBvbmx5IHNjaGVkdWxlZCBvbmNlIHBlciB0aWNrLlxuICAgICAgTmV3IGNvbW1hbmRzIGFyZSBhcHBlbmRlZCB0byBhbiBhbHJlYWR5IHNjaGVkdWxlZCBwaXBlbGluZS5cbiAgICAqL1xuICAgIGlmICghcGlwZWxpbmVbZXhwb3J0cy5rRXhlY10pIHtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rRXhlY10gPSB0cnVlO1xuICAgICAgICAvKlxuICAgICAgICAgIERlZmVycmluZyB3aXRoIHNldEltbWVkaWF0ZSBzbyB3ZSBoYXZlIGEgY2hhbmNlIHRvIGNhcHR1cmUgbXVsdGlwbGVcbiAgICAgICAgICBjb21tYW5kcyB0aGF0IGNhbiBiZSBzY2hlZHVsZWQgYnkgSS9PIGV2ZW50cyBhbHJlYWR5IGluIHRoZSBldmVudCBsb29wIHF1ZXVlLlxuICAgICAgICAqL1xuICAgICAgICBzZXRJbW1lZGlhdGUoZXhlY3V0ZUF1dG9QaXBlbGluZSwgY2xpZW50LCBzbG90S2V5KTtcbiAgICB9XG4gICAgLy8gQ3JlYXRlIHRoZSBwcm9taXNlIHdoaWNoIHdpbGwgZXhlY3V0ZSB0aGUgY29tbWFuZCBpbiB0aGUgcGlwZWxpbmUuXG4gICAgY29uc3QgYXV0b1BpcGVsaW5lUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgcGlwZWxpbmVbZXhwb3J0cy5rQ2FsbGJhY2tzXS5wdXNoKGZ1bmN0aW9uIChlcnIsIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmVzb2x2ZSh2YWx1ZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoZnVuY3Rpb25OYW1lID09PSBcImNhbGxcIikge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KGNvbW1hbmROYW1lKTtcbiAgICAgICAgfVxuICAgICAgICBwaXBlbGluZVtmdW5jdGlvbk5hbWVdKC4uLmFyZ3MpO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShhdXRvUGlwZWxpbmVQcm9taXNlLCBjYWxsYmFjayk7XG59XG5leHBvcnRzLmV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcgPSBleGVjdXRlV2l0aEF1dG9QaXBlbGluaW5nO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/autoPipelining.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterOptions.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterOptions.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_CLUSTER_OPTIONS = void 0;\nconst dns_1 = __webpack_require__(/*! dns */ \"dns\");\nexports.DEFAULT_CLUSTER_OPTIONS = {\n    clusterRetryStrategy: (times) => Math.min(100 + times * 2, 2000),\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    scaleReads: \"master\",\n    maxRedirections: 16,\n    retryDelayOnMoved: 0,\n    retryDelayOnFailover: 100,\n    retryDelayOnClusterDown: 100,\n    retryDelayOnTryAgain: 100,\n    slotsRefreshTimeout: 1000,\n    useSRVRecords: false,\n    resolveSrv: dns_1.resolveSrv,\n    dnsLookup: dns_1.lookup,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    shardedSubscribers: false,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyT3B0aW9ucy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCwrQkFBK0I7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLCtCQUErQjtBQUMvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0NsdXN0ZXJPcHRpb25zLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5ERUZBVUxUX0NMVVNURVJfT1BUSU9OUyA9IHZvaWQgMDtcbmNvbnN0IGRuc18xID0gcmVxdWlyZShcImRuc1wiKTtcbmV4cG9ydHMuREVGQVVMVF9DTFVTVEVSX09QVElPTlMgPSB7XG4gICAgY2x1c3RlclJldHJ5U3RyYXRlZ3k6ICh0aW1lcykgPT4gTWF0aC5taW4oMTAwICsgdGltZXMgKiAyLCAyMDAwKSxcbiAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgZW5hYmxlUmVhZHlDaGVjazogdHJ1ZSxcbiAgICBzY2FsZVJlYWRzOiBcIm1hc3RlclwiLFxuICAgIG1heFJlZGlyZWN0aW9uczogMTYsXG4gICAgcmV0cnlEZWxheU9uTW92ZWQ6IDAsXG4gICAgcmV0cnlEZWxheU9uRmFpbG92ZXI6IDEwMCxcbiAgICByZXRyeURlbGF5T25DbHVzdGVyRG93bjogMTAwLFxuICAgIHJldHJ5RGVsYXlPblRyeUFnYWluOiAxMDAsXG4gICAgc2xvdHNSZWZyZXNoVGltZW91dDogMTAwMCxcbiAgICB1c2VTUlZSZWNvcmRzOiBmYWxzZSxcbiAgICByZXNvbHZlU3J2OiBkbnNfMS5yZXNvbHZlU3J2LFxuICAgIGRuc0xvb2t1cDogZG5zXzEubG9va3VwLFxuICAgIGVuYWJsZUF1dG9QaXBlbGluaW5nOiBmYWxzZSxcbiAgICBhdXRvUGlwZWxpbmluZ0lnbm9yZWRDb21tYW5kczogW10sXG4gICAgc2hhcmRlZFN1YnNjcmliZXJzOiBmYWxzZSxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterOptions.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriber.js":
/*!******************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriber.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriber\");\nclass ClusterSubscriber {\n    constructor(connectionPool, emitter, isSharded = false) {\n        this.connectionPool = connectionPool;\n        this.emitter = emitter;\n        this.isSharded = isSharded;\n        this.started = false;\n        //There is only one connection for the entire pool\n        this.subscriber = null;\n        //The slot range for which this subscriber is responsible\n        this.slotRange = [];\n        this.onSubscriberEnd = () => {\n            if (!this.started) {\n                debug(\"subscriber has disconnected, but ClusterSubscriber is not started, so not reconnecting.\");\n                return;\n            }\n            // If the subscriber closes whilst it's still the active connection,\n            // we might as well try to connecting to a new node if possible to\n            // minimise the number of missed publishes.\n            debug(\"subscriber has disconnected, selecting a new one...\");\n            this.selectSubscriber();\n        };\n        // If the current node we're using as the subscriber disappears\n        // from the node pool for some reason, we will select a new one\n        // to connect to.\n        // Note that this event is only triggered if the connection to\n        // the node has been used; cluster subscriptions are setup with\n        // lazyConnect = true. It's possible for the subscriber node to\n        // disappear without this method being called!\n        // See https://github.com/luin/ioredis/pull/1589\n        this.connectionPool.on(\"-node\", (_, key) => {\n            if (!this.started || !this.subscriber) {\n                return;\n            }\n            if ((0, util_1.getNodeKey)(this.subscriber.options) === key) {\n                debug(\"subscriber has left, selecting a new one...\");\n                this.selectSubscriber();\n            }\n        });\n        this.connectionPool.on(\"+node\", () => {\n            if (!this.started || this.subscriber) {\n                return;\n            }\n            debug(\"a new node is discovered and there is no subscriber, selecting a new one...\");\n            this.selectSubscriber();\n        });\n    }\n    getInstance() {\n        return this.subscriber;\n    }\n    /**\n     * Associate this subscriber to a specific slot range.\n     *\n     * Returns the range or an empty array if the slot range couldn't be associated.\n     *\n     * BTW: This is more for debugging and testing purposes.\n     *\n     * @param range\n     */\n    associateSlotRange(range) {\n        if (this.isSharded) {\n            this.slotRange = range;\n        }\n        return this.slotRange;\n    }\n    start() {\n        this.started = true;\n        this.selectSubscriber();\n        debug(\"started\");\n    }\n    stop() {\n        this.started = false;\n        if (this.subscriber) {\n            this.subscriber.disconnect();\n            this.subscriber = null;\n        }\n    }\n    isStarted() {\n        return this.started;\n    }\n    selectSubscriber() {\n        const lastActiveSubscriber = this.lastActiveSubscriber;\n        // Disconnect the previous subscriber even if there\n        // will not be a new one.\n        if (lastActiveSubscriber) {\n            lastActiveSubscriber.off(\"end\", this.onSubscriberEnd);\n            lastActiveSubscriber.disconnect();\n        }\n        if (this.subscriber) {\n            this.subscriber.off(\"end\", this.onSubscriberEnd);\n            this.subscriber.disconnect();\n        }\n        const sampleNode = (0, utils_1.sample)(this.connectionPool.getNodes());\n        if (!sampleNode) {\n            debug(\"selecting subscriber failed since there is no node discovered in the cluster yet\");\n            this.subscriber = null;\n            return;\n        }\n        const { options } = sampleNode;\n        debug(\"selected a subscriber %s:%s\", options.host, options.port);\n        /*\n         * Create a specialized Redis connection for the subscription.\n         * Note that auto reconnection is enabled here.\n         *\n         * `enableReadyCheck` is also enabled because although subscription is allowed\n         * while redis is loading data from the disk, we can check if the password\n         * provided for the subscriber is correct, and if not, the current subscriber\n         * will be disconnected and a new subscriber will be selected.\n         */\n        let connectionPrefix = \"subscriber\";\n        if (this.isSharded)\n            connectionPrefix = \"ssubscriber\";\n        this.subscriber = new Redis_1.default({\n            port: options.port,\n            host: options.host,\n            username: options.username,\n            password: options.password,\n            enableReadyCheck: true,\n            connectionName: (0, util_1.getConnectionName)(connectionPrefix, options.connectionName),\n            lazyConnect: true,\n            tls: options.tls,\n            // Don't try to reconnect the subscriber connection. If the connection fails\n            // we will get an end event (handled below), at which point we'll pick a new\n            // node from the pool and try to connect to that as the subscriber connection.\n            retryStrategy: null,\n        });\n        // Ignore the errors since they're handled in the connection pool.\n        this.subscriber.on(\"error\", utils_1.noop);\n        // The node we lost connection to may not come back up in a\n        // reasonable amount of time (e.g. a slave that's taken down\n        // for maintainence), we could potentially miss many published\n        // messages so we should reconnect as quickly as possible, to\n        // a different node if needed.\n        this.subscriber.once(\"end\", this.onSubscriberEnd);\n        // Re-subscribe previous channels\n        const previousChannels = { subscribe: [], psubscribe: [], ssubscribe: [] };\n        if (lastActiveSubscriber) {\n            const condition = lastActiveSubscriber.condition || lastActiveSubscriber.prevCondition;\n            if (condition && condition.subscriber) {\n                previousChannels.subscribe = condition.subscriber.channels(\"subscribe\");\n                previousChannels.psubscribe =\n                    condition.subscriber.channels(\"psubscribe\");\n                previousChannels.ssubscribe =\n                    condition.subscriber.channels(\"ssubscribe\");\n            }\n        }\n        if (previousChannels.subscribe.length ||\n            previousChannels.psubscribe.length ||\n            previousChannels.ssubscribe.length) {\n            let pending = 0;\n            for (const type of [\"subscribe\", \"psubscribe\", \"ssubscribe\"]) {\n                const channels = previousChannels[type];\n                if (channels.length) {\n                    pending += 1;\n                    debug(\"%s %d channels\", type, channels.length);\n                    this.subscriber[type](channels)\n                        .then(() => {\n                        if (!--pending) {\n                            this.lastActiveSubscriber = this.subscriber;\n                        }\n                    })\n                        .catch(() => {\n                        // TODO: should probably disconnect the subscriber and try again.\n                        debug(\"failed to %s %d channels\", type, channels.length);\n                    });\n                }\n            }\n        }\n        else {\n            this.lastActiveSubscriber = this.subscriber;\n        }\n        for (const event of [\n            \"message\",\n            \"messageBuffer\",\n        ]) {\n            this.subscriber.on(event, (arg1, arg2) => {\n                this.emitter.emit(event, arg1, arg2);\n            });\n        }\n        for (const event of [\"pmessage\", \"pmessageBuffer\"]) {\n            this.subscriber.on(event, (arg1, arg2, arg3) => {\n                this.emitter.emit(event, arg1, arg2, arg3);\n            });\n        }\n        if (this.isSharded == true) {\n            for (const event of [\n                \"smessage\",\n                \"smessageBuffer\",\n            ]) {\n                this.subscriber.on(event, (arg1, arg2) => {\n                    this.emitter.emit(event, arg1, arg2);\n                });\n            }\n        }\n    }\n}\nexports[\"default\"] = ClusterSubscriber;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyU3Vic2NyaWJlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxlQUFlLG1CQUFPLENBQUMsdUdBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyU3Vic2NyaWJlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgUmVkaXNfMSA9IHJlcXVpcmUoXCIuLi9SZWRpc1wiKTtcbmNvbnN0IGRlYnVnID0gKDAsIHV0aWxzXzEuRGVidWcpKFwiY2x1c3RlcjpzdWJzY3JpYmVyXCIpO1xuY2xhc3MgQ2x1c3RlclN1YnNjcmliZXIge1xuICAgIGNvbnN0cnVjdG9yKGNvbm5lY3Rpb25Qb29sLCBlbWl0dGVyLCBpc1NoYXJkZWQgPSBmYWxzZSkge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sID0gY29ubmVjdGlvblBvb2w7XG4gICAgICAgIHRoaXMuZW1pdHRlciA9IGVtaXR0ZXI7XG4gICAgICAgIHRoaXMuaXNTaGFyZGVkID0gaXNTaGFyZGVkO1xuICAgICAgICB0aGlzLnN0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgLy9UaGVyZSBpcyBvbmx5IG9uZSBjb25uZWN0aW9uIGZvciB0aGUgZW50aXJlIHBvb2xcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgLy9UaGUgc2xvdCByYW5nZSBmb3Igd2hpY2ggdGhpcyBzdWJzY3JpYmVyIGlzIHJlc3BvbnNpYmxlXG4gICAgICAgIHRoaXMuc2xvdFJhbmdlID0gW107XG4gICAgICAgIHRoaXMub25TdWJzY3JpYmVyRW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCF0aGlzLnN0YXJ0ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZXIgaGFzIGRpc2Nvbm5lY3RlZCwgYnV0IENsdXN0ZXJTdWJzY3JpYmVyIGlzIG5vdCBzdGFydGVkLCBzbyBub3QgcmVjb25uZWN0aW5nLlwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBJZiB0aGUgc3Vic2NyaWJlciBjbG9zZXMgd2hpbHN0IGl0J3Mgc3RpbGwgdGhlIGFjdGl2ZSBjb25uZWN0aW9uLFxuICAgICAgICAgICAgLy8gd2UgbWlnaHQgYXMgd2VsbCB0cnkgdG8gY29ubmVjdGluZyB0byBhIG5ldyBub2RlIGlmIHBvc3NpYmxlIHRvXG4gICAgICAgICAgICAvLyBtaW5pbWlzZSB0aGUgbnVtYmVyIG9mIG1pc3NlZCBwdWJsaXNoZXMuXG4gICAgICAgICAgICBkZWJ1ZyhcInN1YnNjcmliZXIgaGFzIGRpc2Nvbm5lY3RlZCwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICB9O1xuICAgICAgICAvLyBJZiB0aGUgY3VycmVudCBub2RlIHdlJ3JlIHVzaW5nIGFzIHRoZSBzdWJzY3JpYmVyIGRpc2FwcGVhcnNcbiAgICAgICAgLy8gZnJvbSB0aGUgbm9kZSBwb29sIGZvciBzb21lIHJlYXNvbiwgd2Ugd2lsbCBzZWxlY3QgYSBuZXcgb25lXG4gICAgICAgIC8vIHRvIGNvbm5lY3QgdG8uXG4gICAgICAgIC8vIE5vdGUgdGhhdCB0aGlzIGV2ZW50IGlzIG9ubHkgdHJpZ2dlcmVkIGlmIHRoZSBjb25uZWN0aW9uIHRvXG4gICAgICAgIC8vIHRoZSBub2RlIGhhcyBiZWVuIHVzZWQ7IGNsdXN0ZXIgc3Vic2NyaXB0aW9ucyBhcmUgc2V0dXAgd2l0aFxuICAgICAgICAvLyBsYXp5Q29ubmVjdCA9IHRydWUuIEl0J3MgcG9zc2libGUgZm9yIHRoZSBzdWJzY3JpYmVyIG5vZGUgdG9cbiAgICAgICAgLy8gZGlzYXBwZWFyIHdpdGhvdXQgdGhpcyBtZXRob2QgYmVpbmcgY2FsbGVkIVxuICAgICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2x1aW4vaW9yZWRpcy9wdWxsLzE1ODlcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIi1ub2RlXCIsIChfLCBrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghdGhpcy5zdGFydGVkIHx8ICF0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoKDAsIHV0aWxfMS5nZXROb2RlS2V5KSh0aGlzLnN1YnNjcmliZXIub3B0aW9ucykgPT09IGtleSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlciBoYXMgbGVmdCwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdFN1YnNjcmliZXIoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCIrbm9kZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBpZiAoIXRoaXMuc3RhcnRlZCB8fCB0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWJ1ZyhcImEgbmV3IG5vZGUgaXMgZGlzY292ZXJlZCBhbmQgdGhlcmUgaXMgbm8gc3Vic2NyaWJlciwgc2VsZWN0aW5nIGEgbmV3IG9uZS4uLlwiKTtcbiAgICAgICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZ2V0SW5zdGFuY2UoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN1YnNjcmliZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFzc29jaWF0ZSB0aGlzIHN1YnNjcmliZXIgdG8gYSBzcGVjaWZpYyBzbG90IHJhbmdlLlxuICAgICAqXG4gICAgICogUmV0dXJucyB0aGUgcmFuZ2Ugb3IgYW4gZW1wdHkgYXJyYXkgaWYgdGhlIHNsb3QgcmFuZ2UgY291bGRuJ3QgYmUgYXNzb2NpYXRlZC5cbiAgICAgKlxuICAgICAqIEJUVzogVGhpcyBpcyBtb3JlIGZvciBkZWJ1Z2dpbmcgYW5kIHRlc3RpbmcgcHVycG9zZXMuXG4gICAgICpcbiAgICAgKiBAcGFyYW0gcmFuZ2VcbiAgICAgKi9cbiAgICBhc3NvY2lhdGVTbG90UmFuZ2UocmFuZ2UpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNTaGFyZGVkKSB7XG4gICAgICAgICAgICB0aGlzLnNsb3RSYW5nZSA9IHJhbmdlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnNsb3RSYW5nZTtcbiAgICB9XG4gICAgc3RhcnQoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuc2VsZWN0U3Vic2NyaWJlcigpO1xuICAgICAgICBkZWJ1ZyhcInN0YXJ0ZWRcIik7XG4gICAgfVxuICAgIHN0b3AoKSB7XG4gICAgICAgIHRoaXMuc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH1cbiAgICBpc1N0YXJ0ZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXJ0ZWQ7XG4gICAgfVxuICAgIHNlbGVjdFN1YnNjcmliZXIoKSB7XG4gICAgICAgIGNvbnN0IGxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5sYXN0QWN0aXZlU3Vic2NyaWJlcjtcbiAgICAgICAgLy8gRGlzY29ubmVjdCB0aGUgcHJldmlvdXMgc3Vic2NyaWJlciBldmVuIGlmIHRoZXJlXG4gICAgICAgIC8vIHdpbGwgbm90IGJlIGEgbmV3IG9uZS5cbiAgICAgICAgaWYgKGxhc3RBY3RpdmVTdWJzY3JpYmVyKSB7XG4gICAgICAgICAgICBsYXN0QWN0aXZlU3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgbGFzdEFjdGl2ZVN1YnNjcmliZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vZmYoXCJlbmRcIiwgdGhpcy5vblN1YnNjcmliZXJFbmQpO1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzYW1wbGVOb2RlID0gKDAsIHV0aWxzXzEuc2FtcGxlKSh0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKCkpO1xuICAgICAgICBpZiAoIXNhbXBsZU5vZGUpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VsZWN0aW5nIHN1YnNjcmliZXIgZmFpbGVkIHNpbmNlIHRoZXJlIGlzIG5vIG5vZGUgZGlzY292ZXJlZCBpbiB0aGUgY2x1c3RlciB5ZXRcIik7XG4gICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIgPSBudWxsO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHsgb3B0aW9ucyB9ID0gc2FtcGxlTm9kZTtcbiAgICAgICAgZGVidWcoXCJzZWxlY3RlZCBhIHN1YnNjcmliZXIgJXM6JXNcIiwgb3B0aW9ucy5ob3N0LCBvcHRpb25zLnBvcnQpO1xuICAgICAgICAvKlxuICAgICAgICAgKiBDcmVhdGUgYSBzcGVjaWFsaXplZCBSZWRpcyBjb25uZWN0aW9uIGZvciB0aGUgc3Vic2NyaXB0aW9uLlxuICAgICAgICAgKiBOb3RlIHRoYXQgYXV0byByZWNvbm5lY3Rpb24gaXMgZW5hYmxlZCBoZXJlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBgZW5hYmxlUmVhZHlDaGVja2AgaXMgYWxzbyBlbmFibGVkIGJlY2F1c2UgYWx0aG91Z2ggc3Vic2NyaXB0aW9uIGlzIGFsbG93ZWRcbiAgICAgICAgICogd2hpbGUgcmVkaXMgaXMgbG9hZGluZyBkYXRhIGZyb20gdGhlIGRpc2ssIHdlIGNhbiBjaGVjayBpZiB0aGUgcGFzc3dvcmRcbiAgICAgICAgICogcHJvdmlkZWQgZm9yIHRoZSBzdWJzY3JpYmVyIGlzIGNvcnJlY3QsIGFuZCBpZiBub3QsIHRoZSBjdXJyZW50IHN1YnNjcmliZXJcbiAgICAgICAgICogd2lsbCBiZSBkaXNjb25uZWN0ZWQgYW5kIGEgbmV3IHN1YnNjcmliZXIgd2lsbCBiZSBzZWxlY3RlZC5cbiAgICAgICAgICovXG4gICAgICAgIGxldCBjb25uZWN0aW9uUHJlZml4ID0gXCJzdWJzY3JpYmVyXCI7XG4gICAgICAgIGlmICh0aGlzLmlzU2hhcmRlZClcbiAgICAgICAgICAgIGNvbm5lY3Rpb25QcmVmaXggPSBcInNzdWJzY3JpYmVyXCI7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBSZWRpc18xLmRlZmF1bHQoe1xuICAgICAgICAgICAgcG9ydDogb3B0aW9ucy5wb3J0LFxuICAgICAgICAgICAgaG9zdDogb3B0aW9ucy5ob3N0LFxuICAgICAgICAgICAgdXNlcm5hbWU6IG9wdGlvbnMudXNlcm5hbWUsXG4gICAgICAgICAgICBwYXNzd29yZDogb3B0aW9ucy5wYXNzd29yZCxcbiAgICAgICAgICAgIGVuYWJsZVJlYWR5Q2hlY2s6IHRydWUsXG4gICAgICAgICAgICBjb25uZWN0aW9uTmFtZTogKDAsIHV0aWxfMS5nZXRDb25uZWN0aW9uTmFtZSkoY29ubmVjdGlvblByZWZpeCwgb3B0aW9ucy5jb25uZWN0aW9uTmFtZSksXG4gICAgICAgICAgICBsYXp5Q29ubmVjdDogdHJ1ZSxcbiAgICAgICAgICAgIHRsczogb3B0aW9ucy50bHMsXG4gICAgICAgICAgICAvLyBEb24ndCB0cnkgdG8gcmVjb25uZWN0IHRoZSBzdWJzY3JpYmVyIGNvbm5lY3Rpb24uIElmIHRoZSBjb25uZWN0aW9uIGZhaWxzXG4gICAgICAgICAgICAvLyB3ZSB3aWxsIGdldCBhbiBlbmQgZXZlbnQgKGhhbmRsZWQgYmVsb3cpLCBhdCB3aGljaCBwb2ludCB3ZSdsbCBwaWNrIGEgbmV3XG4gICAgICAgICAgICAvLyBub2RlIGZyb20gdGhlIHBvb2wgYW5kIHRyeSB0byBjb25uZWN0IHRvIHRoYXQgYXMgdGhlIHN1YnNjcmliZXIgY29ubmVjdGlvbi5cbiAgICAgICAgICAgIHJldHJ5U3RyYXRlZ3k6IG51bGwsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9ycyBzaW5jZSB0aGV5J3JlIGhhbmRsZWQgaW4gdGhlIGNvbm5lY3Rpb24gcG9vbC5cbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKFwiZXJyb3JcIiwgdXRpbHNfMS5ub29wKTtcbiAgICAgICAgLy8gVGhlIG5vZGUgd2UgbG9zdCBjb25uZWN0aW9uIHRvIG1heSBub3QgY29tZSBiYWNrIHVwIGluIGFcbiAgICAgICAgLy8gcmVhc29uYWJsZSBhbW91bnQgb2YgdGltZSAoZS5nLiBhIHNsYXZlIHRoYXQncyB0YWtlbiBkb3duXG4gICAgICAgIC8vIGZvciBtYWludGFpbmVuY2UpLCB3ZSBjb3VsZCBwb3RlbnRpYWxseSBtaXNzIG1hbnkgcHVibGlzaGVkXG4gICAgICAgIC8vIG1lc3NhZ2VzIHNvIHdlIHNob3VsZCByZWNvbm5lY3QgYXMgcXVpY2tseSBhcyBwb3NzaWJsZSwgdG9cbiAgICAgICAgLy8gYSBkaWZmZXJlbnQgbm9kZSBpZiBuZWVkZWQuXG4gICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbmNlKFwiZW5kXCIsIHRoaXMub25TdWJzY3JpYmVyRW5kKTtcbiAgICAgICAgLy8gUmUtc3Vic2NyaWJlIHByZXZpb3VzIGNoYW5uZWxzXG4gICAgICAgIGNvbnN0IHByZXZpb3VzQ2hhbm5lbHMgPSB7IHN1YnNjcmliZTogW10sIHBzdWJzY3JpYmU6IFtdLCBzc3Vic2NyaWJlOiBbXSB9O1xuICAgICAgICBpZiAobGFzdEFjdGl2ZVN1YnNjcmliZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IGxhc3RBY3RpdmVTdWJzY3JpYmVyLmNvbmRpdGlvbiB8fCBsYXN0QWN0aXZlU3Vic2NyaWJlci5wcmV2Q29uZGl0aW9uO1xuICAgICAgICAgICAgaWYgKGNvbmRpdGlvbiAmJiBjb25kaXRpb24uc3Vic2NyaWJlcikge1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMuc3Vic2NyaWJlID0gY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJzdWJzY3JpYmVcIik7XG4gICAgICAgICAgICAgICAgcHJldmlvdXNDaGFubmVscy5wc3Vic2NyaWJlID1cbiAgICAgICAgICAgICAgICAgICAgY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIHByZXZpb3VzQ2hhbm5lbHMuc3N1YnNjcmliZSA9XG4gICAgICAgICAgICAgICAgICAgIGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3N1YnNjcmliZVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldmlvdXNDaGFubmVscy5zdWJzY3JpYmUubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnBzdWJzY3JpYmUubGVuZ3RoIHx8XG4gICAgICAgICAgICBwcmV2aW91c0NoYW5uZWxzLnNzdWJzY3JpYmUubGVuZ3RoKSB7XG4gICAgICAgICAgICBsZXQgcGVuZGluZyA9IDA7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHR5cGUgb2YgW1wic3Vic2NyaWJlXCIsIFwicHN1YnNjcmliZVwiLCBcInNzdWJzY3JpYmVcIl0pIHtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHByZXZpb3VzQ2hhbm5lbHNbdHlwZV07XG4gICAgICAgICAgICAgICAgaWYgKGNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBwZW5kaW5nICs9IDE7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiJXMgJWQgY2hhbm5lbHNcIiwgdHlwZSwgY2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyW3R5cGVdKGNoYW5uZWxzKVxuICAgICAgICAgICAgICAgICAgICAgICAgLnRoZW4oKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEtLXBlbmRpbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIFRPRE86IHNob3VsZCBwcm9iYWJseSBkaXNjb25uZWN0IHRoZSBzdWJzY3JpYmVyIGFuZCB0cnkgYWdhaW4uXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImZhaWxlZCB0byAlcyAlZCBjaGFubmVsc1wiLCB0eXBlLCBjaGFubmVscy5sZW5ndGgpO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmxhc3RBY3RpdmVTdWJzY3JpYmVyID0gdGhpcy5zdWJzY3JpYmVyO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1xuICAgICAgICAgICAgXCJtZXNzYWdlXCIsXG4gICAgICAgICAgICBcIm1lc3NhZ2VCdWZmZXJcIixcbiAgICAgICAgXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKGV2ZW50LCAoYXJnMSwgYXJnMikgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2YgW1wicG1lc3NhZ2VcIiwgXCJwbWVzc2FnZUJ1ZmZlclwiXSkge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyLm9uKGV2ZW50LCAoYXJnMSwgYXJnMiwgYXJnMykgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KGV2ZW50LCBhcmcxLCBhcmcyLCBhcmczKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzU2hhcmRlZCA9PSB0cnVlKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGV2ZW50IG9mIFtcbiAgICAgICAgICAgICAgICBcInNtZXNzYWdlXCIsXG4gICAgICAgICAgICAgICAgXCJzbWVzc2FnZUJ1ZmZlclwiLFxuICAgICAgICAgICAgXSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlci5vbihldmVudCwgKGFyZzEsIGFyZzIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyLmVtaXQoZXZlbnQsIGFyZzEsIGFyZzIpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlclN1YnNjcmliZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriber.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst ClusterSubscriber_1 = __webpack_require__(/*! ./ClusterSubscriber */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriber.js\");\nconst ConnectionPool_1 = __webpack_require__(/*! ./ConnectionPool */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ConnectionPool.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js\");\nconst calculateSlot = __webpack_require__(/*! cluster-key-slot */ \"(rsc)/../../node_modules/.pnpm/cluster-key-slot@1.1.2/node_modules/cluster-key-slot/lib/index.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:subscriberGroup\");\n/**\n * Redis differs between \"normal\" and sharded PubSub. If using the \"normal\" PubSub feature, exactly one\n * ClusterSubscriber exists per cluster instance. This works because the Redis cluster bus forwards m\n * messages between shards. However, this has scalability limitations, which is the reason why the sharded\n * PubSub feature was added to Redis. With sharded PubSub, each shard is responsible for its own messages.\n * Given that, we need at least one ClusterSubscriber per master endpoint/node.\n *\n * This class leverages the previously exising ClusterSubscriber by adding support for multiple such subscribers\n * in alignment to the master nodes of the cluster. The ClusterSubscriber class was extended in a non-breaking way\n * to support this feature.\n */\nclass ClusterSubscriberGroup {\n    /**\n     * Register callbacks\n     *\n     * @param cluster\n     */\n    constructor(cluster) {\n        this.cluster = cluster;\n        this.shardedSubscribers = new Map();\n        this.clusterSlots = [];\n        //Simple [min, max] slot ranges aren't enough because you can migrate single slots\n        this.subscriberToSlotsIndex = new Map();\n        this.channels = new Map();\n        cluster.on(\"+node\", (redis) => {\n            this._addSubscriber(redis);\n        });\n        cluster.on(\"-node\", (redis) => {\n            this._removeSubscriber(redis);\n        });\n        cluster.on(\"refresh\", () => {\n            this._refreshSlots(cluster);\n        });\n    }\n    /**\n     * Get the responsible subscriber.\n     *\n     * Returns null if no subscriber was found\n     *\n     * @param slot\n     */\n    getResponsibleSubscriber(slot) {\n        const nodeKey = this.clusterSlots[slot][0];\n        return this.shardedSubscribers.get(nodeKey);\n    }\n    /**\n     * Adds a channel for which this subscriber group is responsible\n     *\n     * @param channels\n     */\n    addChannels(channels) {\n        const slot = calculateSlot(channels[0]);\n        //Check if the all channels belong to the same slot and otherwise reject the operation\n        channels.forEach((c) => {\n            if (calculateSlot(c) != slot)\n                return -1;\n        });\n        const currChannels = this.channels.get(slot);\n        if (!currChannels) {\n            this.channels.set(slot, channels);\n        }\n        else {\n            this.channels.set(slot, currChannels.concat(channels));\n        }\n        return [...this.channels.values()].flatMap(v => v).length;\n    }\n    /**\n     * Removes channels for which the subscriber group is responsible by optionally unsubscribing\n     * @param channels\n     */\n    removeChannels(channels) {\n        const slot = calculateSlot(channels[0]);\n        //Check if the all channels belong to the same slot and otherwise reject the operation\n        channels.forEach((c) => {\n            if (calculateSlot(c) != slot)\n                return -1;\n        });\n        const slotChannels = this.channels.get(slot);\n        if (slotChannels) {\n            const updatedChannels = slotChannels.filter(c => !channels.includes(c));\n            this.channels.set(slot, updatedChannels);\n        }\n        return [...this.channels.values()].flatMap(v => v).length;\n    }\n    /**\n     * Disconnect all subscribers\n     */\n    stop() {\n        for (const s of this.shardedSubscribers.values()) {\n            s.stop();\n        }\n    }\n    /**\n     * Start all not yet started subscribers\n     */\n    start() {\n        for (const s of this.shardedSubscribers.values()) {\n            if (!s.isStarted()) {\n                s.start();\n            }\n        }\n    }\n    /**\n     * Add a subscriber to the group of subscribers\n     *\n     * @param redis\n     */\n    _addSubscriber(redis) {\n        const pool = new ConnectionPool_1.default(redis.options);\n        if (pool.addMasterNode(redis)) {\n            const sub = new ClusterSubscriber_1.default(pool, this.cluster, true);\n            const nodeKey = (0, util_1.getNodeKey)(redis.options);\n            this.shardedSubscribers.set(nodeKey, sub);\n            sub.start();\n            // We need to attempt to resubscribe them in case the new node serves their slot\n            this._resubscribe();\n            this.cluster.emit(\"+subscriber\");\n            return sub;\n        }\n        return null;\n    }\n    /**\n     * Removes a subscriber from the group\n     * @param redis\n     */\n    _removeSubscriber(redis) {\n        const nodeKey = (0, util_1.getNodeKey)(redis.options);\n        const sub = this.shardedSubscribers.get(nodeKey);\n        if (sub) {\n            sub.stop();\n            this.shardedSubscribers.delete(nodeKey);\n            // Even though the subscriber to this node is going down, we might have another subscriber\n            // handling the same slots, so we need to attempt to subscribe the orphaned channels\n            this._resubscribe();\n            this.cluster.emit(\"-subscriber\");\n        }\n        return this.shardedSubscribers;\n    }\n    /**\n     * Refreshes the subscriber-related slot ranges\n     *\n     * Returns false if no refresh was needed\n     *\n     * @param cluster\n     */\n    _refreshSlots(cluster) {\n        //If there was an actual change, then reassign the slot ranges\n        if (this._slotsAreEqual(cluster.slots)) {\n            debug(\"Nothing to refresh because the new cluster map is equal to the previous one.\");\n        }\n        else {\n            debug(\"Refreshing the slots of the subscriber group.\");\n            //Rebuild the slots index\n            this.subscriberToSlotsIndex = new Map();\n            for (let slot = 0; slot < cluster.slots.length; slot++) {\n                const node = cluster.slots[slot][0];\n                if (!this.subscriberToSlotsIndex.has(node)) {\n                    this.subscriberToSlotsIndex.set(node, []);\n                }\n                this.subscriberToSlotsIndex.get(node).push(Number(slot));\n            }\n            //Update the subscribers from the index\n            this._resubscribe();\n            //Update the cached slots map\n            this.clusterSlots = JSON.parse(JSON.stringify(cluster.slots));\n            this.cluster.emit(\"subscribersReady\");\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Resubscribes to the previous channels\n     *\n     * @private\n     */\n    _resubscribe() {\n        if (this.shardedSubscribers) {\n            this.shardedSubscribers.forEach((s, nodeKey) => {\n                const subscriberSlots = this.subscriberToSlotsIndex.get(nodeKey);\n                if (subscriberSlots) {\n                    //More for debugging purposes\n                    s.associateSlotRange(subscriberSlots);\n                    //Resubscribe on the underlying connection\n                    subscriberSlots.forEach((ss) => {\n                        //Might return null if being disconnected\n                        const redis = s.getInstance();\n                        const channels = this.channels.get(ss);\n                        if (channels && channels.length > 0) {\n                            //Try to subscribe now\n                            if (redis) {\n                                redis.ssubscribe(channels);\n                                //If the instance isn't ready yet, then register the re-subscription for later\n                                redis.on(\"ready\", () => {\n                                    redis.ssubscribe(channels);\n                                });\n                            }\n                        }\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Deep equality of the cluster slots objects\n     *\n     * @param other\n     * @private\n     */\n    _slotsAreEqual(other) {\n        if (this.clusterSlots === undefined)\n            return false;\n        else\n            return JSON.stringify(this.clusterSlots) === JSON.stringify(other);\n    }\n}\nexports[\"default\"] = ClusterSubscriberGroup;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9DbHVzdGVyU3Vic2NyaWJlckdyb3VwLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHdHQUFVO0FBQ2xDLDRCQUE0QixtQkFBTyxDQUFDLGlJQUFxQjtBQUN6RCx5QkFBeUIsbUJBQU8sQ0FBQywySEFBa0I7QUFDbkQsZUFBZSxtQkFBTyxDQUFDLHVHQUFRO0FBQy9CLHNCQUFzQixtQkFBTyxDQUFDLDBIQUFrQjtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NsdXN0ZXIvQ2x1c3RlclN1YnNjcmliZXJHcm91cC5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBDbHVzdGVyU3Vic2NyaWJlcl8xID0gcmVxdWlyZShcIi4vQ2x1c3RlclN1YnNjcmliZXJcIik7XG5jb25zdCBDb25uZWN0aW9uUG9vbF8xID0gcmVxdWlyZShcIi4vQ29ubmVjdGlvblBvb2xcIik7XG5jb25zdCB1dGlsXzEgPSByZXF1aXJlKFwiLi91dGlsXCIpO1xuY29uc3QgY2FsY3VsYXRlU2xvdCA9IHJlcXVpcmUoXCJjbHVzdGVyLWtleS1zbG90XCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyOnN1YnNjcmliZXJHcm91cFwiKTtcbi8qKlxuICogUmVkaXMgZGlmZmVycyBiZXR3ZWVuIFwibm9ybWFsXCIgYW5kIHNoYXJkZWQgUHViU3ViLiBJZiB1c2luZyB0aGUgXCJub3JtYWxcIiBQdWJTdWIgZmVhdHVyZSwgZXhhY3RseSBvbmVcbiAqIENsdXN0ZXJTdWJzY3JpYmVyIGV4aXN0cyBwZXIgY2x1c3RlciBpbnN0YW5jZS4gVGhpcyB3b3JrcyBiZWNhdXNlIHRoZSBSZWRpcyBjbHVzdGVyIGJ1cyBmb3J3YXJkcyBtXG4gKiBtZXNzYWdlcyBiZXR3ZWVuIHNoYXJkcy4gSG93ZXZlciwgdGhpcyBoYXMgc2NhbGFiaWxpdHkgbGltaXRhdGlvbnMsIHdoaWNoIGlzIHRoZSByZWFzb24gd2h5IHRoZSBzaGFyZGVkXG4gKiBQdWJTdWIgZmVhdHVyZSB3YXMgYWRkZWQgdG8gUmVkaXMuIFdpdGggc2hhcmRlZCBQdWJTdWIsIGVhY2ggc2hhcmQgaXMgcmVzcG9uc2libGUgZm9yIGl0cyBvd24gbWVzc2FnZXMuXG4gKiBHaXZlbiB0aGF0LCB3ZSBuZWVkIGF0IGxlYXN0IG9uZSBDbHVzdGVyU3Vic2NyaWJlciBwZXIgbWFzdGVyIGVuZHBvaW50L25vZGUuXG4gKlxuICogVGhpcyBjbGFzcyBsZXZlcmFnZXMgdGhlIHByZXZpb3VzbHkgZXhpc2luZyBDbHVzdGVyU3Vic2NyaWJlciBieSBhZGRpbmcgc3VwcG9ydCBmb3IgbXVsdGlwbGUgc3VjaCBzdWJzY3JpYmVyc1xuICogaW4gYWxpZ25tZW50IHRvIHRoZSBtYXN0ZXIgbm9kZXMgb2YgdGhlIGNsdXN0ZXIuIFRoZSBDbHVzdGVyU3Vic2NyaWJlciBjbGFzcyB3YXMgZXh0ZW5kZWQgaW4gYSBub24tYnJlYWtpbmcgd2F5XG4gKiB0byBzdXBwb3J0IHRoaXMgZmVhdHVyZS5cbiAqL1xuY2xhc3MgQ2x1c3RlclN1YnNjcmliZXJHcm91cCB7XG4gICAgLyoqXG4gICAgICogUmVnaXN0ZXIgY2FsbGJhY2tzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gY2x1c3RlclxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKGNsdXN0ZXIpIHtcbiAgICAgICAgdGhpcy5jbHVzdGVyID0gY2x1c3RlcjtcbiAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuY2x1c3RlclNsb3RzID0gW107XG4gICAgICAgIC8vU2ltcGxlIFttaW4sIG1heF0gc2xvdCByYW5nZXMgYXJlbid0IGVub3VnaCBiZWNhdXNlIHlvdSBjYW4gbWlncmF0ZSBzaW5nbGUgc2xvdHNcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IE1hcCgpO1xuICAgICAgICBjbHVzdGVyLm9uKFwiK25vZGVcIiwgKHJlZGlzKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hZGRTdWJzY3JpYmVyKHJlZGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNsdXN0ZXIub24oXCItbm9kZVwiLCAocmVkaXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW92ZVN1YnNjcmliZXIocmVkaXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2x1c3Rlci5vbihcInJlZnJlc2hcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFNsb3RzKGNsdXN0ZXIpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSByZXNwb25zaWJsZSBzdWJzY3JpYmVyLlxuICAgICAqXG4gICAgICogUmV0dXJucyBudWxsIGlmIG5vIHN1YnNjcmliZXIgd2FzIGZvdW5kXG4gICAgICpcbiAgICAgKiBAcGFyYW0gc2xvdFxuICAgICAqL1xuICAgIGdldFJlc3BvbnNpYmxlU3Vic2NyaWJlcihzbG90KSB7XG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSB0aGlzLmNsdXN0ZXJTbG90c1tzbG90XVswXTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmdldChub2RlS2V5KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQWRkcyBhIGNoYW5uZWwgZm9yIHdoaWNoIHRoaXMgc3Vic2NyaWJlciBncm91cCBpcyByZXNwb25zaWJsZVxuICAgICAqXG4gICAgICogQHBhcmFtIGNoYW5uZWxzXG4gICAgICovXG4gICAgYWRkQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGNhbGN1bGF0ZVNsb3QoY2hhbm5lbHNbMF0pO1xuICAgICAgICAvL0NoZWNrIGlmIHRoZSBhbGwgY2hhbm5lbHMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3QgYW5kIG90aGVyd2lzZSByZWplY3QgdGhlIG9wZXJhdGlvblxuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlU2xvdChjKSAhPSBzbG90KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJDaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNsb3QpO1xuICAgICAgICBpZiAoIWN1cnJDaGFubmVscykge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5zZXQoc2xvdCwgY2hhbm5lbHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jaGFubmVscy5zZXQoc2xvdCwgY3VyckNoYW5uZWxzLmNvbmNhdChjaGFubmVscykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBbLi4udGhpcy5jaGFubmVscy52YWx1ZXMoKV0uZmxhdE1hcCh2ID0+IHYpLmxlbmd0aDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVtb3ZlcyBjaGFubmVscyBmb3Igd2hpY2ggdGhlIHN1YnNjcmliZXIgZ3JvdXAgaXMgcmVzcG9uc2libGUgYnkgb3B0aW9uYWxseSB1bnN1YnNjcmliaW5nXG4gICAgICogQHBhcmFtIGNoYW5uZWxzXG4gICAgICovXG4gICAgcmVtb3ZlQ2hhbm5lbHMoY2hhbm5lbHMpIHtcbiAgICAgICAgY29uc3Qgc2xvdCA9IGNhbGN1bGF0ZVNsb3QoY2hhbm5lbHNbMF0pO1xuICAgICAgICAvL0NoZWNrIGlmIHRoZSBhbGwgY2hhbm5lbHMgYmVsb25nIHRvIHRoZSBzYW1lIHNsb3QgYW5kIG90aGVyd2lzZSByZWplY3QgdGhlIG9wZXJhdGlvblxuICAgICAgICBjaGFubmVscy5mb3JFYWNoKChjKSA9PiB7XG4gICAgICAgICAgICBpZiAoY2FsY3VsYXRlU2xvdChjKSAhPSBzbG90KVxuICAgICAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHNsb3RDaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNsb3QpO1xuICAgICAgICBpZiAoc2xvdENoYW5uZWxzKSB7XG4gICAgICAgICAgICBjb25zdCB1cGRhdGVkQ2hhbm5lbHMgPSBzbG90Q2hhbm5lbHMuZmlsdGVyKGMgPT4gIWNoYW5uZWxzLmluY2x1ZGVzKGMpKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbHMuc2V0KHNsb3QsIHVwZGF0ZWRDaGFubmVscyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFsuLi50aGlzLmNoYW5uZWxzLnZhbHVlcygpXS5mbGF0TWFwKHYgPT4gdikubGVuZ3RoO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEaXNjb25uZWN0IGFsbCBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIHN0b3AoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcyBvZiB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgcy5zdG9wKCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogU3RhcnQgYWxsIG5vdCB5ZXQgc3RhcnRlZCBzdWJzY3JpYmVyc1xuICAgICAqL1xuICAgIHN0YXJ0KCkge1xuICAgICAgICBmb3IgKGNvbnN0IHMgb2YgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIGlmICghcy5pc1N0YXJ0ZWQoKSkge1xuICAgICAgICAgICAgICAgIHMuc3RhcnQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBzdWJzY3JpYmVyIHRvIHRoZSBncm91cCBvZiBzdWJzY3JpYmVyc1xuICAgICAqXG4gICAgICogQHBhcmFtIHJlZGlzXG4gICAgICovXG4gICAgX2FkZFN1YnNjcmliZXIocmVkaXMpIHtcbiAgICAgICAgY29uc3QgcG9vbCA9IG5ldyBDb25uZWN0aW9uUG9vbF8xLmRlZmF1bHQocmVkaXMub3B0aW9ucyk7XG4gICAgICAgIGlmIChwb29sLmFkZE1hc3Rlck5vZGUocmVkaXMpKSB7XG4gICAgICAgICAgICBjb25zdCBzdWIgPSBuZXcgQ2x1c3RlclN1YnNjcmliZXJfMS5kZWZhdWx0KHBvb2wsIHRoaXMuY2x1c3RlciwgdHJ1ZSk7XG4gICAgICAgICAgICBjb25zdCBub2RlS2V5ID0gKDAsIHV0aWxfMS5nZXROb2RlS2V5KShyZWRpcy5vcHRpb25zKTtcbiAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnNldChub2RlS2V5LCBzdWIpO1xuICAgICAgICAgICAgc3ViLnN0YXJ0KCk7XG4gICAgICAgICAgICAvLyBXZSBuZWVkIHRvIGF0dGVtcHQgdG8gcmVzdWJzY3JpYmUgdGhlbSBpbiBjYXNlIHRoZSBuZXcgbm9kZSBzZXJ2ZXMgdGhlaXIgc2xvdFxuICAgICAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlci5lbWl0KFwiK3N1YnNjcmliZXJcIik7XG4gICAgICAgICAgICByZXR1cm4gc3ViO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmVzIGEgc3Vic2NyaWJlciBmcm9tIHRoZSBncm91cFxuICAgICAqIEBwYXJhbSByZWRpc1xuICAgICAqL1xuICAgIF9yZW1vdmVTdWJzY3JpYmVyKHJlZGlzKSB7XG4gICAgICAgIGNvbnN0IG5vZGVLZXkgPSAoMCwgdXRpbF8xLmdldE5vZGVLZXkpKHJlZGlzLm9wdGlvbnMpO1xuICAgICAgICBjb25zdCBzdWIgPSB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5nZXQobm9kZUtleSk7XG4gICAgICAgIGlmIChzdWIpIHtcbiAgICAgICAgICAgIHN1Yi5zdG9wKCk7XG4gICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5kZWxldGUobm9kZUtleSk7XG4gICAgICAgICAgICAvLyBFdmVuIHRob3VnaCB0aGUgc3Vic2NyaWJlciB0byB0aGlzIG5vZGUgaXMgZ29pbmcgZG93biwgd2UgbWlnaHQgaGF2ZSBhbm90aGVyIHN1YnNjcmliZXJcbiAgICAgICAgICAgIC8vIGhhbmRsaW5nIHRoZSBzYW1lIHNsb3RzLCBzbyB3ZSBuZWVkIHRvIGF0dGVtcHQgdG8gc3Vic2NyaWJlIHRoZSBvcnBoYW5lZCBjaGFubmVsc1xuICAgICAgICAgICAgdGhpcy5fcmVzdWJzY3JpYmUoKTtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlci5lbWl0KFwiLXN1YnNjcmliZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZWZyZXNoZXMgdGhlIHN1YnNjcmliZXItcmVsYXRlZCBzbG90IHJhbmdlc1xuICAgICAqXG4gICAgICogUmV0dXJucyBmYWxzZSBpZiBubyByZWZyZXNoIHdhcyBuZWVkZWRcbiAgICAgKlxuICAgICAqIEBwYXJhbSBjbHVzdGVyXG4gICAgICovXG4gICAgX3JlZnJlc2hTbG90cyhjbHVzdGVyKSB7XG4gICAgICAgIC8vSWYgdGhlcmUgd2FzIGFuIGFjdHVhbCBjaGFuZ2UsIHRoZW4gcmVhc3NpZ24gdGhlIHNsb3QgcmFuZ2VzXG4gICAgICAgIGlmICh0aGlzLl9zbG90c0FyZUVxdWFsKGNsdXN0ZXIuc2xvdHMpKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIk5vdGhpbmcgdG8gcmVmcmVzaCBiZWNhdXNlIHRoZSBuZXcgY2x1c3RlciBtYXAgaXMgZXF1YWwgdG8gdGhlIHByZXZpb3VzIG9uZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlJlZnJlc2hpbmcgdGhlIHNsb3RzIG9mIHRoZSBzdWJzY3JpYmVyIGdyb3VwLlwiKTtcbiAgICAgICAgICAgIC8vUmVidWlsZCB0aGUgc2xvdHMgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaWJlclRvU2xvdHNJbmRleCA9IG5ldyBNYXAoKTtcbiAgICAgICAgICAgIGZvciAobGV0IHNsb3QgPSAwOyBzbG90IDwgY2x1c3Rlci5zbG90cy5sZW5ndGg7IHNsb3QrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBjbHVzdGVyLnNsb3RzW3Nsb3RdWzBdO1xuICAgICAgICAgICAgICAgIGlmICghdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4Lmhhcyhub2RlKSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXJUb1Nsb3RzSW5kZXguc2V0KG5vZGUsIFtdKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5zdWJzY3JpYmVyVG9TbG90c0luZGV4LmdldChub2RlKS5wdXNoKE51bWJlcihzbG90KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvL1VwZGF0ZSB0aGUgc3Vic2NyaWJlcnMgZnJvbSB0aGUgaW5kZXhcbiAgICAgICAgICAgIHRoaXMuX3Jlc3Vic2NyaWJlKCk7XG4gICAgICAgICAgICAvL1VwZGF0ZSB0aGUgY2FjaGVkIHNsb3RzIG1hcFxuICAgICAgICAgICAgdGhpcy5jbHVzdGVyU2xvdHMgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KGNsdXN0ZXIuc2xvdHMpKTtcbiAgICAgICAgICAgIHRoaXMuY2x1c3Rlci5lbWl0KFwic3Vic2NyaWJlcnNSZWFkeVwiKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdWJzY3JpYmVzIHRvIHRoZSBwcmV2aW91cyBjaGFubmVsc1xuICAgICAqXG4gICAgICogQHByaXZhdGVcbiAgICAgKi9cbiAgICBfcmVzdWJzY3JpYmUoKSB7XG4gICAgICAgIGlmICh0aGlzLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMuZm9yRWFjaCgocywgbm9kZUtleSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IHN1YnNjcmliZXJTbG90cyA9IHRoaXMuc3Vic2NyaWJlclRvU2xvdHNJbmRleC5nZXQobm9kZUtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHN1YnNjcmliZXJTbG90cykge1xuICAgICAgICAgICAgICAgICAgICAvL01vcmUgZm9yIGRlYnVnZ2luZyBwdXJwb3Nlc1xuICAgICAgICAgICAgICAgICAgICBzLmFzc29jaWF0ZVNsb3RSYW5nZShzdWJzY3JpYmVyU2xvdHMpO1xuICAgICAgICAgICAgICAgICAgICAvL1Jlc3Vic2NyaWJlIG9uIHRoZSB1bmRlcmx5aW5nIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgc3Vic2NyaWJlclNsb3RzLmZvckVhY2goKHNzKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvL01pZ2h0IHJldHVybiBudWxsIGlmIGJlaW5nIGRpc2Nvbm5lY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVkaXMgPSBzLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBjaGFubmVscyA9IHRoaXMuY2hhbm5lbHMuZ2V0KHNzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjaGFubmVscyAmJiBjaGFubmVscy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9UcnkgdG8gc3Vic2NyaWJlIG5vd1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWRpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcy5zc3Vic2NyaWJlKGNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy9JZiB0aGUgaW5zdGFuY2UgaXNuJ3QgcmVhZHkgeWV0LCB0aGVuIHJlZ2lzdGVyIHRoZSByZS1zdWJzY3JpcHRpb24gZm9yIGxhdGVyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZGlzLm9uKFwicmVhZHlcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMuc3N1YnNjcmliZShjaGFubmVscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVlcCBlcXVhbGl0eSBvZiB0aGUgY2x1c3RlciBzbG90cyBvYmplY3RzXG4gICAgICpcbiAgICAgKiBAcGFyYW0gb3RoZXJcbiAgICAgKiBAcHJpdmF0ZVxuICAgICAqL1xuICAgIF9zbG90c0FyZUVxdWFsKG90aGVyKSB7XG4gICAgICAgIGlmICh0aGlzLmNsdXN0ZXJTbG90cyA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkodGhpcy5jbHVzdGVyU2xvdHMpID09PSBKU09OLnN0cmluZ2lmeShvdGhlcik7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlclN1YnNjcmliZXJHcm91cDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ConnectionPool.js":
/*!***************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ConnectionPool.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\");\nconst debug = (0, utils_1.Debug)(\"cluster:connectionPool\");\nclass ConnectionPool extends events_1.EventEmitter {\n    constructor(redisOptions) {\n        super();\n        this.redisOptions = redisOptions;\n        // master + slave = all\n        this.nodes = {\n            all: {},\n            master: {},\n            slave: {},\n        };\n        this.specifiedOptions = {};\n    }\n    getNodes(role = \"all\") {\n        const nodes = this.nodes[role];\n        return Object.keys(nodes).map((key) => nodes[key]);\n    }\n    getInstanceByKey(key) {\n        return this.nodes.all[key];\n    }\n    getSampleInstance(role) {\n        const keys = Object.keys(this.nodes[role]);\n        const sampleKey = (0, utils_1.sample)(keys);\n        return this.nodes[role][sampleKey];\n    }\n    /**\n     * Add a master node to the pool\n     * @param node\n     */\n    addMasterNode(node) {\n        const key = (0, util_1.getNodeKey)(node.options);\n        const redis = this.createRedisFromOptions(node, node.options.readOnly);\n        //Master nodes aren't read-only\n        if (!node.options.readOnly) {\n            this.nodes.all[key] = redis;\n            this.nodes.master[key] = redis;\n            return true;\n        }\n        return false;\n    }\n    /**\n     * Creates a Redis connection instance from the node options\n     * @param node\n     * @param readOnly\n     */\n    createRedisFromOptions(node, readOnly) {\n        const redis = new Redis_1.default((0, utils_1.defaults)({\n            // Never try to reconnect when a node is lose,\n            // instead, waiting for a `MOVED` error and\n            // fetch the slots again.\n            retryStrategy: null,\n            // Offline queue should be enabled so that\n            // we don't need to wait for the `ready` event\n            // before sending commands to the node.\n            enableOfflineQueue: true,\n            readOnly: readOnly,\n        }, node, this.redisOptions, { lazyConnect: true }));\n        return redis;\n    }\n    /**\n     * Find or create a connection to the node\n     */\n    findOrCreate(node, readOnly = false) {\n        const key = (0, util_1.getNodeKey)(node);\n        readOnly = Boolean(readOnly);\n        if (this.specifiedOptions[key]) {\n            Object.assign(node, this.specifiedOptions[key]);\n        }\n        else {\n            this.specifiedOptions[key] = node;\n        }\n        let redis;\n        if (this.nodes.all[key]) {\n            redis = this.nodes.all[key];\n            if (redis.options.readOnly !== readOnly) {\n                redis.options.readOnly = readOnly;\n                debug(\"Change role of %s to %s\", key, readOnly ? \"slave\" : \"master\");\n                redis[readOnly ? \"readonly\" : \"readwrite\"]().catch(utils_1.noop);\n                if (readOnly) {\n                    delete this.nodes.master[key];\n                    this.nodes.slave[key] = redis;\n                }\n                else {\n                    delete this.nodes.slave[key];\n                    this.nodes.master[key] = redis;\n                }\n            }\n        }\n        else {\n            debug(\"Connecting to %s as %s\", key, readOnly ? \"slave\" : \"master\");\n            redis = this.createRedisFromOptions(node, readOnly);\n            this.nodes.all[key] = redis;\n            this.nodes[readOnly ? \"slave\" : \"master\"][key] = redis;\n            redis.once(\"end\", () => {\n                this.removeNode(key);\n                this.emit(\"-node\", redis, key);\n                if (!Object.keys(this.nodes.all).length) {\n                    this.emit(\"drain\");\n                }\n            });\n            this.emit(\"+node\", redis, key);\n            redis.on(\"error\", function (error) {\n                this.emit(\"nodeError\", error, key);\n            });\n        }\n        return redis;\n    }\n    /**\n     * Reset the pool with a set of nodes.\n     * The old node will be removed.\n     */\n    reset(nodes) {\n        debug(\"Reset with %O\", nodes);\n        const newNodes = {};\n        nodes.forEach((node) => {\n            const key = (0, util_1.getNodeKey)(node);\n            // Don't override the existing (master) node\n            // when the current one is slave.\n            if (!(node.readOnly && newNodes[key])) {\n                newNodes[key] = node;\n            }\n        });\n        Object.keys(this.nodes.all).forEach((key) => {\n            if (!newNodes[key]) {\n                debug(\"Disconnect %s because the node does not hold any slot\", key);\n                this.nodes.all[key].disconnect();\n                this.removeNode(key);\n            }\n        });\n        Object.keys(newNodes).forEach((key) => {\n            const node = newNodes[key];\n            this.findOrCreate(node, node.readOnly);\n        });\n    }\n    /**\n     * Remove a node from the pool.\n     */\n    removeNode(key) {\n        const { nodes } = this;\n        if (nodes.all[key]) {\n            debug(\"Remove %s from the pool\", key);\n            delete nodes.all[key];\n        }\n        delete nodes.master[key];\n        delete nodes.slave[key];\n    }\n}\nexports[\"default\"] = ConnectionPool;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9Db25uZWN0aW9uUG9vbC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxpQkFBaUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNqQyxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBVTtBQUNsQyxlQUFlLG1CQUFPLENBQUMsdUdBQVE7QUFDL0IsZ0JBQWdCLG1CQUFPLENBQUMsa0dBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUI7QUFDbkIsc0JBQXNCO0FBQ3RCLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsNkJBQTZCLG1CQUFtQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFFBQVE7QUFDeEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0Nvbm5lY3Rpb25Qb29sLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgZXZlbnRzXzEgPSByZXF1aXJlKFwiZXZlbnRzXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBSZWRpc18xID0gcmVxdWlyZShcIi4uL1JlZGlzXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyOmNvbm5lY3Rpb25Qb29sXCIpO1xuY2xhc3MgQ29ubmVjdGlvblBvb2wgZXh0ZW5kcyBldmVudHNfMS5FdmVudEVtaXR0ZXIge1xuICAgIGNvbnN0cnVjdG9yKHJlZGlzT3B0aW9ucykge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnJlZGlzT3B0aW9ucyA9IHJlZGlzT3B0aW9ucztcbiAgICAgICAgLy8gbWFzdGVyICsgc2xhdmUgPSBhbGxcbiAgICAgICAgdGhpcy5ub2RlcyA9IHtcbiAgICAgICAgICAgIGFsbDoge30sXG4gICAgICAgICAgICBtYXN0ZXI6IHt9LFxuICAgICAgICAgICAgc2xhdmU6IHt9LFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnNwZWNpZmllZE9wdGlvbnMgPSB7fTtcbiAgICB9XG4gICAgZ2V0Tm9kZXMocm9sZSA9IFwiYWxsXCIpIHtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSB0aGlzLm5vZGVzW3JvbGVdO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmtleXMobm9kZXMpLm1hcCgoa2V5KSA9PiBub2Rlc1trZXldKTtcbiAgICB9XG4gICAgZ2V0SW5zdGFuY2VCeUtleShrZXkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubm9kZXMuYWxsW2tleV07XG4gICAgfVxuICAgIGdldFNhbXBsZUluc3RhbmNlKHJvbGUpIHtcbiAgICAgICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKHRoaXMubm9kZXNbcm9sZV0pO1xuICAgICAgICBjb25zdCBzYW1wbGVLZXkgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKGtleXMpO1xuICAgICAgICByZXR1cm4gdGhpcy5ub2Rlc1tyb2xlXVtzYW1wbGVLZXldO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBZGQgYSBtYXN0ZXIgbm9kZSB0byB0aGUgcG9vbFxuICAgICAqIEBwYXJhbSBub2RlXG4gICAgICovXG4gICAgYWRkTWFzdGVyTm9kZShub2RlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZS5vcHRpb25zKTtcbiAgICAgICAgY29uc3QgcmVkaXMgPSB0aGlzLmNyZWF0ZVJlZGlzRnJvbU9wdGlvbnMobm9kZSwgbm9kZS5vcHRpb25zLnJlYWRPbmx5KTtcbiAgICAgICAgLy9NYXN0ZXIgbm9kZXMgYXJlbid0IHJlYWQtb25seVxuICAgICAgICBpZiAoIW5vZGUub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5hbGxba2V5XSA9IHJlZGlzO1xuICAgICAgICAgICAgdGhpcy5ub2Rlcy5tYXN0ZXJba2V5XSA9IHJlZGlzO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgUmVkaXMgY29ubmVjdGlvbiBpbnN0YW5jZSBmcm9tIHRoZSBub2RlIG9wdGlvbnNcbiAgICAgKiBAcGFyYW0gbm9kZVxuICAgICAqIEBwYXJhbSByZWFkT25seVxuICAgICAqL1xuICAgIGNyZWF0ZVJlZGlzRnJvbU9wdGlvbnMobm9kZSwgcmVhZE9ubHkpIHtcbiAgICAgICAgY29uc3QgcmVkaXMgPSBuZXcgUmVkaXNfMS5kZWZhdWx0KCgwLCB1dGlsc18xLmRlZmF1bHRzKSh7XG4gICAgICAgICAgICAvLyBOZXZlciB0cnkgdG8gcmVjb25uZWN0IHdoZW4gYSBub2RlIGlzIGxvc2UsXG4gICAgICAgICAgICAvLyBpbnN0ZWFkLCB3YWl0aW5nIGZvciBhIGBNT1ZFRGAgZXJyb3IgYW5kXG4gICAgICAgICAgICAvLyBmZXRjaCB0aGUgc2xvdHMgYWdhaW4uXG4gICAgICAgICAgICByZXRyeVN0cmF0ZWd5OiBudWxsLFxuICAgICAgICAgICAgLy8gT2ZmbGluZSBxdWV1ZSBzaG91bGQgYmUgZW5hYmxlZCBzbyB0aGF0XG4gICAgICAgICAgICAvLyB3ZSBkb24ndCBuZWVkIHRvIHdhaXQgZm9yIHRoZSBgcmVhZHlgIGV2ZW50XG4gICAgICAgICAgICAvLyBiZWZvcmUgc2VuZGluZyBjb21tYW5kcyB0byB0aGUgbm9kZS5cbiAgICAgICAgICAgIGVuYWJsZU9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIHJlYWRPbmx5OiByZWFkT25seSxcbiAgICAgICAgfSwgbm9kZSwgdGhpcy5yZWRpc09wdGlvbnMsIHsgbGF6eUNvbm5lY3Q6IHRydWUgfSkpO1xuICAgICAgICByZXR1cm4gcmVkaXM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZpbmQgb3IgY3JlYXRlIGEgY29ubmVjdGlvbiB0byB0aGUgbm9kZVxuICAgICAqL1xuICAgIGZpbmRPckNyZWF0ZShub2RlLCByZWFkT25seSA9IGZhbHNlKSB7XG4gICAgICAgIGNvbnN0IGtleSA9ICgwLCB1dGlsXzEuZ2V0Tm9kZUtleSkobm9kZSk7XG4gICAgICAgIHJlYWRPbmx5ID0gQm9vbGVhbihyZWFkT25seSk7XG4gICAgICAgIGlmICh0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSkge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihub2RlLCB0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnNwZWNpZmllZE9wdGlvbnNba2V5XSA9IG5vZGU7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJlZGlzO1xuICAgICAgICBpZiAodGhpcy5ub2Rlcy5hbGxba2V5XSkge1xuICAgICAgICAgICAgcmVkaXMgPSB0aGlzLm5vZGVzLmFsbFtrZXldO1xuICAgICAgICAgICAgaWYgKHJlZGlzLm9wdGlvbnMucmVhZE9ubHkgIT09IHJlYWRPbmx5KSB7XG4gICAgICAgICAgICAgICAgcmVkaXMub3B0aW9ucy5yZWFkT25seSA9IHJlYWRPbmx5O1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiQ2hhbmdlIHJvbGUgb2YgJXMgdG8gJXNcIiwga2V5LCByZWFkT25seSA/IFwic2xhdmVcIiA6IFwibWFzdGVyXCIpO1xuICAgICAgICAgICAgICAgIHJlZGlzW3JlYWRPbmx5ID8gXCJyZWFkb25seVwiIDogXCJyZWFkd3JpdGVcIl0oKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICAgICAgICAgIGlmIChyZWFkT25seSkge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlcy5tYXN0ZXJba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub2Rlcy5zbGF2ZVtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWxldGUgdGhpcy5ub2Rlcy5zbGF2ZVtrZXldO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLm1hc3RlcltrZXldID0gcmVkaXM7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGVidWcoXCJDb25uZWN0aW5nIHRvICVzIGFzICVzXCIsIGtleSwgcmVhZE9ubHkgPyBcInNsYXZlXCIgOiBcIm1hc3RlclwiKTtcbiAgICAgICAgICAgIHJlZGlzID0gdGhpcy5jcmVhdGVSZWRpc0Zyb21PcHRpb25zKG5vZGUsIHJlYWRPbmx5KTtcbiAgICAgICAgICAgIHRoaXMubm9kZXMuYWxsW2tleV0gPSByZWRpcztcbiAgICAgICAgICAgIHRoaXMubm9kZXNbcmVhZE9ubHkgPyBcInNsYXZlXCIgOiBcIm1hc3RlclwiXVtrZXldID0gcmVkaXM7XG4gICAgICAgICAgICByZWRpcy5vbmNlKFwiZW5kXCIsICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoa2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoXCItbm9kZVwiLCByZWRpcywga2V5KTtcbiAgICAgICAgICAgICAgICBpZiAoIU9iamVjdC5rZXlzKHRoaXMubm9kZXMuYWxsKS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwiZHJhaW5cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0aGlzLmVtaXQoXCIrbm9kZVwiLCByZWRpcywga2V5KTtcbiAgICAgICAgICAgIHJlZGlzLm9uKFwiZXJyb3JcIiwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KFwibm9kZUVycm9yXCIsIGVycm9yLCBrZXkpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlZGlzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXNldCB0aGUgcG9vbCB3aXRoIGEgc2V0IG9mIG5vZGVzLlxuICAgICAqIFRoZSBvbGQgbm9kZSB3aWxsIGJlIHJlbW92ZWQuXG4gICAgICovXG4gICAgcmVzZXQobm9kZXMpIHtcbiAgICAgICAgZGVidWcoXCJSZXNldCB3aXRoICVPXCIsIG5vZGVzKTtcbiAgICAgICAgY29uc3QgbmV3Tm9kZXMgPSB7fTtcbiAgICAgICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gKDAsIHV0aWxfMS5nZXROb2RlS2V5KShub2RlKTtcbiAgICAgICAgICAgIC8vIERvbid0IG92ZXJyaWRlIHRoZSBleGlzdGluZyAobWFzdGVyKSBub2RlXG4gICAgICAgICAgICAvLyB3aGVuIHRoZSBjdXJyZW50IG9uZSBpcyBzbGF2ZS5cbiAgICAgICAgICAgIGlmICghKG5vZGUucmVhZE9ubHkgJiYgbmV3Tm9kZXNba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBuZXdOb2Rlc1trZXldID0gbm9kZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKHRoaXMubm9kZXMuYWxsKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGlmICghbmV3Tm9kZXNba2V5XSkge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiRGlzY29ubmVjdCAlcyBiZWNhdXNlIHRoZSBub2RlIGRvZXMgbm90IGhvbGQgYW55IHNsb3RcIiwga2V5KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vZGVzLmFsbFtrZXldLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZU5vZGUoa2V5KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIE9iamVjdC5rZXlzKG5ld05vZGVzKS5mb3JFYWNoKChrZXkpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBuZXdOb2Rlc1trZXldO1xuICAgICAgICAgICAgdGhpcy5maW5kT3JDcmVhdGUobm9kZSwgbm9kZS5yZWFkT25seSk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgYSBub2RlIGZyb20gdGhlIHBvb2wuXG4gICAgICovXG4gICAgcmVtb3ZlTm9kZShrZXkpIHtcbiAgICAgICAgY29uc3QgeyBub2RlcyB9ID0gdGhpcztcbiAgICAgICAgaWYgKG5vZGVzLmFsbFtrZXldKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcIlJlbW92ZSAlcyBmcm9tIHRoZSBwb29sXCIsIGtleSk7XG4gICAgICAgICAgICBkZWxldGUgbm9kZXMuYWxsW2tleV07XG4gICAgICAgIH1cbiAgICAgICAgZGVsZXRlIG5vZGVzLm1hc3RlcltrZXldO1xuICAgICAgICBkZWxldGUgbm9kZXMuc2xhdmVba2V5XTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb25uZWN0aW9uUG9vbDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ConnectionPool.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/DelayQueue.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/DelayQueue.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/../../node_modules/.pnpm/denque@2.1.0/node_modules/denque/index.js\");\nconst debug = (0, utils_1.Debug)(\"delayqueue\");\n/**\n * Queue that runs items after specified duration\n */\nclass DelayQueue {\n    constructor() {\n        this.queues = {};\n        this.timeouts = {};\n    }\n    /**\n     * Add a new item to the queue\n     *\n     * @param bucket bucket name\n     * @param item function that will run later\n     * @param options\n     */\n    push(bucket, item, options) {\n        const callback = options.callback || process.nextTick;\n        if (!this.queues[bucket]) {\n            this.queues[bucket] = new Deque();\n        }\n        const queue = this.queues[bucket];\n        queue.push(item);\n        if (!this.timeouts[bucket]) {\n            this.timeouts[bucket] = setTimeout(() => {\n                callback(() => {\n                    this.timeouts[bucket] = null;\n                    this.execute(bucket);\n                });\n            }, options.timeout);\n        }\n    }\n    execute(bucket) {\n        const queue = this.queues[bucket];\n        if (!queue) {\n            return;\n        }\n        const { length } = queue;\n        if (!length) {\n            return;\n        }\n        debug(\"send %d commands in %s queue\", length, bucket);\n        this.queues[bucket] = null;\n        while (queue.length > 0) {\n            queue.shift()();\n        }\n    }\n}\nexports[\"default\"] = DelayQueue;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9EZWxheVF1ZXVlLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGdCQUFnQixtQkFBTyxDQUFDLHdHQUFVO0FBQ2xDLGNBQWMsbUJBQU8sQ0FBQyx3RkFBUTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsU0FBUztBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL0RlbGF5UXVldWUuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uL3V0aWxzXCIpO1xuY29uc3QgRGVxdWUgPSByZXF1aXJlKFwiZGVucXVlXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJkZWxheXF1ZXVlXCIpO1xuLyoqXG4gKiBRdWV1ZSB0aGF0IHJ1bnMgaXRlbXMgYWZ0ZXIgc3BlY2lmaWVkIGR1cmF0aW9uXG4gKi9cbmNsYXNzIERlbGF5UXVldWUge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLnF1ZXVlcyA9IHt9O1xuICAgICAgICB0aGlzLnRpbWVvdXRzID0ge307XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFkZCBhIG5ldyBpdGVtIHRvIHRoZSBxdWV1ZVxuICAgICAqXG4gICAgICogQHBhcmFtIGJ1Y2tldCBidWNrZXQgbmFtZVxuICAgICAqIEBwYXJhbSBpdGVtIGZ1bmN0aW9uIHRoYXQgd2lsbCBydW4gbGF0ZXJcbiAgICAgKiBAcGFyYW0gb3B0aW9uc1xuICAgICAqL1xuICAgIHB1c2goYnVja2V0LCBpdGVtLCBvcHRpb25zKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gb3B0aW9ucy5jYWxsYmFjayB8fCBwcm9jZXNzLm5leHRUaWNrO1xuICAgICAgICBpZiAoIXRoaXMucXVldWVzW2J1Y2tldF0pIHtcbiAgICAgICAgICAgIHRoaXMucXVldWVzW2J1Y2tldF0gPSBuZXcgRGVxdWUoKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW2J1Y2tldF07XG4gICAgICAgIHF1ZXVlLnB1c2goaXRlbSk7XG4gICAgICAgIGlmICghdGhpcy50aW1lb3V0c1tidWNrZXRdKSB7XG4gICAgICAgICAgICB0aGlzLnRpbWVvdXRzW2J1Y2tldF0gPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjaygoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMudGltZW91dHNbYnVja2V0XSA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZShidWNrZXQpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSwgb3B0aW9ucy50aW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBleGVjdXRlKGJ1Y2tldCkge1xuICAgICAgICBjb25zdCBxdWV1ZSA9IHRoaXMucXVldWVzW2J1Y2tldF07XG4gICAgICAgIGlmICghcXVldWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB7IGxlbmd0aCB9ID0gcXVldWU7XG4gICAgICAgIGlmICghbGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgZGVidWcoXCJzZW5kICVkIGNvbW1hbmRzIGluICVzIHF1ZXVlXCIsIGxlbmd0aCwgYnVja2V0KTtcbiAgICAgICAgdGhpcy5xdWV1ZXNbYnVja2V0XSA9IG51bGw7XG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBxdWV1ZS5zaGlmdCgpKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBEZWxheVF1ZXVlO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/DelayQueue.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/index.js":
/*!******************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/index.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/../../node_modules/.pnpm/@ioredis+commands@1.2.0/node_modules/@ioredis/commands/built/index.js\");\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/../../node_modules/.pnpm/redis-errors@1.2.0/node_modules/redis-errors/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst ClusterAllFailedError_1 = __webpack_require__(/*! ../errors/ClusterAllFailedError */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/ClusterAllFailedError.js\");\nconst Redis_1 = __webpack_require__(/*! ../Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\");\nconst ScanStream_1 = __webpack_require__(/*! ../ScanStream */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/ScanStream.js\");\nconst transaction_1 = __webpack_require__(/*! ../transaction */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/transaction.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst applyMixin_1 = __webpack_require__(/*! ../utils/applyMixin */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/applyMixin.js\");\nconst Commander_1 = __webpack_require__(/*! ../utils/Commander */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/Commander.js\");\nconst ClusterOptions_1 = __webpack_require__(/*! ./ClusterOptions */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterOptions.js\");\nconst ClusterSubscriber_1 = __webpack_require__(/*! ./ClusterSubscriber */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriber.js\");\nconst ConnectionPool_1 = __webpack_require__(/*! ./ConnectionPool */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ConnectionPool.js\");\nconst DelayQueue_1 = __webpack_require__(/*! ./DelayQueue */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/DelayQueue.js\");\nconst util_1 = __webpack_require__(/*! ./util */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js\");\nconst Deque = __webpack_require__(/*! denque */ \"(rsc)/../../node_modules/.pnpm/denque@2.1.0/node_modules/denque/index.js\");\nconst ClusterSubscriberGroup_1 = __webpack_require__(/*! ./ClusterSubscriberGroup */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/ClusterSubscriberGroup.js\");\nconst debug = (0, utils_1.Debug)(\"cluster\");\nconst REJECT_OVERWRITTEN_COMMANDS = new WeakSet();\n/**\n * Client for the official Redis Cluster\n */\nclass Cluster extends Commander_1.default {\n    /**\n     * Creates an instance of Cluster.\n     */\n    //TODO: Add an option that enables or disables sharded PubSub\n    constructor(startupNodes, options = {}) {\n        super();\n        this.slots = [];\n        /**\n         * @ignore\n         */\n        this._groupsIds = {};\n        /**\n         * @ignore\n         */\n        this._groupsBySlot = Array(16384);\n        /**\n         * @ignore\n         */\n        this.isCluster = true;\n        this.retryAttempts = 0;\n        this.delayQueue = new DelayQueue_1.default();\n        this.offlineQueue = new Deque();\n        this.isRefreshing = false;\n        this._refreshSlotsCacheCallbacks = [];\n        this._autoPipelines = new Map();\n        this._runningAutoPipelines = new Set();\n        this._readyDelayedCallbacks = [];\n        /**\n         * Every time Cluster#connect() is called, this value will be\n         * auto-incrementing. The purpose of this value is used for\n         * discarding previous connect attampts when creating a new\n         * connection.\n         */\n        this.connectionEpoch = 0;\n        events_1.EventEmitter.call(this);\n        this.startupNodes = startupNodes;\n        this.options = (0, utils_1.defaults)({}, options, ClusterOptions_1.DEFAULT_CLUSTER_OPTIONS, this.options);\n        if (this.options.shardedSubscribers == true)\n            this.shardedSubscribers = new ClusterSubscriberGroup_1.default(this);\n        if (this.options.redisOptions &&\n            this.options.redisOptions.keyPrefix &&\n            !this.options.keyPrefix) {\n            this.options.keyPrefix = this.options.redisOptions.keyPrefix;\n        }\n        // validate options\n        if (typeof this.options.scaleReads !== \"function\" &&\n            [\"all\", \"master\", \"slave\"].indexOf(this.options.scaleReads) === -1) {\n            throw new Error('Invalid option scaleReads \"' +\n                this.options.scaleReads +\n                '\". Expected \"all\", \"master\", \"slave\" or a custom function');\n        }\n        this.connectionPool = new ConnectionPool_1.default(this.options.redisOptions);\n        this.connectionPool.on(\"-node\", (redis, key) => {\n            this.emit(\"-node\", redis);\n        });\n        this.connectionPool.on(\"+node\", (redis) => {\n            this.emit(\"+node\", redis);\n        });\n        this.connectionPool.on(\"drain\", () => {\n            this.setStatus(\"close\");\n        });\n        this.connectionPool.on(\"nodeError\", (error, key) => {\n            this.emit(\"node error\", error, key);\n        });\n        this.subscriber = new ClusterSubscriber_1.default(this.connectionPool, this);\n        if (this.options.scripts) {\n            Object.entries(this.options.scripts).forEach(([name, definition]) => {\n                this.defineCommand(name, definition);\n            });\n        }\n        if (this.options.lazyConnect) {\n            this.setStatus(\"wait\");\n        }\n        else {\n            this.connect().catch((err) => {\n                debug(\"connecting failed: %s\", err);\n            });\n        }\n    }\n    /**\n     * Connect to a cluster\n     */\n    connect() {\n        return new Promise((resolve, reject) => {\n            if (this.status === \"connecting\" ||\n                this.status === \"connect\" ||\n                this.status === \"ready\") {\n                reject(new Error(\"Redis is already connecting/connected\"));\n                return;\n            }\n            const epoch = ++this.connectionEpoch;\n            this.setStatus(\"connecting\");\n            this.resolveStartupNodeHostnames()\n                .then((nodes) => {\n                if (this.connectionEpoch !== epoch) {\n                    debug(\"discard connecting after resolving startup nodes because epoch not match: %d != %d\", epoch, this.connectionEpoch);\n                    reject(new redis_errors_1.RedisError(\"Connection is discarded because a new connection is made\"));\n                    return;\n                }\n                if (this.status !== \"connecting\") {\n                    debug(\"discard connecting after resolving startup nodes because the status changed to %s\", this.status);\n                    reject(new redis_errors_1.RedisError(\"Connection is aborted\"));\n                    return;\n                }\n                this.connectionPool.reset(nodes);\n                const readyHandler = () => {\n                    this.setStatus(\"ready\");\n                    this.retryAttempts = 0;\n                    this.executeOfflineCommands();\n                    this.resetNodesRefreshInterval();\n                    resolve();\n                };\n                let closeListener = undefined;\n                const refreshListener = () => {\n                    this.invokeReadyDelayedCallbacks(undefined);\n                    this.removeListener(\"close\", closeListener);\n                    this.manuallyClosing = false;\n                    this.setStatus(\"connect\");\n                    if (this.options.enableReadyCheck) {\n                        this.readyCheck((err, fail) => {\n                            if (err || fail) {\n                                debug(\"Ready check failed (%s). Reconnecting...\", err || fail);\n                                if (this.status === \"connect\") {\n                                    this.disconnect(true);\n                                }\n                            }\n                            else {\n                                readyHandler();\n                            }\n                        });\n                    }\n                    else {\n                        readyHandler();\n                    }\n                };\n                closeListener = () => {\n                    const error = new Error(\"None of startup nodes is available\");\n                    this.removeListener(\"refresh\", refreshListener);\n                    this.invokeReadyDelayedCallbacks(error);\n                    reject(error);\n                };\n                this.once(\"refresh\", refreshListener);\n                this.once(\"close\", closeListener);\n                this.once(\"close\", this.handleCloseEvent.bind(this));\n                this.refreshSlotsCache((err) => {\n                    if (err && err.message === ClusterAllFailedError_1.default.defaultMessage) {\n                        Redis_1.default.prototype.silentEmit.call(this, \"error\", err);\n                        this.connectionPool.reset([]);\n                    }\n                });\n                this.subscriber.start();\n                if (this.options.shardedSubscribers) {\n                    this.shardedSubscribers.start();\n                }\n            })\n                .catch((err) => {\n                this.setStatus(\"close\");\n                this.handleCloseEvent(err);\n                this.invokeReadyDelayedCallbacks(err);\n                reject(err);\n            });\n        });\n    }\n    /**\n     * Disconnect from every node in the cluster.\n     */\n    disconnect(reconnect = false) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        if (!reconnect) {\n            this.manuallyClosing = true;\n        }\n        if (this.reconnectTimeout && !reconnect) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n            debug(\"Canceled reconnecting attempts\");\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (this.options.shardedSubscribers) {\n            this.shardedSubscribers.stop();\n        }\n        if (status === \"wait\") {\n            this.setStatus(\"close\");\n            this.handleCloseEvent();\n        }\n        else {\n            this.connectionPool.reset([]);\n        }\n    }\n    /**\n     * Quit the cluster gracefully.\n     */\n    quit(callback) {\n        const status = this.status;\n        this.setStatus(\"disconnecting\");\n        this.manuallyClosing = true;\n        if (this.reconnectTimeout) {\n            clearTimeout(this.reconnectTimeout);\n            this.reconnectTimeout = null;\n        }\n        this.clearNodesRefreshInterval();\n        this.subscriber.stop();\n        if (this.options.shardedSubscribers) {\n            this.shardedSubscribers.stop();\n        }\n        if (status === \"wait\") {\n            const ret = (0, standard_as_callback_1.default)(Promise.resolve(\"OK\"), callback);\n            // use setImmediate to make sure \"close\" event\n            // being emitted after quit() is returned\n            setImmediate(function () {\n                this.setStatus(\"close\");\n                this.handleCloseEvent();\n            }.bind(this));\n            return ret;\n        }\n        return (0, standard_as_callback_1.default)(Promise.all(this.nodes().map((node) => node.quit().catch((err) => {\n            // Ignore the error caused by disconnecting since\n            // we're disconnecting...\n            if (err.message === utils_1.CONNECTION_CLOSED_ERROR_MSG) {\n                return \"OK\";\n            }\n            throw err;\n        }))).then(() => \"OK\"), callback);\n    }\n    /**\n     * Create a new instance with the same startup nodes and options as the current one.\n     *\n     * @example\n     * ```js\n     * var cluster = new Redis.Cluster([{ host: \"127.0.0.1\", port: \"30001\" }]);\n     * var anotherCluster = cluster.duplicate();\n     * ```\n     */\n    duplicate(overrideStartupNodes = [], overrideOptions = {}) {\n        const startupNodes = overrideStartupNodes.length > 0\n            ? overrideStartupNodes\n            : this.startupNodes.slice(0);\n        const options = Object.assign({}, this.options, overrideOptions);\n        return new Cluster(startupNodes, options);\n    }\n    /**\n     * Get nodes with the specified role\n     */\n    nodes(role = \"all\") {\n        if (role !== \"all\" && role !== \"master\" && role !== \"slave\") {\n            throw new Error('Invalid role \"' + role + '\". Expected \"all\", \"master\" or \"slave\"');\n        }\n        return this.connectionPool.getNodes(role);\n    }\n    /**\n     * This is needed in order not to install a listener for each auto pipeline\n     *\n     * @ignore\n     */\n    delayUntilReady(callback) {\n        this._readyDelayedCallbacks.push(callback);\n    }\n    /**\n     * Get the number of commands queued in automatic pipelines.\n     *\n     * This is not available (and returns 0) until the cluster is connected and slots information have been received.\n     */\n    get autoPipelineQueueSize() {\n        let queued = 0;\n        for (const pipeline of this._autoPipelines.values()) {\n            queued += pipeline.length;\n        }\n        return queued;\n    }\n    /**\n     * Refresh the slot cache\n     *\n     * @ignore\n     */\n    refreshSlotsCache(callback) {\n        if (callback) {\n            this._refreshSlotsCacheCallbacks.push(callback);\n        }\n        if (this.isRefreshing) {\n            return;\n        }\n        this.isRefreshing = true;\n        const _this = this;\n        const wrapper = (error) => {\n            this.isRefreshing = false;\n            for (const callback of this._refreshSlotsCacheCallbacks) {\n                callback(error);\n            }\n            this._refreshSlotsCacheCallbacks = [];\n        };\n        const nodes = (0, utils_1.shuffle)(this.connectionPool.getNodes());\n        let lastNodeError = null;\n        function tryNode(index) {\n            if (index === nodes.length) {\n                const error = new ClusterAllFailedError_1.default(ClusterAllFailedError_1.default.defaultMessage, lastNodeError);\n                return wrapper(error);\n            }\n            const node = nodes[index];\n            const key = `${node.options.host}:${node.options.port}`;\n            debug(\"getting slot cache from %s\", key);\n            _this.getInfoFromNode(node, function (err) {\n                switch (_this.status) {\n                    case \"close\":\n                    case \"end\":\n                        return wrapper(new Error(\"Cluster is disconnected.\"));\n                    case \"disconnecting\":\n                        return wrapper(new Error(\"Cluster is disconnecting.\"));\n                }\n                if (err) {\n                    _this.emit(\"node error\", err, key);\n                    lastNodeError = err;\n                    tryNode(index + 1);\n                }\n                else {\n                    _this.emit(\"refresh\");\n                    wrapper();\n                }\n            });\n        }\n        tryNode(0);\n    }\n    /**\n     * @ignore\n     */\n    sendCommand(command, stream, node) {\n        if (this.status === \"wait\") {\n            this.connect().catch(utils_1.noop);\n        }\n        if (this.status === \"end\") {\n            command.reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n            return command.promise;\n        }\n        let to = this.options.scaleReads;\n        if (to !== \"master\") {\n            const isCommandReadOnly = command.isReadOnly ||\n                ((0, commands_1.exists)(command.name) && (0, commands_1.hasFlag)(command.name, \"readonly\"));\n            if (!isCommandReadOnly) {\n                to = \"master\";\n            }\n        }\n        let targetSlot = node ? node.slot : command.getSlot();\n        const ttl = {};\n        const _this = this;\n        if (!node && !REJECT_OVERWRITTEN_COMMANDS.has(command)) {\n            REJECT_OVERWRITTEN_COMMANDS.add(command);\n            const reject = command.reject;\n            command.reject = function (err) {\n                const partialTry = tryConnection.bind(null, true);\n                _this.handleError(err, ttl, {\n                    moved: function (slot, key) {\n                        debug(\"command %s is moved to %s\", command.name, key);\n                        targetSlot = Number(slot);\n                        if (_this.slots[slot]) {\n                            _this.slots[slot][0] = key;\n                        }\n                        else {\n                            _this.slots[slot] = [key];\n                        }\n                        _this._groupsBySlot[slot] =\n                            _this._groupsIds[_this.slots[slot].join(\";\")];\n                        _this.connectionPool.findOrCreate(_this.natMapper(key));\n                        tryConnection();\n                        debug(\"refreshing slot caches... (triggered by MOVED error)\");\n                        _this.refreshSlotsCache();\n                    },\n                    ask: function (slot, key) {\n                        debug(\"command %s is required to ask %s:%s\", command.name, key);\n                        const mapped = _this.natMapper(key);\n                        _this.connectionPool.findOrCreate(mapped);\n                        tryConnection(false, `${mapped.host}:${mapped.port}`);\n                    },\n                    tryagain: partialTry,\n                    clusterDown: partialTry,\n                    connectionClosed: partialTry,\n                    maxRedirections: function (redirectionError) {\n                        reject.call(command, redirectionError);\n                    },\n                    defaults: function () {\n                        reject.call(command, err);\n                    },\n                });\n            };\n        }\n        tryConnection();\n        function tryConnection(random, asking) {\n            if (_this.status === \"end\") {\n                command.reject(new redis_errors_1.AbortError(\"Cluster is ended.\"));\n                return;\n            }\n            let redis;\n            if (_this.status === \"ready\" || command.name === \"cluster\") {\n                if (node && node.redis) {\n                    redis = node.redis;\n                }\n                else if (Command_1.default.checkFlag(\"ENTER_SUBSCRIBER_MODE\", command.name) ||\n                    Command_1.default.checkFlag(\"EXIT_SUBSCRIBER_MODE\", command.name)) {\n                    if (_this.options.shardedSubscribers == true &&\n                        (command.name == \"ssubscribe\" || command.name == \"sunsubscribe\")) {\n                        const sub = _this.shardedSubscribers.getResponsibleSubscriber(targetSlot);\n                        let status = -1;\n                        if (command.name == \"ssubscribe\")\n                            status = _this.shardedSubscribers.addChannels(command.getKeys());\n                        if (command.name == \"sunsubscribe\")\n                            status = _this.shardedSubscribers.removeChannels(command.getKeys());\n                        if (status !== -1) {\n                            redis = sub.getInstance();\n                        }\n                        else {\n                            command.reject(new redis_errors_1.AbortError(\"Can't add or remove the given channels. Are they in the same slot?\"));\n                        }\n                    }\n                    else {\n                        redis = _this.subscriber.getInstance();\n                    }\n                    if (!redis) {\n                        command.reject(new redis_errors_1.AbortError(\"No subscriber for the cluster\"));\n                        return;\n                    }\n                }\n                else {\n                    if (!random) {\n                        if (typeof targetSlot === \"number\" && _this.slots[targetSlot]) {\n                            const nodeKeys = _this.slots[targetSlot];\n                            if (typeof to === \"function\") {\n                                const nodes = nodeKeys.map(function (key) {\n                                    return _this.connectionPool.getInstanceByKey(key);\n                                });\n                                redis = to(nodes, command);\n                                if (Array.isArray(redis)) {\n                                    redis = (0, utils_1.sample)(redis);\n                                }\n                                if (!redis) {\n                                    redis = nodes[0];\n                                }\n                            }\n                            else {\n                                let key;\n                                if (to === \"all\") {\n                                    key = (0, utils_1.sample)(nodeKeys);\n                                }\n                                else if (to === \"slave\" && nodeKeys.length > 1) {\n                                    key = (0, utils_1.sample)(nodeKeys, 1);\n                                }\n                                else {\n                                    key = nodeKeys[0];\n                                }\n                                redis = _this.connectionPool.getInstanceByKey(key);\n                            }\n                        }\n                        if (asking) {\n                            redis = _this.connectionPool.getInstanceByKey(asking);\n                            redis.asking();\n                        }\n                    }\n                    if (!redis) {\n                        redis =\n                            (typeof to === \"function\"\n                                ? null\n                                : _this.connectionPool.getSampleInstance(to)) ||\n                                _this.connectionPool.getSampleInstance(\"all\");\n                    }\n                }\n                if (node && !node.redis) {\n                    node.redis = redis;\n                }\n            }\n            if (redis) {\n                redis.sendCommand(command, stream);\n            }\n            else if (_this.options.enableOfflineQueue) {\n                _this.offlineQueue.push({\n                    command: command,\n                    stream: stream,\n                    node: node,\n                });\n            }\n            else {\n                command.reject(new Error(\"Cluster isn't ready and enableOfflineQueue options is false\"));\n            }\n        }\n        return command.promise;\n    }\n    sscanStream(key, options) {\n        return this.createScanStream(\"sscan\", { key, options });\n    }\n    sscanBufferStream(key, options) {\n        return this.createScanStream(\"sscanBuffer\", { key, options });\n    }\n    hscanStream(key, options) {\n        return this.createScanStream(\"hscan\", { key, options });\n    }\n    hscanBufferStream(key, options) {\n        return this.createScanStream(\"hscanBuffer\", { key, options });\n    }\n    zscanStream(key, options) {\n        return this.createScanStream(\"zscan\", { key, options });\n    }\n    zscanBufferStream(key, options) {\n        return this.createScanStream(\"zscanBuffer\", { key, options });\n    }\n    /**\n     * @ignore\n     */\n    handleError(error, ttl, handlers) {\n        if (typeof ttl.value === \"undefined\") {\n            ttl.value = this.options.maxRedirections;\n        }\n        else {\n            ttl.value -= 1;\n        }\n        if (ttl.value <= 0) {\n            handlers.maxRedirections(new Error(\"Too many Cluster redirections. Last error: \" + error));\n            return;\n        }\n        const errv = error.message.split(\" \");\n        if (errv[0] === \"MOVED\") {\n            const timeout = this.options.retryDelayOnMoved;\n            if (timeout && typeof timeout === \"number\") {\n                this.delayQueue.push(\"moved\", handlers.moved.bind(null, errv[1], errv[2]), { timeout });\n            }\n            else {\n                handlers.moved(errv[1], errv[2]);\n            }\n        }\n        else if (errv[0] === \"ASK\") {\n            handlers.ask(errv[1], errv[2]);\n        }\n        else if (errv[0] === \"TRYAGAIN\") {\n            this.delayQueue.push(\"tryagain\", handlers.tryagain, {\n                timeout: this.options.retryDelayOnTryAgain,\n            });\n        }\n        else if (errv[0] === \"CLUSTERDOWN\" &&\n            this.options.retryDelayOnClusterDown > 0) {\n            this.delayQueue.push(\"clusterdown\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnClusterDown,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else if (error.message === utils_1.CONNECTION_CLOSED_ERROR_MSG &&\n            this.options.retryDelayOnFailover > 0 &&\n            this.status === \"ready\") {\n            this.delayQueue.push(\"failover\", handlers.connectionClosed, {\n                timeout: this.options.retryDelayOnFailover,\n                callback: this.refreshSlotsCache.bind(this),\n            });\n        }\n        else {\n            handlers.defaults();\n        }\n    }\n    resetOfflineQueue() {\n        this.offlineQueue = new Deque();\n    }\n    clearNodesRefreshInterval() {\n        if (this.slotsTimer) {\n            clearTimeout(this.slotsTimer);\n            this.slotsTimer = null;\n        }\n    }\n    resetNodesRefreshInterval() {\n        if (this.slotsTimer || !this.options.slotsRefreshInterval) {\n            return;\n        }\n        const nextRound = () => {\n            this.slotsTimer = setTimeout(() => {\n                debug('refreshing slot caches... (triggered by \"slotsRefreshInterval\" option)');\n                this.refreshSlotsCache(() => {\n                    nextRound();\n                });\n            }, this.options.slotsRefreshInterval);\n        };\n        nextRound();\n    }\n    /**\n     * Change cluster instance's status\n     */\n    setStatus(status) {\n        debug(\"status: %s -> %s\", this.status || \"[empty]\", status);\n        this.status = status;\n        process.nextTick(() => {\n            this.emit(status);\n        });\n    }\n    /**\n     * Called when closed to check whether a reconnection should be made\n     */\n    handleCloseEvent(reason) {\n        if (reason) {\n            debug(\"closed because %s\", reason);\n        }\n        let retryDelay;\n        if (!this.manuallyClosing &&\n            typeof this.options.clusterRetryStrategy === \"function\") {\n            retryDelay = this.options.clusterRetryStrategy.call(this, ++this.retryAttempts, reason);\n        }\n        if (typeof retryDelay === \"number\") {\n            this.setStatus(\"reconnecting\");\n            this.reconnectTimeout = setTimeout(() => {\n                this.reconnectTimeout = null;\n                debug(\"Cluster is disconnected. Retrying after %dms\", retryDelay);\n                this.connect().catch(function (err) {\n                    debug(\"Got error %s when reconnecting. Ignoring...\", err);\n                });\n            }, retryDelay);\n        }\n        else {\n            this.setStatus(\"end\");\n            this.flushQueue(new Error(\"None of startup nodes is available\"));\n        }\n    }\n    /**\n     * Flush offline queue with error.\n     */\n    flushQueue(error) {\n        let item;\n        while ((item = this.offlineQueue.shift())) {\n            item.command.reject(error);\n        }\n    }\n    executeOfflineCommands() {\n        if (this.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", this.offlineQueue.length);\n            const offlineQueue = this.offlineQueue;\n            this.resetOfflineQueue();\n            let item;\n            while ((item = offlineQueue.shift())) {\n                this.sendCommand(item.command, item.stream, item.node);\n            }\n        }\n    }\n    natMapper(nodeKey) {\n        const key = typeof nodeKey === \"string\"\n            ? nodeKey\n            : `${nodeKey.host}:${nodeKey.port}`;\n        let mapped = null;\n        if (this.options.natMap && typeof this.options.natMap === \"function\") {\n            mapped = this.options.natMap(key);\n        }\n        else if (this.options.natMap && typeof this.options.natMap === \"object\") {\n            mapped = this.options.natMap[key];\n        }\n        if (mapped) {\n            debug(\"NAT mapping %s -> %O\", key, mapped);\n            return Object.assign({}, mapped);\n        }\n        return typeof nodeKey === \"string\"\n            ? (0, util_1.nodeKeyToRedisOptions)(nodeKey)\n            : nodeKey;\n    }\n    getInfoFromNode(redis, callback) {\n        if (!redis) {\n            return callback(new Error(\"Node is disconnected\"));\n        }\n        // Use a duplication of the connection to avoid\n        // timeouts when the connection is in the blocking\n        // mode (e.g. waiting for BLPOP).\n        const duplicatedConnection = redis.duplicate({\n            enableOfflineQueue: true,\n            enableReadyCheck: false,\n            retryStrategy: null,\n            connectionName: (0, util_1.getConnectionName)(\"refresher\", this.options.redisOptions && this.options.redisOptions.connectionName),\n        });\n        // Ignore error events since we will handle\n        // exceptions for the CLUSTER SLOTS command.\n        duplicatedConnection.on(\"error\", utils_1.noop);\n        duplicatedConnection.cluster(\"SLOTS\", (0, utils_1.timeout)((err, result) => {\n            duplicatedConnection.disconnect();\n            if (err) {\n                debug(\"error encountered running CLUSTER.SLOTS: %s\", err);\n                return callback(err);\n            }\n            if (this.status === \"disconnecting\" ||\n                this.status === \"close\" ||\n                this.status === \"end\") {\n                debug(\"ignore CLUSTER.SLOTS results (count: %d) since cluster status is %s\", result.length, this.status);\n                callback();\n                return;\n            }\n            const nodes = [];\n            debug(\"cluster slots result count: %d\", result.length);\n            for (let i = 0; i < result.length; ++i) {\n                const items = result[i];\n                const slotRangeStart = items[0];\n                const slotRangeEnd = items[1];\n                const keys = [];\n                for (let j = 2; j < items.length; j++) {\n                    if (!items[j][0]) {\n                        continue;\n                    }\n                    const node = this.natMapper({\n                        host: items[j][0],\n                        port: items[j][1],\n                    });\n                    node.readOnly = j !== 2;\n                    nodes.push(node);\n                    keys.push(node.host + \":\" + node.port);\n                }\n                debug(\"cluster slots result [%d]: slots %d~%d served by %s\", i, slotRangeStart, slotRangeEnd, keys);\n                for (let slot = slotRangeStart; slot <= slotRangeEnd; slot++) {\n                    this.slots[slot] = keys;\n                }\n            }\n            // Assign to each node keys a numeric value to make autopipeline comparison faster.\n            this._groupsIds = Object.create(null);\n            let j = 0;\n            for (let i = 0; i < 16384; i++) {\n                const target = (this.slots[i] || []).join(\";\");\n                if (!target.length) {\n                    this._groupsBySlot[i] = undefined;\n                    continue;\n                }\n                if (!this._groupsIds[target]) {\n                    this._groupsIds[target] = ++j;\n                }\n                this._groupsBySlot[i] = this._groupsIds[target];\n            }\n            this.connectionPool.reset(nodes);\n            callback();\n        }, this.options.slotsRefreshTimeout));\n    }\n    invokeReadyDelayedCallbacks(err) {\n        for (const c of this._readyDelayedCallbacks) {\n            process.nextTick(c, err);\n        }\n        this._readyDelayedCallbacks = [];\n    }\n    /**\n     * Check whether Cluster is able to process commands\n     */\n    readyCheck(callback) {\n        this.cluster(\"INFO\", (err, res) => {\n            if (err) {\n                return callback(err);\n            }\n            if (typeof res !== \"string\") {\n                return callback();\n            }\n            let state;\n            const lines = res.split(\"\\r\\n\");\n            for (let i = 0; i < lines.length; ++i) {\n                const parts = lines[i].split(\":\");\n                if (parts[0] === \"cluster_state\") {\n                    state = parts[1];\n                    break;\n                }\n            }\n            if (state === \"fail\") {\n                debug(\"cluster state not ok (%s)\", state);\n                callback(null, state);\n            }\n            else {\n                callback();\n            }\n        });\n    }\n    resolveSrv(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.resolveSrv(hostname, (err, records) => {\n                if (err) {\n                    return reject(err);\n                }\n                const self = this, groupedRecords = (0, util_1.groupSrvRecords)(records), sortedKeys = Object.keys(groupedRecords).sort((a, b) => parseInt(a) - parseInt(b));\n                function tryFirstOne(err) {\n                    if (!sortedKeys.length) {\n                        return reject(err);\n                    }\n                    const key = sortedKeys[0], group = groupedRecords[key], record = (0, util_1.weightSrvRecords)(group);\n                    if (!group.records.length) {\n                        sortedKeys.shift();\n                    }\n                    self.dnsLookup(record.name).then((host) => resolve({\n                        host,\n                        port: record.port,\n                    }), tryFirstOne);\n                }\n                tryFirstOne();\n            });\n        });\n    }\n    dnsLookup(hostname) {\n        return new Promise((resolve, reject) => {\n            this.options.dnsLookup(hostname, (err, address) => {\n                if (err) {\n                    debug(\"failed to resolve hostname %s to IP: %s\", hostname, err.message);\n                    reject(err);\n                }\n                else {\n                    debug(\"resolved hostname %s to IP %s\", hostname, address);\n                    resolve(address);\n                }\n            });\n        });\n    }\n    /**\n     * Normalize startup nodes, and resolving hostnames to IPs.\n     *\n     * This process happens every time when #connect() is called since\n     * #startupNodes and DNS records may chanage.\n     */\n    async resolveStartupNodeHostnames() {\n        if (!Array.isArray(this.startupNodes) || this.startupNodes.length === 0) {\n            throw new Error(\"`startupNodes` should contain at least one node.\");\n        }\n        const startupNodes = (0, util_1.normalizeNodeOptions)(this.startupNodes);\n        const hostnames = (0, util_1.getUniqueHostnamesFromOptions)(startupNodes);\n        if (hostnames.length === 0) {\n            return startupNodes;\n        }\n        const configs = await Promise.all(hostnames.map((this.options.useSRVRecords ? this.resolveSrv : this.dnsLookup).bind(this)));\n        const hostnameToConfig = (0, utils_1.zipMap)(hostnames, configs);\n        return startupNodes.map((node) => {\n            const config = hostnameToConfig.get(node.host);\n            if (!config) {\n                return node;\n            }\n            if (this.options.useSRVRecords) {\n                return Object.assign({}, node, config);\n            }\n            return Object.assign({}, node, { host: config });\n        });\n    }\n    createScanStream(command, { key, options = {} }) {\n        return new ScanStream_1.default({\n            objectMode: true,\n            key: key,\n            redis: this,\n            command: command,\n            ...options,\n        });\n    }\n}\n(0, applyMixin_1.default)(Cluster, events_1.EventEmitter);\n(0, transaction_1.addTransactionSupport)(Cluster.prototype);\nexports[\"default\"] = Cluster;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQywrSEFBbUI7QUFDOUMsaUJBQWlCLG1CQUFPLENBQUMsc0JBQVE7QUFDakMsdUJBQXVCLG1CQUFPLENBQUMsMEdBQWM7QUFDN0MsK0JBQStCLG1CQUFPLENBQUMsd0lBQXNCO0FBQzdELGtCQUFrQixtQkFBTyxDQUFDLHNHQUFZO0FBQ3RDLGdDQUFnQyxtQkFBTyxDQUFDLGdKQUFpQztBQUN6RSxnQkFBZ0IsbUJBQU8sQ0FBQyxrR0FBVTtBQUNsQyxxQkFBcUIsbUJBQU8sQ0FBQyw0R0FBZTtBQUM1QyxzQkFBc0IsbUJBQU8sQ0FBQyw4R0FBZ0I7QUFDOUMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMscUJBQXFCLG1CQUFPLENBQUMsd0hBQXFCO0FBQ2xELG9CQUFvQixtQkFBTyxDQUFDLHNIQUFvQjtBQUNoRCx5QkFBeUIsbUJBQU8sQ0FBQywySEFBa0I7QUFDbkQsNEJBQTRCLG1CQUFPLENBQUMsaUlBQXFCO0FBQ3pELHlCQUF5QixtQkFBTyxDQUFDLDJIQUFrQjtBQUNuRCxxQkFBcUIsbUJBQU8sQ0FBQyxtSEFBYztBQUMzQyxlQUFlLG1CQUFPLENBQUMsdUdBQVE7QUFDL0IsY0FBYyxtQkFBTyxDQUFDLHdGQUFRO0FBQzlCLGlDQUFpQyxtQkFBTyxDQUFDLDJJQUEwQjtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGtDQUFrQztBQUM1RTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixrQkFBa0IsR0FBRyxrQkFBa0I7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsWUFBWSxHQUFHLFlBQVk7QUFDM0UscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxjQUFjO0FBQzlEO0FBQ0E7QUFDQSxzREFBc0QsY0FBYztBQUNwRTtBQUNBO0FBQ0EsZ0RBQWdELGNBQWM7QUFDOUQ7QUFDQTtBQUNBLHNEQUFzRCxjQUFjO0FBQ3BFO0FBQ0E7QUFDQSxnREFBZ0QsY0FBYztBQUM5RDtBQUNBO0FBQ0Esc0RBQXNELGNBQWM7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RkFBNkYsU0FBUztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsYUFBYSxHQUFHLGFBQWE7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLG1CQUFtQjtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxrQkFBa0I7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Qsc0JBQXNCO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixXQUFXO0FBQ3ZDLDREQUE0RDtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsa0JBQWtCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0EsbUNBQW1DLFVBQVUsY0FBYztBQUMzRCxTQUFTO0FBQ1Q7QUFDQSxnQ0FBZ0MsbUJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY29uc3QgY29tbWFuZHNfMSA9IHJlcXVpcmUoXCJAaW9yZWRpcy9jb21tYW5kc1wiKTtcbmNvbnN0IGV2ZW50c18xID0gcmVxdWlyZShcImV2ZW50c1wiKTtcbmNvbnN0IHJlZGlzX2Vycm9yc18xID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi4vQ29tbWFuZFwiKTtcbmNvbnN0IENsdXN0ZXJBbGxGYWlsZWRFcnJvcl8xID0gcmVxdWlyZShcIi4uL2Vycm9ycy9DbHVzdGVyQWxsRmFpbGVkRXJyb3JcIik7XG5jb25zdCBSZWRpc18xID0gcmVxdWlyZShcIi4uL1JlZGlzXCIpO1xuY29uc3QgU2NhblN0cmVhbV8xID0gcmVxdWlyZShcIi4uL1NjYW5TdHJlYW1cIik7XG5jb25zdCB0cmFuc2FjdGlvbl8xID0gcmVxdWlyZShcIi4uL3RyYW5zYWN0aW9uXCIpO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IGFwcGx5TWl4aW5fMSA9IHJlcXVpcmUoXCIuLi91dGlscy9hcHBseU1peGluXCIpO1xuY29uc3QgQ29tbWFuZGVyXzEgPSByZXF1aXJlKFwiLi4vdXRpbHMvQ29tbWFuZGVyXCIpO1xuY29uc3QgQ2x1c3Rlck9wdGlvbnNfMSA9IHJlcXVpcmUoXCIuL0NsdXN0ZXJPcHRpb25zXCIpO1xuY29uc3QgQ2x1c3RlclN1YnNjcmliZXJfMSA9IHJlcXVpcmUoXCIuL0NsdXN0ZXJTdWJzY3JpYmVyXCIpO1xuY29uc3QgQ29ubmVjdGlvblBvb2xfMSA9IHJlcXVpcmUoXCIuL0Nvbm5lY3Rpb25Qb29sXCIpO1xuY29uc3QgRGVsYXlRdWV1ZV8xID0gcmVxdWlyZShcIi4vRGVsYXlRdWV1ZVwiKTtcbmNvbnN0IHV0aWxfMSA9IHJlcXVpcmUoXCIuL3V0aWxcIik7XG5jb25zdCBEZXF1ZSA9IHJlcXVpcmUoXCJkZW5xdWVcIik7XG5jb25zdCBDbHVzdGVyU3Vic2NyaWJlckdyb3VwXzEgPSByZXF1aXJlKFwiLi9DbHVzdGVyU3Vic2NyaWJlckdyb3VwXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjbHVzdGVyXCIpO1xuY29uc3QgUkVKRUNUX09WRVJXUklUVEVOX0NPTU1BTkRTID0gbmV3IFdlYWtTZXQoKTtcbi8qKlxuICogQ2xpZW50IGZvciB0aGUgb2ZmaWNpYWwgUmVkaXMgQ2x1c3RlclxuICovXG5jbGFzcyBDbHVzdGVyIGV4dGVuZHMgQ29tbWFuZGVyXzEuZGVmYXVsdCB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhbiBpbnN0YW5jZSBvZiBDbHVzdGVyLlxuICAgICAqL1xuICAgIC8vVE9ETzogQWRkIGFuIG9wdGlvbiB0aGF0IGVuYWJsZXMgb3IgZGlzYWJsZXMgc2hhcmRlZCBQdWJTdWJcbiAgICBjb25zdHJ1Y3RvcihzdGFydHVwTm9kZXMsIG9wdGlvbnMgPSB7fSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICB0aGlzLnNsb3RzID0gW107XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAaWdub3JlXG4gICAgICAgICAqL1xuICAgICAgICB0aGlzLl9ncm91cHNJZHMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuX2dyb3Vwc0J5U2xvdCA9IEFycmF5KDE2Mzg0KTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuaXNDbHVzdGVyID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5yZXRyeUF0dGVtcHRzID0gMDtcbiAgICAgICAgdGhpcy5kZWxheVF1ZXVlID0gbmV3IERlbGF5UXVldWVfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRoaXMub2ZmbGluZVF1ZXVlID0gbmV3IERlcXVlKCk7XG4gICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzID0gW107XG4gICAgICAgIHRoaXMuX2F1dG9QaXBlbGluZXMgPSBuZXcgTWFwKCk7XG4gICAgICAgIHRoaXMuX3J1bm5pbmdBdXRvUGlwZWxpbmVzID0gbmV3IFNldCgpO1xuICAgICAgICB0aGlzLl9yZWFkeURlbGF5ZWRDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEV2ZXJ5IHRpbWUgQ2x1c3RlciNjb25uZWN0KCkgaXMgY2FsbGVkLCB0aGlzIHZhbHVlIHdpbGwgYmVcbiAgICAgICAgICogYXV0by1pbmNyZW1lbnRpbmcuIFRoZSBwdXJwb3NlIG9mIHRoaXMgdmFsdWUgaXMgdXNlZCBmb3JcbiAgICAgICAgICogZGlzY2FyZGluZyBwcmV2aW91cyBjb25uZWN0IGF0dGFtcHRzIHdoZW4gY3JlYXRpbmcgYSBuZXdcbiAgICAgICAgICogY29ubmVjdGlvbi5cbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuY29ubmVjdGlvbkVwb2NoID0gMDtcbiAgICAgICAgZXZlbnRzXzEuRXZlbnRFbWl0dGVyLmNhbGwodGhpcyk7XG4gICAgICAgIHRoaXMuc3RhcnR1cE5vZGVzID0gc3RhcnR1cE5vZGVzO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSAoMCwgdXRpbHNfMS5kZWZhdWx0cykoe30sIG9wdGlvbnMsIENsdXN0ZXJPcHRpb25zXzEuREVGQVVMVF9DTFVTVEVSX09QVElPTlMsIHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2hhcmRlZFN1YnNjcmliZXJzID09IHRydWUpXG4gICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycyA9IG5ldyBDbHVzdGVyU3Vic2NyaWJlckdyb3VwXzEuZGVmYXVsdCh0aGlzKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMua2V5UHJlZml4ICYmXG4gICAgICAgICAgICAhdGhpcy5vcHRpb25zLmtleVByZWZpeCkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmtleVByZWZpeCA9IHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMua2V5UHJlZml4O1xuICAgICAgICB9XG4gICAgICAgIC8vIHZhbGlkYXRlIG9wdGlvbnNcbiAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm9wdGlvbnMuc2NhbGVSZWFkcyAhPT0gXCJmdW5jdGlvblwiICYmXG4gICAgICAgICAgICBbXCJhbGxcIiwgXCJtYXN0ZXJcIiwgXCJzbGF2ZVwiXS5pbmRleE9mKHRoaXMub3B0aW9ucy5zY2FsZVJlYWRzKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBvcHRpb24gc2NhbGVSZWFkcyBcIicgK1xuICAgICAgICAgICAgICAgIHRoaXMub3B0aW9ucy5zY2FsZVJlYWRzICtcbiAgICAgICAgICAgICAgICAnXCIuIEV4cGVjdGVkIFwiYWxsXCIsIFwibWFzdGVyXCIsIFwic2xhdmVcIiBvciBhIGN1c3RvbSBmdW5jdGlvbicpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wgPSBuZXcgQ29ubmVjdGlvblBvb2xfMS5kZWZhdWx0KHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLm9uKFwiLW5vZGVcIiwgKHJlZGlzLCBrZXkpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIi1ub2RlXCIsIHJlZGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCIrbm9kZVwiLCAocmVkaXMpID0+IHtcbiAgICAgICAgICAgIHRoaXMuZW1pdChcIitub2RlXCIsIHJlZGlzKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvblBvb2wub24oXCJkcmFpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNsb3NlXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5vbihcIm5vZGVFcnJvclwiLCAoZXJyb3IsIGtleSkgPT4ge1xuICAgICAgICAgICAgdGhpcy5lbWl0KFwibm9kZSBlcnJvclwiLCBlcnJvciwga2V5KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc3Vic2NyaWJlciA9IG5ldyBDbHVzdGVyU3Vic2NyaWJlcl8xLmRlZmF1bHQodGhpcy5jb25uZWN0aW9uUG9vbCwgdGhpcyk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuc2NyaXB0cykge1xuICAgICAgICAgICAgT2JqZWN0LmVudHJpZXModGhpcy5vcHRpb25zLnNjcmlwdHMpLmZvckVhY2goKFtuYW1lLCBkZWZpbml0aW9uXSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuZGVmaW5lQ29tbWFuZChuYW1lLCBkZWZpbml0aW9uKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMubGF6eUNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwid2FpdFwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3RpbmcgZmFpbGVkOiAlc1wiLCBlcnIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQ29ubmVjdCB0byBhIGNsdXN0ZXJcbiAgICAgKi9cbiAgICBjb25uZWN0KCkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RpbmdcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcImNvbm5lY3RcIiB8fFxuICAgICAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKFwiUmVkaXMgaXMgYWxyZWFkeSBjb25uZWN0aW5nL2Nvbm5lY3RlZFwiKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgZXBvY2ggPSArK3RoaXMuY29ubmVjdGlvbkVwb2NoO1xuICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZXNvbHZlU3RhcnR1cE5vZGVIb3N0bmFtZXMoKVxuICAgICAgICAgICAgICAgIC50aGVuKChub2RlcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25FcG9jaCAhPT0gZXBvY2gpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJkaXNjYXJkIGNvbm5lY3RpbmcgYWZ0ZXIgcmVzb2x2aW5nIHN0YXJ0dXAgbm9kZXMgYmVjYXVzZSBlcG9jaCBub3QgbWF0Y2g6ICVkICE9ICVkXCIsIGVwb2NoLCB0aGlzLmNvbm5lY3Rpb25FcG9jaCk7XG4gICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuUmVkaXNFcnJvcihcIkNvbm5lY3Rpb24gaXMgZGlzY2FyZGVkIGJlY2F1c2UgYSBuZXcgY29ubmVjdGlvbiBpcyBtYWRlXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgIT09IFwiY29ubmVjdGluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiZGlzY2FyZCBjb25uZWN0aW5nIGFmdGVyIHJlc29sdmluZyBzdGFydHVwIG5vZGVzIGJlY2F1c2UgdGhlIHN0YXR1cyBjaGFuZ2VkIHRvICVzXCIsIHRoaXMuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KG5ldyByZWRpc19lcnJvcnNfMS5SZWRpc0Vycm9yKFwiQ29ubmVjdGlvbiBpcyBhYm9ydGVkXCIpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLnJlc2V0KG5vZGVzKTtcbiAgICAgICAgICAgICAgICBjb25zdCByZWFkeUhhbmRsZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwicmVhZHlcIik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZXhlY3V0ZU9mZmxpbmVDb21tYW5kcygpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0Tm9kZXNSZWZyZXNoSW50ZXJ2YWwoKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgbGV0IGNsb3NlTGlzdGVuZXIgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgY29uc3QgcmVmcmVzaExpc3RlbmVyID0gKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmludm9rZVJlYWR5RGVsYXllZENhbGxiYWNrcyh1bmRlZmluZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKFwiY2xvc2VcIiwgY2xvc2VMaXN0ZW5lcik7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiY29ubmVjdFwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVSZWFkeUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlYWR5Q2hlY2soKGVyciwgZmFpbCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgfHwgZmFpbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcIlJlYWR5IGNoZWNrIGZhaWxlZCAoJXMpLiBSZWNvbm5lY3RpbmcuLi5cIiwgZXJyIHx8IGZhaWwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwiY29ubmVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlYWR5SGFuZGxlcigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVhZHlIYW5kbGVyKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGNsb3NlTGlzdGVuZXIgPSAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gbmV3IEVycm9yKFwiTm9uZSBvZiBzdGFydHVwIG5vZGVzIGlzIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcihcInJlZnJlc2hcIiwgcmVmcmVzaExpc3RlbmVyKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnZva2VSZWFkeURlbGF5ZWRDYWxsYmFja3MoZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbmNlKFwicmVmcmVzaFwiLCByZWZyZXNoTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImNsb3NlXCIsIGNsb3NlTGlzdGVuZXIpO1xuICAgICAgICAgICAgICAgIHRoaXMub25jZShcImNsb3NlXCIsIHRoaXMuaGFuZGxlQ2xvc2VFdmVudC5iaW5kKHRoaXMpKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlZnJlc2hTbG90c0NhY2hlKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBlcnIubWVzc2FnZSA9PT0gQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEuZGVmYXVsdC5kZWZhdWx0TWVzc2FnZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgUmVkaXNfMS5kZWZhdWx0LnByb3RvdHlwZS5zaWxlbnRFbWl0LmNhbGwodGhpcywgXCJlcnJvclwiLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uUG9vbC5yZXNldChbXSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLnN1YnNjcmliZXIuc3RhcnQoKTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNoYXJkZWRTdWJzY3JpYmVycy5zdGFydCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlQ2xvc2VFdmVudChlcnIpO1xuICAgICAgICAgICAgICAgIHRoaXMuaW52b2tlUmVhZHlEZWxheWVkQ2FsbGJhY2tzKGVycik7XG4gICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERpc2Nvbm5lY3QgZnJvbSBldmVyeSBub2RlIGluIHRoZSBjbHVzdGVyLlxuICAgICAqL1xuICAgIGRpc2Nvbm5lY3QocmVjb25uZWN0ID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3Qgc3RhdHVzID0gdGhpcy5zdGF0dXM7XG4gICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiZGlzY29ubmVjdGluZ1wiKTtcbiAgICAgICAgaWYgKCFyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIHRoaXMubWFudWFsbHlDbG9zaW5nID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5yZWNvbm5lY3RUaW1lb3V0ICYmICFyZWNvbm5lY3QpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgIGRlYnVnKFwiQ2FuY2VsZWQgcmVjb25uZWN0aW5nIGF0dGVtcHRzXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY2xlYXJOb2Rlc1JlZnJlc2hJbnRlcnZhbCgpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZXIuc3RvcCgpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycykge1xuICAgICAgICAgICAgdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICB0aGlzLnNldFN0YXR1cyhcImNsb3NlXCIpO1xuICAgICAgICAgICAgdGhpcy5oYW5kbGVDbG9zZUV2ZW50KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLnJlc2V0KFtdKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBRdWl0IHRoZSBjbHVzdGVyIGdyYWNlZnVsbHkuXG4gICAgICovXG4gICAgcXVpdChjYWxsYmFjaykge1xuICAgICAgICBjb25zdCBzdGF0dXMgPSB0aGlzLnN0YXR1cztcbiAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJkaXNjb25uZWN0aW5nXCIpO1xuICAgICAgICB0aGlzLm1hbnVhbGx5Q2xvc2luZyA9IHRydWU7XG4gICAgICAgIGlmICh0aGlzLnJlY29ubmVjdFRpbWVvdXQpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJlY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNsZWFyTm9kZXNSZWZyZXNoSW50ZXJ2YWwoKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpYmVyLnN0b3AoKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5zaGFyZGVkU3Vic2NyaWJlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2hhcmRlZFN1YnNjcmliZXJzLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdHVzID09PSBcIndhaXRcIikge1xuICAgICAgICAgICAgY29uc3QgcmV0ID0gKDAsIHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEuZGVmYXVsdCkoUHJvbWlzZS5yZXNvbHZlKFwiT0tcIiksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIC8vIHVzZSBzZXRJbW1lZGlhdGUgdG8gbWFrZSBzdXJlIFwiY2xvc2VcIiBldmVudFxuICAgICAgICAgICAgLy8gYmVpbmcgZW1pdHRlZCBhZnRlciBxdWl0KCkgaXMgcmV0dXJuZWRcbiAgICAgICAgICAgIHNldEltbWVkaWF0ZShmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgICAgICAgICB0aGlzLmhhbmRsZUNsb3NlRXZlbnQoKTtcbiAgICAgICAgICAgIH0uYmluZCh0aGlzKSk7XG4gICAgICAgICAgICByZXR1cm4gcmV0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShQcm9taXNlLmFsbCh0aGlzLm5vZGVzKCkubWFwKChub2RlKSA9PiBub2RlLnF1aXQoKS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGVycm9yIGNhdXNlZCBieSBkaXNjb25uZWN0aW5nIHNpbmNlXG4gICAgICAgICAgICAvLyB3ZSdyZSBkaXNjb25uZWN0aW5nLi4uXG4gICAgICAgICAgICBpZiAoZXJyLm1lc3NhZ2UgPT09IHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFwiT0tcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfSkpKS50aGVuKCgpID0+IFwiT0tcIiksIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IGluc3RhbmNlIHdpdGggdGhlIHNhbWUgc3RhcnR1cCBub2RlcyBhbmQgb3B0aW9ucyBhcyB0aGUgY3VycmVudCBvbmUuXG4gICAgICpcbiAgICAgKiBAZXhhbXBsZVxuICAgICAqIGBgYGpzXG4gICAgICogdmFyIGNsdXN0ZXIgPSBuZXcgUmVkaXMuQ2x1c3RlcihbeyBob3N0OiBcIjEyNy4wLjAuMVwiLCBwb3J0OiBcIjMwMDAxXCIgfV0pO1xuICAgICAqIHZhciBhbm90aGVyQ2x1c3RlciA9IGNsdXN0ZXIuZHVwbGljYXRlKCk7XG4gICAgICogYGBgXG4gICAgICovXG4gICAgZHVwbGljYXRlKG92ZXJyaWRlU3RhcnR1cE5vZGVzID0gW10sIG92ZXJyaWRlT3B0aW9ucyA9IHt9KSB7XG4gICAgICAgIGNvbnN0IHN0YXJ0dXBOb2RlcyA9IG92ZXJyaWRlU3RhcnR1cE5vZGVzLmxlbmd0aCA+IDBcbiAgICAgICAgICAgID8gb3ZlcnJpZGVTdGFydHVwTm9kZXNcbiAgICAgICAgICAgIDogdGhpcy5zdGFydHVwTm9kZXMuc2xpY2UoMCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCB0aGlzLm9wdGlvbnMsIG92ZXJyaWRlT3B0aW9ucyk7XG4gICAgICAgIHJldHVybiBuZXcgQ2x1c3RlcihzdGFydHVwTm9kZXMsIG9wdGlvbnMpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgbm9kZXMgd2l0aCB0aGUgc3BlY2lmaWVkIHJvbGVcbiAgICAgKi9cbiAgICBub2Rlcyhyb2xlID0gXCJhbGxcIikge1xuICAgICAgICBpZiAocm9sZSAhPT0gXCJhbGxcIiAmJiByb2xlICE9PSBcIm1hc3RlclwiICYmIHJvbGUgIT09IFwic2xhdmVcIikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIHJvbGUgXCInICsgcm9sZSArICdcIi4gRXhwZWN0ZWQgXCJhbGxcIiwgXCJtYXN0ZXJcIiBvciBcInNsYXZlXCInKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uUG9vbC5nZXROb2Rlcyhyb2xlKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhpcyBpcyBuZWVkZWQgaW4gb3JkZXIgbm90IHRvIGluc3RhbGwgYSBsaXN0ZW5lciBmb3IgZWFjaCBhdXRvIHBpcGVsaW5lXG4gICAgICpcbiAgICAgKiBAaWdub3JlXG4gICAgICovXG4gICAgZGVsYXlVbnRpbFJlYWR5KGNhbGxiYWNrKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5RGVsYXllZENhbGxiYWNrcy5wdXNoKGNhbGxiYWNrKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBudW1iZXIgb2YgY29tbWFuZHMgcXVldWVkIGluIGF1dG9tYXRpYyBwaXBlbGluZXMuXG4gICAgICpcbiAgICAgKiBUaGlzIGlzIG5vdCBhdmFpbGFibGUgKGFuZCByZXR1cm5zIDApIHVudGlsIHRoZSBjbHVzdGVyIGlzIGNvbm5lY3RlZCBhbmQgc2xvdHMgaW5mb3JtYXRpb24gaGF2ZSBiZWVuIHJlY2VpdmVkLlxuICAgICAqL1xuICAgIGdldCBhdXRvUGlwZWxpbmVRdWV1ZVNpemUoKSB7XG4gICAgICAgIGxldCBxdWV1ZWQgPSAwO1xuICAgICAgICBmb3IgKGNvbnN0IHBpcGVsaW5lIG9mIHRoaXMuX2F1dG9QaXBlbGluZXMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHF1ZXVlZCArPSBwaXBlbGluZS5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHF1ZXVlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVmcmVzaCB0aGUgc2xvdCBjYWNoZVxuICAgICAqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHJlZnJlc2hTbG90c0NhY2hlKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChjYWxsYmFjaykge1xuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFja3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNSZWZyZXNoaW5nKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc1JlZnJlc2hpbmcgPSB0cnVlO1xuICAgICAgICBjb25zdCBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHdyYXBwZXIgPSAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgIHRoaXMuaXNSZWZyZXNoaW5nID0gZmFsc2U7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGNhbGxiYWNrIG9mIHRoaXMuX3JlZnJlc2hTbG90c0NhY2hlQ2FsbGJhY2tzKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fcmVmcmVzaFNsb3RzQ2FjaGVDYWxsYmFja3MgPSBbXTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgbm9kZXMgPSAoMCwgdXRpbHNfMS5zaHVmZmxlKSh0aGlzLmNvbm5lY3Rpb25Qb29sLmdldE5vZGVzKCkpO1xuICAgICAgICBsZXQgbGFzdE5vZGVFcnJvciA9IG51bGw7XG4gICAgICAgIGZ1bmN0aW9uIHRyeU5vZGUoaW5kZXgpIHtcbiAgICAgICAgICAgIGlmIChpbmRleCA9PT0gbm9kZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBuZXcgQ2x1c3RlckFsbEZhaWxlZEVycm9yXzEuZGVmYXVsdChDbHVzdGVyQWxsRmFpbGVkRXJyb3JfMS5kZWZhdWx0LmRlZmF1bHRNZXNzYWdlLCBsYXN0Tm9kZUVycm9yKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlcihlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBub2RlID0gbm9kZXNbaW5kZXhdO1xuICAgICAgICAgICAgY29uc3Qga2V5ID0gYCR7bm9kZS5vcHRpb25zLmhvc3R9OiR7bm9kZS5vcHRpb25zLnBvcnR9YDtcbiAgICAgICAgICAgIGRlYnVnKFwiZ2V0dGluZyBzbG90IGNhY2hlIGZyb20gJXNcIiwga2V5KTtcbiAgICAgICAgICAgIF90aGlzLmdldEluZm9Gcm9tTm9kZShub2RlLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoIChfdGhpcy5zdGF0dXMpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FzZSBcImNsb3NlXCI6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJlbmRcIjpcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB3cmFwcGVyKG5ldyBFcnJvcihcIkNsdXN0ZXIgaXMgZGlzY29ubmVjdGVkLlwiKSk7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgXCJkaXNjb25uZWN0aW5nXCI6XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gd3JhcHBlcihuZXcgRXJyb3IoXCJDbHVzdGVyIGlzIGRpc2Nvbm5lY3RpbmcuXCIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KFwibm9kZSBlcnJvclwiLCBlcnIsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgIGxhc3ROb2RlRXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgICAgIHRyeU5vZGUoaW5kZXggKyAxKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoXCJyZWZyZXNoXCIpO1xuICAgICAgICAgICAgICAgICAgICB3cmFwcGVyKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5Tm9kZSgwKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQGlnbm9yZVxuICAgICAqL1xuICAgIHNlbmRDb21tYW5kKGNvbW1hbmQsIHN0cmVhbSwgbm9kZSkge1xuICAgICAgICBpZiAodGhpcy5zdGF0dXMgPT09IFwid2FpdFwiKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJlbmRcIikge1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICB9XG4gICAgICAgIGxldCB0byA9IHRoaXMub3B0aW9ucy5zY2FsZVJlYWRzO1xuICAgICAgICBpZiAodG8gIT09IFwibWFzdGVyXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzQ29tbWFuZFJlYWRPbmx5ID0gY29tbWFuZC5pc1JlYWRPbmx5IHx8XG4gICAgICAgICAgICAgICAgKCgwLCBjb21tYW5kc18xLmV4aXN0cykoY29tbWFuZC5uYW1lKSAmJiAoMCwgY29tbWFuZHNfMS5oYXNGbGFnKShjb21tYW5kLm5hbWUsIFwicmVhZG9ubHlcIikpO1xuICAgICAgICAgICAgaWYgKCFpc0NvbW1hbmRSZWFkT25seSkge1xuICAgICAgICAgICAgICAgIHRvID0gXCJtYXN0ZXJcIjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsZXQgdGFyZ2V0U2xvdCA9IG5vZGUgPyBub2RlLnNsb3QgOiBjb21tYW5kLmdldFNsb3QoKTtcbiAgICAgICAgY29uc3QgdHRsID0ge307XG4gICAgICAgIGNvbnN0IF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKCFub2RlICYmICFSRUpFQ1RfT1ZFUldSSVRURU5fQ09NTUFORFMuaGFzKGNvbW1hbmQpKSB7XG4gICAgICAgICAgICBSRUpFQ1RfT1ZFUldSSVRURU5fQ09NTUFORFMuYWRkKGNvbW1hbmQpO1xuICAgICAgICAgICAgY29uc3QgcmVqZWN0ID0gY29tbWFuZC5yZWplY3Q7XG4gICAgICAgICAgICBjb21tYW5kLnJlamVjdCA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJ0aWFsVHJ5ID0gdHJ5Q29ubmVjdGlvbi5iaW5kKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgIF90aGlzLmhhbmRsZUVycm9yKGVyciwgdHRsLCB7XG4gICAgICAgICAgICAgICAgICAgIG1vdmVkOiBmdW5jdGlvbiAoc2xvdCwga2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbW1hbmQgJXMgaXMgbW92ZWQgdG8gJXNcIiwgY29tbWFuZC5uYW1lLCBrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0U2xvdCA9IE51bWJlcihzbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zbG90c1tzbG90XSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNsb3RzW3Nsb3RdWzBdID0ga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2xvdHNbc2xvdF0gPSBba2V5XTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ncm91cHNCeVNsb3Rbc2xvdF0gPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLl9ncm91cHNJZHNbX3RoaXMuc2xvdHNbc2xvdF0uam9pbihcIjtcIildO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdGlvblBvb2wuZmluZE9yQ3JlYXRlKF90aGlzLm5hdE1hcHBlcihrZXkpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyeUNvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVmcmVzaGluZyBzbG90IGNhY2hlcy4uLiAodHJpZ2dlcmVkIGJ5IE1PVkVEIGVycm9yKVwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnJlZnJlc2hTbG90c0NhY2hlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGFzazogZnVuY3Rpb24gKHNsb3QsIGtleSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJjb21tYW5kICVzIGlzIHJlcXVpcmVkIHRvIGFzayAlczolc1wiLCBjb21tYW5kLm5hbWUsIGtleSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBtYXBwZWQgPSBfdGhpcy5uYXRNYXBwZXIoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25Qb29sLmZpbmRPckNyZWF0ZShtYXBwZWQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5Q29ubmVjdGlvbihmYWxzZSwgYCR7bWFwcGVkLmhvc3R9OiR7bWFwcGVkLnBvcnR9YCk7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIHRyeWFnYWluOiBwYXJ0aWFsVHJ5LFxuICAgICAgICAgICAgICAgICAgICBjbHVzdGVyRG93bjogcGFydGlhbFRyeSxcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbkNsb3NlZDogcGFydGlhbFRyeSxcbiAgICAgICAgICAgICAgICAgICAgbWF4UmVkaXJlY3Rpb25zOiBmdW5jdGlvbiAocmVkaXJlY3Rpb25FcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVqZWN0LmNhbGwoY29tbWFuZCwgcmVkaXJlY3Rpb25FcnJvcik7XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHRzOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZWplY3QuY2FsbChjb21tYW5kLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICB0cnlDb25uZWN0aW9uKCk7XG4gICAgICAgIGZ1bmN0aW9uIHRyeUNvbm5lY3Rpb24ocmFuZG9tLCBhc2tpbmcpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBjb21tYW5kLnJlamVjdChuZXcgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvcihcIkNsdXN0ZXIgaXMgZW5kZWQuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVkaXM7XG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdHVzID09PSBcInJlYWR5XCIgfHwgY29tbWFuZC5uYW1lID09PSBcImNsdXN0ZXJcIikge1xuICAgICAgICAgICAgICAgIGlmIChub2RlICYmIG5vZGUucmVkaXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBub2RlLnJlZGlzO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJFTlRFUl9TVUJTQ1JJQkVSX01PREVcIiwgY29tbWFuZC5uYW1lKSB8fFxuICAgICAgICAgICAgICAgICAgICBDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJFWElUX1NVQlNDUklCRVJfTU9ERVwiLCBjb21tYW5kLm5hbWUpKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5vcHRpb25zLnNoYXJkZWRTdWJzY3JpYmVycyA9PSB0cnVlICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoY29tbWFuZC5uYW1lID09IFwic3N1YnNjcmliZVwiIHx8IGNvbW1hbmQubmFtZSA9PSBcInN1bnN1YnNjcmliZVwiKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3ViID0gX3RoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmdldFJlc3BvbnNpYmxlU3Vic2NyaWJlcih0YXJnZXRTbG90KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxldCBzdGF0dXMgPSAtMTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT0gXCJzc3Vic2NyaWJlXCIpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzID0gX3RoaXMuc2hhcmRlZFN1YnNjcmliZXJzLmFkZENoYW5uZWxzKGNvbW1hbmQuZ2V0S2V5cygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT0gXCJzdW5zdWJzY3JpYmVcIilcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0dXMgPSBfdGhpcy5zaGFyZGVkU3Vic2NyaWJlcnMucmVtb3ZlQ2hhbm5lbHMoY29tbWFuZC5nZXRLZXlzKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXR1cyAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9IHN1Yi5nZXRJbnN0YW5jZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IHJlZGlzX2Vycm9yc18xLkFib3J0RXJyb3IoXCJDYW4ndCBhZGQgb3IgcmVtb3ZlIHRoZSBnaXZlbiBjaGFubmVscy4gQXJlIHRoZXkgaW4gdGhlIHNhbWUgc2xvdD9cIikpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBfdGhpcy5zdWJzY3JpYmVyLmdldEluc3RhbmNlKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IHJlZGlzX2Vycm9yc18xLkFib3J0RXJyb3IoXCJObyBzdWJzY3JpYmVyIGZvciB0aGUgY2x1c3RlclwiKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghcmFuZG9tKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIHRhcmdldFNsb3QgPT09IFwibnVtYmVyXCIgJiYgX3RoaXMuc2xvdHNbdGFyZ2V0U2xvdF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlS2V5cyA9IF90aGlzLnNsb3RzW3RhcmdldFNsb3RdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgdG8gPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlcyA9IG5vZGVLZXlzLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuY29ubmVjdGlvblBvb2wuZ2V0SW5zdGFuY2VCeUtleShrZXkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSB0byhub2RlcywgY29tbWFuZCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHJlZGlzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSAoMCwgdXRpbHNfMS5zYW1wbGUpKHJlZGlzKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIXJlZGlzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9IG5vZGVzWzBdO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQga2V5O1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodG8gPT09IFwiYWxsXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGtleSA9ICgwLCB1dGlsc18xLnNhbXBsZSkobm9kZUtleXMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRvID09PSBcInNsYXZlXCIgJiYgbm9kZUtleXMubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gKDAsIHV0aWxzXzEuc2FtcGxlKShub2RlS2V5cywgMSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXkgPSBub2RlS2V5c1swXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWRpcyA9IF90aGlzLmNvbm5lY3Rpb25Qb29sLmdldEluc3RhbmNlQnlLZXkoa2V5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYXNraW5nKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPSBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRJbnN0YW5jZUJ5S2V5KGFza2luZyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMuYXNraW5nKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZWRpcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVkaXMgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICh0eXBlb2YgdG8gPT09IFwiZnVuY3Rpb25cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA/IG51bGxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdGhpcy5jb25uZWN0aW9uUG9vbC5nZXRTYW1wbGVJbnN0YW5jZSh0bykpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3Rpb25Qb29sLmdldFNhbXBsZUluc3RhbmNlKFwiYWxsXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChub2RlICYmICFub2RlLnJlZGlzKSB7XG4gICAgICAgICAgICAgICAgICAgIG5vZGUucmVkaXMgPSByZWRpcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVkaXMpIHtcbiAgICAgICAgICAgICAgICByZWRpcy5zZW5kQ29tbWFuZChjb21tYW5kLCBzdHJlYW0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoX3RoaXMub3B0aW9ucy5lbmFibGVPZmZsaW5lUXVldWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZsaW5lUXVldWUucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGNvbW1hbmQ6IGNvbW1hbmQsXG4gICAgICAgICAgICAgICAgICAgIHN0cmVhbTogc3RyZWFtLFxuICAgICAgICAgICAgICAgICAgICBub2RlOiBub2RlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKFwiQ2x1c3RlciBpc24ndCByZWFkeSBhbmQgZW5hYmxlT2ZmbGluZVF1ZXVlIG9wdGlvbnMgaXMgZmFsc2VcIikpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjb21tYW5kLnByb21pc2U7XG4gICAgfVxuICAgIHNzY2FuU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwic3NjYW5cIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHNzY2FuQnVmZmVyU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwic3NjYW5CdWZmZXJcIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIGhzY2FuU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwiaHNjYW5cIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIGhzY2FuQnVmZmVyU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwiaHNjYW5CdWZmZXJcIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHpzY2FuU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwienNjYW5cIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIHpzY2FuQnVmZmVyU3RyZWFtKGtleSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gdGhpcy5jcmVhdGVTY2FuU3RyZWFtKFwienNjYW5CdWZmZXJcIiwgeyBrZXksIG9wdGlvbnMgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBoYW5kbGVFcnJvcihlcnJvciwgdHRsLCBoYW5kbGVycykge1xuICAgICAgICBpZiAodHlwZW9mIHR0bC52YWx1ZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgdHRsLnZhbHVlID0gdGhpcy5vcHRpb25zLm1heFJlZGlyZWN0aW9ucztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHR0bC52YWx1ZSAtPSAxO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0dGwudmFsdWUgPD0gMCkge1xuICAgICAgICAgICAgaGFuZGxlcnMubWF4UmVkaXJlY3Rpb25zKG5ldyBFcnJvcihcIlRvbyBtYW55IENsdXN0ZXIgcmVkaXJlY3Rpb25zLiBMYXN0IGVycm9yOiBcIiArIGVycm9yKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZXJydiA9IGVycm9yLm1lc3NhZ2Uuc3BsaXQoXCIgXCIpO1xuICAgICAgICBpZiAoZXJydlswXSA9PT0gXCJNT1ZFRFwiKSB7XG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gdGhpcy5vcHRpb25zLnJldHJ5RGVsYXlPbk1vdmVkO1xuICAgICAgICAgICAgaWYgKHRpbWVvdXQgJiYgdHlwZW9mIHRpbWVvdXQgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRlbGF5UXVldWUucHVzaChcIm1vdmVkXCIsIGhhbmRsZXJzLm1vdmVkLmJpbmQobnVsbCwgZXJydlsxXSwgZXJydlsyXSksIHsgdGltZW91dCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJzLm1vdmVkKGVycnZbMV0sIGVycnZbMl0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGVycnZbMF0gPT09IFwiQVNLXCIpIHtcbiAgICAgICAgICAgIGhhbmRsZXJzLmFzayhlcnJ2WzFdLCBlcnJ2WzJdKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJ2WzBdID09PSBcIlRSWUFHQUlOXCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlRdWV1ZS5wdXNoKFwidHJ5YWdhaW5cIiwgaGFuZGxlcnMudHJ5YWdhaW4sIHtcbiAgICAgICAgICAgICAgICB0aW1lb3V0OiB0aGlzLm9wdGlvbnMucmV0cnlEZWxheU9uVHJ5QWdhaW4sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnJ2WzBdID09PSBcIkNMVVNURVJET1dOXCIgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25DbHVzdGVyRG93biA+IDApIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlRdWV1ZS5wdXNoKFwiY2x1c3RlcmRvd25cIiwgaGFuZGxlcnMuY29ubmVjdGlvbkNsb3NlZCwge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25DbHVzdGVyRG93bixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogdGhpcy5yZWZyZXNoU2xvdHNDYWNoZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyb3IubWVzc2FnZSA9PT0gdXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgJiZcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25GYWlsb3ZlciA+IDAgJiZcbiAgICAgICAgICAgIHRoaXMuc3RhdHVzID09PSBcInJlYWR5XCIpIHtcbiAgICAgICAgICAgIHRoaXMuZGVsYXlRdWV1ZS5wdXNoKFwiZmFpbG92ZXJcIiwgaGFuZGxlcnMuY29ubmVjdGlvbkNsb3NlZCwge1xuICAgICAgICAgICAgICAgIHRpbWVvdXQ6IHRoaXMub3B0aW9ucy5yZXRyeURlbGF5T25GYWlsb3ZlcixcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogdGhpcy5yZWZyZXNoU2xvdHNDYWNoZS5iaW5kKHRoaXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBoYW5kbGVycy5kZWZhdWx0cygpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJlc2V0T2ZmbGluZVF1ZXVlKCkge1xuICAgICAgICB0aGlzLm9mZmxpbmVRdWV1ZSA9IG5ldyBEZXF1ZSgpO1xuICAgIH1cbiAgICBjbGVhck5vZGVzUmVmcmVzaEludGVydmFsKCkge1xuICAgICAgICBpZiAodGhpcy5zbG90c1RpbWVyKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5zbG90c1RpbWVyKTtcbiAgICAgICAgICAgIHRoaXMuc2xvdHNUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmVzZXROb2Rlc1JlZnJlc2hJbnRlcnZhbCgpIHtcbiAgICAgICAgaWYgKHRoaXMuc2xvdHNUaW1lciB8fCAhdGhpcy5vcHRpb25zLnNsb3RzUmVmcmVzaEludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbmV4dFJvdW5kID0gKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zbG90c1RpbWVyID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoJ3JlZnJlc2hpbmcgc2xvdCBjYWNoZXMuLi4gKHRyaWdnZXJlZCBieSBcInNsb3RzUmVmcmVzaEludGVydmFsXCIgb3B0aW9uKScpO1xuICAgICAgICAgICAgICAgIHRoaXMucmVmcmVzaFNsb3RzQ2FjaGUoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICBuZXh0Um91bmQoKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sIHRoaXMub3B0aW9ucy5zbG90c1JlZnJlc2hJbnRlcnZhbCk7XG4gICAgICAgIH07XG4gICAgICAgIG5leHRSb3VuZCgpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGFuZ2UgY2x1c3RlciBpbnN0YW5jZSdzIHN0YXR1c1xuICAgICAqL1xuICAgIHNldFN0YXR1cyhzdGF0dXMpIHtcbiAgICAgICAgZGVidWcoXCJzdGF0dXM6ICVzIC0+ICVzXCIsIHRoaXMuc3RhdHVzIHx8IFwiW2VtcHR5XVwiLCBzdGF0dXMpO1xuICAgICAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICAgICAgcHJvY2Vzcy5uZXh0VGljaygoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmVtaXQoc3RhdHVzKTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGNsb3NlZCB0byBjaGVjayB3aGV0aGVyIGEgcmVjb25uZWN0aW9uIHNob3VsZCBiZSBtYWRlXG4gICAgICovXG4gICAgaGFuZGxlQ2xvc2VFdmVudChyZWFzb24pIHtcbiAgICAgICAgaWYgKHJlYXNvbikge1xuICAgICAgICAgICAgZGVidWcoXCJjbG9zZWQgYmVjYXVzZSAlc1wiLCByZWFzb24pO1xuICAgICAgICB9XG4gICAgICAgIGxldCByZXRyeURlbGF5O1xuICAgICAgICBpZiAoIXRoaXMubWFudWFsbHlDbG9zaW5nICYmXG4gICAgICAgICAgICB0eXBlb2YgdGhpcy5vcHRpb25zLmNsdXN0ZXJSZXRyeVN0cmF0ZWd5ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIHJldHJ5RGVsYXkgPSB0aGlzLm9wdGlvbnMuY2x1c3RlclJldHJ5U3RyYXRlZ3kuY2FsbCh0aGlzLCArK3RoaXMucmV0cnlBdHRlbXB0cywgcmVhc29uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHJldHJ5RGVsYXkgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwicmVjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWNvbm5lY3RUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkNsdXN0ZXIgaXMgZGlzY29ubmVjdGVkLiBSZXRyeWluZyBhZnRlciAlZG1zXCIsIHJldHJ5RGVsYXkpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdCgpLmNhdGNoKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJHb3QgZXJyb3IgJXMgd2hlbiByZWNvbm5lY3RpbmcuIElnbm9yaW5nLi4uXCIsIGVycik7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9LCByZXRyeURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdHVzKFwiZW5kXCIpO1xuICAgICAgICAgICAgdGhpcy5mbHVzaFF1ZXVlKG5ldyBFcnJvcihcIk5vbmUgb2Ygc3RhcnR1cCBub2RlcyBpcyBhdmFpbGFibGVcIikpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEZsdXNoIG9mZmxpbmUgcXVldWUgd2l0aCBlcnJvci5cbiAgICAgKi9cbiAgICBmbHVzaFF1ZXVlKGVycm9yKSB7XG4gICAgICAgIGxldCBpdGVtO1xuICAgICAgICB3aGlsZSAoKGl0ZW0gPSB0aGlzLm9mZmxpbmVRdWV1ZS5zaGlmdCgpKSkge1xuICAgICAgICAgICAgaXRlbS5jb21tYW5kLnJlamVjdChlcnJvcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZXhlY3V0ZU9mZmxpbmVDb21tYW5kcygpIHtcbiAgICAgICAgaWYgKHRoaXMub2ZmbGluZVF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgZGVidWcoXCJzZW5kICVkIGNvbW1hbmRzIGluIG9mZmxpbmUgcXVldWVcIiwgdGhpcy5vZmZsaW5lUXVldWUubGVuZ3RoKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmxpbmVRdWV1ZSA9IHRoaXMub2ZmbGluZVF1ZXVlO1xuICAgICAgICAgICAgdGhpcy5yZXNldE9mZmxpbmVRdWV1ZSgpO1xuICAgICAgICAgICAgbGV0IGl0ZW07XG4gICAgICAgICAgICB3aGlsZSAoKGl0ZW0gPSBvZmZsaW5lUXVldWUuc2hpZnQoKSkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRDb21tYW5kKGl0ZW0uY29tbWFuZCwgaXRlbS5zdHJlYW0sIGl0ZW0ubm9kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF0TWFwcGVyKG5vZGVLZXkpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdHlwZW9mIG5vZGVLZXkgPT09IFwic3RyaW5nXCJcbiAgICAgICAgICAgID8gbm9kZUtleVxuICAgICAgICAgICAgOiBgJHtub2RlS2V5Lmhvc3R9OiR7bm9kZUtleS5wb3J0fWA7XG4gICAgICAgIGxldCBtYXBwZWQgPSBudWxsO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLm5hdE1hcCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm5hdE1hcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBtYXBwZWQgPSB0aGlzLm9wdGlvbnMubmF0TWFwKGtleSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy5vcHRpb25zLm5hdE1hcCAmJiB0eXBlb2YgdGhpcy5vcHRpb25zLm5hdE1hcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgbWFwcGVkID0gdGhpcy5vcHRpb25zLm5hdE1hcFtrZXldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtYXBwZWQpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiTkFUIG1hcHBpbmcgJXMgLT4gJU9cIiwga2V5LCBtYXBwZWQpO1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oe30sIG1hcHBlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHR5cGVvZiBub2RlS2V5ID09PSBcInN0cmluZ1wiXG4gICAgICAgICAgICA/ICgwLCB1dGlsXzEubm9kZUtleVRvUmVkaXNPcHRpb25zKShub2RlS2V5KVxuICAgICAgICAgICAgOiBub2RlS2V5O1xuICAgIH1cbiAgICBnZXRJbmZvRnJvbU5vZGUocmVkaXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghcmVkaXMpIHtcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhuZXcgRXJyb3IoXCJOb2RlIGlzIGRpc2Nvbm5lY3RlZFwiKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVXNlIGEgZHVwbGljYXRpb24gb2YgdGhlIGNvbm5lY3Rpb24gdG8gYXZvaWRcbiAgICAgICAgLy8gdGltZW91dHMgd2hlbiB0aGUgY29ubmVjdGlvbiBpcyBpbiB0aGUgYmxvY2tpbmdcbiAgICAgICAgLy8gbW9kZSAoZS5nLiB3YWl0aW5nIGZvciBCTFBPUCkuXG4gICAgICAgIGNvbnN0IGR1cGxpY2F0ZWRDb25uZWN0aW9uID0gcmVkaXMuZHVwbGljYXRlKHtcbiAgICAgICAgICAgIGVuYWJsZU9mZmxpbmVRdWV1ZTogdHJ1ZSxcbiAgICAgICAgICAgIGVuYWJsZVJlYWR5Q2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgcmV0cnlTdHJhdGVneTogbnVsbCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25OYW1lOiAoMCwgdXRpbF8xLmdldENvbm5lY3Rpb25OYW1lKShcInJlZnJlc2hlclwiLCB0aGlzLm9wdGlvbnMucmVkaXNPcHRpb25zICYmIHRoaXMub3B0aW9ucy5yZWRpc09wdGlvbnMuY29ubmVjdGlvbk5hbWUpLFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gSWdub3JlIGVycm9yIGV2ZW50cyBzaW5jZSB3ZSB3aWxsIGhhbmRsZVxuICAgICAgICAvLyBleGNlcHRpb25zIGZvciB0aGUgQ0xVU1RFUiBTTE9UUyBjb21tYW5kLlxuICAgICAgICBkdXBsaWNhdGVkQ29ubmVjdGlvbi5vbihcImVycm9yXCIsIHV0aWxzXzEubm9vcCk7XG4gICAgICAgIGR1cGxpY2F0ZWRDb25uZWN0aW9uLmNsdXN0ZXIoXCJTTE9UU1wiLCAoMCwgdXRpbHNfMS50aW1lb3V0KSgoZXJyLCByZXN1bHQpID0+IHtcbiAgICAgICAgICAgIGR1cGxpY2F0ZWRDb25uZWN0aW9uLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImVycm9yIGVuY291bnRlcmVkIHJ1bm5pbmcgQ0xVU1RFUi5TTE9UUzogJXNcIiwgZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXR1cyA9PT0gXCJkaXNjb25uZWN0aW5nXCIgfHxcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXR1cyA9PT0gXCJjbG9zZVwiIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0dXMgPT09IFwiZW5kXCIpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcImlnbm9yZSBDTFVTVEVSLlNMT1RTIHJlc3VsdHMgKGNvdW50OiAlZCkgc2luY2UgY2x1c3RlciBzdGF0dXMgaXMgJXNcIiwgcmVzdWx0Lmxlbmd0aCwgdGhpcy5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3Qgbm9kZXMgPSBbXTtcbiAgICAgICAgICAgIGRlYnVnKFwiY2x1c3RlciBzbG90cyByZXN1bHQgY291bnQ6ICVkXCIsIHJlc3VsdC5sZW5ndGgpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCByZXN1bHQubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBpdGVtcyA9IHJlc3VsdFtpXTtcbiAgICAgICAgICAgICAgICBjb25zdCBzbG90UmFuZ2VTdGFydCA9IGl0ZW1zWzBdO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsb3RSYW5nZUVuZCA9IGl0ZW1zWzFdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGtleXMgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKGxldCBqID0gMjsgaiA8IGl0ZW1zLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghaXRlbXNbal1bMF0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSB0aGlzLm5hdE1hcHBlcih7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBpdGVtc1tqXVswXSxcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcnQ6IGl0ZW1zW2pdWzFdLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgbm9kZS5yZWFkT25seSA9IGogIT09IDI7XG4gICAgICAgICAgICAgICAgICAgIG5vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgICAgIGtleXMucHVzaChub2RlLmhvc3QgKyBcIjpcIiArIG5vZGUucG9ydCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKFwiY2x1c3RlciBzbG90cyByZXN1bHQgWyVkXTogc2xvdHMgJWR+JWQgc2VydmVkIGJ5ICVzXCIsIGksIHNsb3RSYW5nZVN0YXJ0LCBzbG90UmFuZ2VFbmQsIGtleXMpO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IHNsb3QgPSBzbG90UmFuZ2VTdGFydDsgc2xvdCA8PSBzbG90UmFuZ2VFbmQ7IHNsb3QrKykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNsb3RzW3Nsb3RdID0ga2V5cztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBBc3NpZ24gdG8gZWFjaCBub2RlIGtleXMgYSBudW1lcmljIHZhbHVlIHRvIG1ha2UgYXV0b3BpcGVsaW5lIGNvbXBhcmlzb24gZmFzdGVyLlxuICAgICAgICAgICAgdGhpcy5fZ3JvdXBzSWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgICAgIGxldCBqID0gMDtcbiAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMTYzODQ7IGkrKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHRhcmdldCA9ICh0aGlzLnNsb3RzW2ldIHx8IFtdKS5qb2luKFwiO1wiKTtcbiAgICAgICAgICAgICAgICBpZiAoIXRhcmdldC5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzQnlTbG90W2ldID0gdW5kZWZpbmVkO1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLl9ncm91cHNJZHNbdGFyZ2V0XSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9ncm91cHNJZHNbdGFyZ2V0XSA9ICsrajtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5fZ3JvdXBzQnlTbG90W2ldID0gdGhpcy5fZ3JvdXBzSWRzW3RhcmdldF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25Qb29sLnJlc2V0KG5vZGVzKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy5zbG90c1JlZnJlc2hUaW1lb3V0KSk7XG4gICAgfVxuICAgIGludm9rZVJlYWR5RGVsYXllZENhbGxiYWNrcyhlcnIpIHtcbiAgICAgICAgZm9yIChjb25zdCBjIG9mIHRoaXMuX3JlYWR5RGVsYXllZENhbGxiYWNrcykge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhjLCBlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlYWR5RGVsYXllZENhbGxiYWNrcyA9IFtdO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDaGVjayB3aGV0aGVyIENsdXN0ZXIgaXMgYWJsZSB0byBwcm9jZXNzIGNvbW1hbmRzXG4gICAgICovXG4gICAgcmVhZHlDaGVjayhjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNsdXN0ZXIoXCJJTkZPXCIsIChlcnIsIHJlcykgPT4ge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHR5cGVvZiByZXMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxldCBzdGF0ZTtcbiAgICAgICAgICAgIGNvbnN0IGxpbmVzID0gcmVzLnNwbGl0KFwiXFxyXFxuXCIpO1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsaW5lcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHBhcnRzID0gbGluZXNbaV0uc3BsaXQoXCI6XCIpO1xuICAgICAgICAgICAgICAgIGlmIChwYXJ0c1swXSA9PT0gXCJjbHVzdGVyX3N0YXRlXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGUgPSBwYXJ0c1sxXTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHN0YXRlID09PSBcImZhaWxcIikge1xuICAgICAgICAgICAgICAgIGRlYnVnKFwiY2x1c3RlciBzdGF0ZSBub3Qgb2sgKCVzKVwiLCBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgc3RhdGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJlc29sdmVTcnYoaG9zdG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucy5yZXNvbHZlU3J2KGhvc3RuYW1lLCAoZXJyLCByZWNvcmRzKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGYgPSB0aGlzLCBncm91cGVkUmVjb3JkcyA9ICgwLCB1dGlsXzEuZ3JvdXBTcnZSZWNvcmRzKShyZWNvcmRzKSwgc29ydGVkS2V5cyA9IE9iamVjdC5rZXlzKGdyb3VwZWRSZWNvcmRzKS5zb3J0KChhLCBiKSA9PiBwYXJzZUludChhKSAtIHBhcnNlSW50KGIpKTtcbiAgICAgICAgICAgICAgICBmdW5jdGlvbiB0cnlGaXJzdE9uZShlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFzb3J0ZWRLZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGtleSA9IHNvcnRlZEtleXNbMF0sIGdyb3VwID0gZ3JvdXBlZFJlY29yZHNba2V5XSwgcmVjb3JkID0gKDAsIHV0aWxfMS53ZWlnaHRTcnZSZWNvcmRzKShncm91cCk7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZ3JvdXAucmVjb3Jkcy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNvcnRlZEtleXMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmRuc0xvb2t1cChyZWNvcmQubmFtZSkudGhlbigoaG9zdCkgPT4gcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICBob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgcG9ydDogcmVjb3JkLnBvcnQsXG4gICAgICAgICAgICAgICAgICAgIH0pLCB0cnlGaXJzdE9uZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRyeUZpcnN0T25lKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGRuc0xvb2t1cChob3N0bmFtZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLmRuc0xvb2t1cChob3N0bmFtZSwgKGVyciwgYWRkcmVzcykgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZGVidWcoXCJmYWlsZWQgdG8gcmVzb2x2ZSBob3N0bmFtZSAlcyB0byBJUDogJXNcIiwgaG9zdG5hbWUsIGVyci5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgcmVqZWN0KGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlc29sdmVkIGhvc3RuYW1lICVzIHRvIElQICVzXCIsIGhvc3RuYW1lLCBhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShhZGRyZXNzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE5vcm1hbGl6ZSBzdGFydHVwIG5vZGVzLCBhbmQgcmVzb2x2aW5nIGhvc3RuYW1lcyB0byBJUHMuXG4gICAgICpcbiAgICAgKiBUaGlzIHByb2Nlc3MgaGFwcGVucyBldmVyeSB0aW1lIHdoZW4gI2Nvbm5lY3QoKSBpcyBjYWxsZWQgc2luY2VcbiAgICAgKiAjc3RhcnR1cE5vZGVzIGFuZCBETlMgcmVjb3JkcyBtYXkgY2hhbmFnZS5cbiAgICAgKi9cbiAgICBhc3luYyByZXNvbHZlU3RhcnR1cE5vZGVIb3N0bmFtZXMoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0aGlzLnN0YXJ0dXBOb2RlcykgfHwgdGhpcy5zdGFydHVwTm9kZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJgc3RhcnR1cE5vZGVzYCBzaG91bGQgY29udGFpbiBhdCBsZWFzdCBvbmUgbm9kZS5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc3RhcnR1cE5vZGVzID0gKDAsIHV0aWxfMS5ub3JtYWxpemVOb2RlT3B0aW9ucykodGhpcy5zdGFydHVwTm9kZXMpO1xuICAgICAgICBjb25zdCBob3N0bmFtZXMgPSAoMCwgdXRpbF8xLmdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zKShzdGFydHVwTm9kZXMpO1xuICAgICAgICBpZiAoaG9zdG5hbWVzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgcmV0dXJuIHN0YXJ0dXBOb2RlcztcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBjb25maWdzID0gYXdhaXQgUHJvbWlzZS5hbGwoaG9zdG5hbWVzLm1hcCgodGhpcy5vcHRpb25zLnVzZVNSVlJlY29yZHMgPyB0aGlzLnJlc29sdmVTcnYgOiB0aGlzLmRuc0xvb2t1cCkuYmluZCh0aGlzKSkpO1xuICAgICAgICBjb25zdCBob3N0bmFtZVRvQ29uZmlnID0gKDAsIHV0aWxzXzEuemlwTWFwKShob3N0bmFtZXMsIGNvbmZpZ3MpO1xuICAgICAgICByZXR1cm4gc3RhcnR1cE5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgY29uZmlnID0gaG9zdG5hbWVUb0NvbmZpZy5nZXQobm9kZS5ob3N0KTtcbiAgICAgICAgICAgIGlmICghY29uZmlnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodGhpcy5vcHRpb25zLnVzZVNSVlJlY29yZHMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbih7fSwgbm9kZSwgY29uZmlnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBub2RlLCB7IGhvc3Q6IGNvbmZpZyB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGNyZWF0ZVNjYW5TdHJlYW0oY29tbWFuZCwgeyBrZXksIG9wdGlvbnMgPSB7fSB9KSB7XG4gICAgICAgIHJldHVybiBuZXcgU2NhblN0cmVhbV8xLmRlZmF1bHQoe1xuICAgICAgICAgICAgb2JqZWN0TW9kZTogdHJ1ZSxcbiAgICAgICAgICAgIGtleToga2V5LFxuICAgICAgICAgICAgcmVkaXM6IHRoaXMsXG4gICAgICAgICAgICBjb21tYW5kOiBjb21tYW5kLFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgfSk7XG4gICAgfVxufVxuKDAsIGFwcGx5TWl4aW5fMS5kZWZhdWx0KShDbHVzdGVyLCBldmVudHNfMS5FdmVudEVtaXR0ZXIpO1xuKDAsIHRyYW5zYWN0aW9uXzEuYWRkVHJhbnNhY3Rpb25TdXBwb3J0KShDbHVzdGVyLnByb3RvdHlwZSk7XG5leHBvcnRzLmRlZmF1bHQgPSBDbHVzdGVyO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.getConnectionName = exports.weightSrvRecords = exports.groupSrvRecords = exports.getUniqueHostnamesFromOptions = exports.normalizeNodeOptions = exports.nodeKeyToRedisOptions = exports.getNodeKey = void 0;\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nfunction getNodeKey(node) {\n    node.port = node.port || 6379;\n    node.host = node.host || \"127.0.0.1\";\n    return node.host + \":\" + node.port;\n}\nexports.getNodeKey = getNodeKey;\nfunction nodeKeyToRedisOptions(nodeKey) {\n    const portIndex = nodeKey.lastIndexOf(\":\");\n    if (portIndex === -1) {\n        throw new Error(`Invalid node key ${nodeKey}`);\n    }\n    return {\n        host: nodeKey.slice(0, portIndex),\n        port: Number(nodeKey.slice(portIndex + 1)),\n    };\n}\nexports.nodeKeyToRedisOptions = nodeKeyToRedisOptions;\nfunction normalizeNodeOptions(nodes) {\n    return nodes.map((node) => {\n        const options = {};\n        if (typeof node === \"object\") {\n            Object.assign(options, node);\n        }\n        else if (typeof node === \"string\") {\n            Object.assign(options, (0, utils_1.parseURL)(node));\n        }\n        else if (typeof node === \"number\") {\n            options.port = node;\n        }\n        else {\n            throw new Error(\"Invalid argument \" + node);\n        }\n        if (typeof options.port === \"string\") {\n            options.port = parseInt(options.port, 10);\n        }\n        // Cluster mode only support db 0\n        delete options.db;\n        if (!options.port) {\n            options.port = 6379;\n        }\n        if (!options.host) {\n            options.host = \"127.0.0.1\";\n        }\n        return (0, utils_1.resolveTLSProfile)(options);\n    });\n}\nexports.normalizeNodeOptions = normalizeNodeOptions;\nfunction getUniqueHostnamesFromOptions(nodes) {\n    const uniqueHostsMap = {};\n    nodes.forEach((node) => {\n        uniqueHostsMap[node.host] = true;\n    });\n    return Object.keys(uniqueHostsMap).filter((host) => !(0, net_1.isIP)(host));\n}\nexports.getUniqueHostnamesFromOptions = getUniqueHostnamesFromOptions;\nfunction groupSrvRecords(records) {\n    const recordsByPriority = {};\n    for (const record of records) {\n        if (!recordsByPriority.hasOwnProperty(record.priority)) {\n            recordsByPriority[record.priority] = {\n                totalWeight: record.weight,\n                records: [record],\n            };\n        }\n        else {\n            recordsByPriority[record.priority].totalWeight += record.weight;\n            recordsByPriority[record.priority].records.push(record);\n        }\n    }\n    return recordsByPriority;\n}\nexports.groupSrvRecords = groupSrvRecords;\nfunction weightSrvRecords(recordsGroup) {\n    if (recordsGroup.records.length === 1) {\n        recordsGroup.totalWeight = 0;\n        return recordsGroup.records.shift();\n    }\n    // + `recordsGroup.records.length` to support `weight` 0\n    const random = Math.floor(Math.random() * (recordsGroup.totalWeight + recordsGroup.records.length));\n    let total = 0;\n    for (const [i, record] of recordsGroup.records.entries()) {\n        total += 1 + record.weight;\n        if (total > random) {\n            recordsGroup.totalWeight -= record.weight;\n            recordsGroup.records.splice(i, 1);\n            return record;\n        }\n    }\n}\nexports.weightSrvRecords = weightSrvRecords;\nfunction getConnectionName(component, nodeConnectionName) {\n    const prefix = `ioredis-cluster(${component})`;\n    return nodeConnectionName ? `${prefix}:${nodeConnectionName}` : prefix;\n}\nexports.getConnectionName = getConnectionName;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY2x1c3Rlci91dGlsLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHlCQUF5QixHQUFHLHdCQUF3QixHQUFHLHVCQUF1QixHQUFHLHFDQUFxQyxHQUFHLDRCQUE0QixHQUFHLDZCQUE2QixHQUFHLGtCQUFrQjtBQUMxTSxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBVTtBQUNsQyxjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBLHNDQUFzQyxVQUFVO0FBQ2hELG1DQUFtQyxPQUFPLEdBQUcsbUJBQW1CO0FBQ2hFO0FBQ0EseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jbHVzdGVyL3V0aWwuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldENvbm5lY3Rpb25OYW1lID0gZXhwb3J0cy53ZWlnaHRTcnZSZWNvcmRzID0gZXhwb3J0cy5ncm91cFNydlJlY29yZHMgPSBleHBvcnRzLmdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zID0gZXhwb3J0cy5ub3JtYWxpemVOb2RlT3B0aW9ucyA9IGV4cG9ydHMubm9kZUtleVRvUmVkaXNPcHRpb25zID0gZXhwb3J0cy5nZXROb2RlS2V5ID0gdm9pZCAwO1xuY29uc3QgdXRpbHNfMSA9IHJlcXVpcmUoXCIuLi91dGlsc1wiKTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmZ1bmN0aW9uIGdldE5vZGVLZXkobm9kZSkge1xuICAgIG5vZGUucG9ydCA9IG5vZGUucG9ydCB8fCA2Mzc5O1xuICAgIG5vZGUuaG9zdCA9IG5vZGUuaG9zdCB8fCBcIjEyNy4wLjAuMVwiO1xuICAgIHJldHVybiBub2RlLmhvc3QgKyBcIjpcIiArIG5vZGUucG9ydDtcbn1cbmV4cG9ydHMuZ2V0Tm9kZUtleSA9IGdldE5vZGVLZXk7XG5mdW5jdGlvbiBub2RlS2V5VG9SZWRpc09wdGlvbnMobm9kZUtleSkge1xuICAgIGNvbnN0IHBvcnRJbmRleCA9IG5vZGVLZXkubGFzdEluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChwb3J0SW5kZXggPT09IC0xKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBub2RlIGtleSAke25vZGVLZXl9YCk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGhvc3Q6IG5vZGVLZXkuc2xpY2UoMCwgcG9ydEluZGV4KSxcbiAgICAgICAgcG9ydDogTnVtYmVyKG5vZGVLZXkuc2xpY2UocG9ydEluZGV4ICsgMSkpLFxuICAgIH07XG59XG5leHBvcnRzLm5vZGVLZXlUb1JlZGlzT3B0aW9ucyA9IG5vZGVLZXlUb1JlZGlzT3B0aW9ucztcbmZ1bmN0aW9uIG5vcm1hbGl6ZU5vZGVPcHRpb25zKG5vZGVzKSB7XG4gICAgcmV0dXJuIG5vZGVzLm1hcCgobm9kZSkgPT4ge1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge307XG4gICAgICAgIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCBub2RlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2Ygbm9kZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihvcHRpb25zLCAoMCwgdXRpbHNfMS5wYXJzZVVSTCkobm9kZSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBub2RlID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBub2RlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBhcmd1bWVudCBcIiArIG5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucy5wb3J0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSBwYXJzZUludChvcHRpb25zLnBvcnQsIDEwKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDbHVzdGVyIG1vZGUgb25seSBzdXBwb3J0IGRiIDBcbiAgICAgICAgZGVsZXRlIG9wdGlvbnMuZGI7XG4gICAgICAgIGlmICghb3B0aW9ucy5wb3J0KSB7XG4gICAgICAgICAgICBvcHRpb25zLnBvcnQgPSA2Mzc5O1xuICAgICAgICB9XG4gICAgICAgIGlmICghb3B0aW9ucy5ob3N0KSB7XG4gICAgICAgICAgICBvcHRpb25zLmhvc3QgPSBcIjEyNy4wLjAuMVwiO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS5yZXNvbHZlVExTUHJvZmlsZSkob3B0aW9ucyk7XG4gICAgfSk7XG59XG5leHBvcnRzLm5vcm1hbGl6ZU5vZGVPcHRpb25zID0gbm9ybWFsaXplTm9kZU9wdGlvbnM7XG5mdW5jdGlvbiBnZXRVbmlxdWVIb3N0bmFtZXNGcm9tT3B0aW9ucyhub2Rlcykge1xuICAgIGNvbnN0IHVuaXF1ZUhvc3RzTWFwID0ge307XG4gICAgbm9kZXMuZm9yRWFjaCgobm9kZSkgPT4ge1xuICAgICAgICB1bmlxdWVIb3N0c01hcFtub2RlLmhvc3RdID0gdHJ1ZTtcbiAgICB9KTtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModW5pcXVlSG9zdHNNYXApLmZpbHRlcigoaG9zdCkgPT4gISgwLCBuZXRfMS5pc0lQKShob3N0KSk7XG59XG5leHBvcnRzLmdldFVuaXF1ZUhvc3RuYW1lc0Zyb21PcHRpb25zID0gZ2V0VW5pcXVlSG9zdG5hbWVzRnJvbU9wdGlvbnM7XG5mdW5jdGlvbiBncm91cFNydlJlY29yZHMocmVjb3Jkcykge1xuICAgIGNvbnN0IHJlY29yZHNCeVByaW9yaXR5ID0ge307XG4gICAgZm9yIChjb25zdCByZWNvcmQgb2YgcmVjb3Jkcykge1xuICAgICAgICBpZiAoIXJlY29yZHNCeVByaW9yaXR5Lmhhc093blByb3BlcnR5KHJlY29yZC5wcmlvcml0eSkpIHtcbiAgICAgICAgICAgIHJlY29yZHNCeVByaW9yaXR5W3JlY29yZC5wcmlvcml0eV0gPSB7XG4gICAgICAgICAgICAgICAgdG90YWxXZWlnaHQ6IHJlY29yZC53ZWlnaHQsXG4gICAgICAgICAgICAgICAgcmVjb3JkczogW3JlY29yZF0sXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVjb3Jkc0J5UHJpb3JpdHlbcmVjb3JkLnByaW9yaXR5XS50b3RhbFdlaWdodCArPSByZWNvcmQud2VpZ2h0O1xuICAgICAgICAgICAgcmVjb3Jkc0J5UHJpb3JpdHlbcmVjb3JkLnByaW9yaXR5XS5yZWNvcmRzLnB1c2gocmVjb3JkKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVjb3Jkc0J5UHJpb3JpdHk7XG59XG5leHBvcnRzLmdyb3VwU3J2UmVjb3JkcyA9IGdyb3VwU3J2UmVjb3JkcztcbmZ1bmN0aW9uIHdlaWdodFNydlJlY29yZHMocmVjb3Jkc0dyb3VwKSB7XG4gICAgaWYgKHJlY29yZHNHcm91cC5yZWNvcmRzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICByZWNvcmRzR3JvdXAudG90YWxXZWlnaHQgPSAwO1xuICAgICAgICByZXR1cm4gcmVjb3Jkc0dyb3VwLnJlY29yZHMuc2hpZnQoKTtcbiAgICB9XG4gICAgLy8gKyBgcmVjb3Jkc0dyb3VwLnJlY29yZHMubGVuZ3RoYCB0byBzdXBwb3J0IGB3ZWlnaHRgIDBcbiAgICBjb25zdCByYW5kb20gPSBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAocmVjb3Jkc0dyb3VwLnRvdGFsV2VpZ2h0ICsgcmVjb3Jkc0dyb3VwLnJlY29yZHMubGVuZ3RoKSk7XG4gICAgbGV0IHRvdGFsID0gMDtcbiAgICBmb3IgKGNvbnN0IFtpLCByZWNvcmRdIG9mIHJlY29yZHNHcm91cC5yZWNvcmRzLmVudHJpZXMoKSkge1xuICAgICAgICB0b3RhbCArPSAxICsgcmVjb3JkLndlaWdodDtcbiAgICAgICAgaWYgKHRvdGFsID4gcmFuZG9tKSB7XG4gICAgICAgICAgICByZWNvcmRzR3JvdXAudG90YWxXZWlnaHQgLT0gcmVjb3JkLndlaWdodDtcbiAgICAgICAgICAgIHJlY29yZHNHcm91cC5yZWNvcmRzLnNwbGljZShpLCAxKTtcbiAgICAgICAgICAgIHJldHVybiByZWNvcmQ7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLndlaWdodFNydlJlY29yZHMgPSB3ZWlnaHRTcnZSZWNvcmRzO1xuZnVuY3Rpb24gZ2V0Q29ubmVjdGlvbk5hbWUoY29tcG9uZW50LCBub2RlQ29ubmVjdGlvbk5hbWUpIHtcbiAgICBjb25zdCBwcmVmaXggPSBgaW9yZWRpcy1jbHVzdGVyKCR7Y29tcG9uZW50fSlgO1xuICAgIHJldHVybiBub2RlQ29ubmVjdGlvbk5hbWUgPyBgJHtwcmVmaXh9OiR7bm9kZUNvbm5lY3Rpb25OYW1lfWAgOiBwcmVmaXg7XG59XG5leHBvcnRzLmdldENvbm5lY3Rpb25OYW1lID0gZ2V0Q29ubmVjdGlvbk5hbWU7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/util.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/AbstractConnector.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/AbstractConnector.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"AbstractConnector\");\nclass AbstractConnector {\n    constructor(disconnectTimeout) {\n        this.connecting = false;\n        this.disconnectTimeout = disconnectTimeout;\n    }\n    check(info) {\n        return true;\n    }\n    disconnect() {\n        this.connecting = false;\n        if (this.stream) {\n            const stream = this.stream; // Make sure callbacks refer to the same instance\n            const timeout = setTimeout(() => {\n                debug(\"stream %s:%s still open, destroying it\", stream.remoteAddress, stream.remotePort);\n                stream.destroy();\n            }, this.disconnectTimeout);\n            stream.on(\"close\", () => clearTimeout(timeout));\n            stream.end();\n        }\n    }\n}\nexports[\"default\"] = AbstractConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9BYnN0cmFjdENvbm5lY3Rvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxnQkFBZ0IsbUJBQU8sQ0FBQyx3R0FBVTtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9BYnN0cmFjdENvbm5lY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcIkFic3RyYWN0Q29ubmVjdG9yXCIpO1xuY2xhc3MgQWJzdHJhY3RDb25uZWN0b3Ige1xuICAgIGNvbnN0cnVjdG9yKGRpc2Nvbm5lY3RUaW1lb3V0KSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICB0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0ID0gZGlzY29ubmVjdFRpbWVvdXQ7XG4gICAgfVxuICAgIGNoZWNrKGluZm8pIHtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5zdHJlYW0pIHtcbiAgICAgICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuc3RyZWFtOyAvLyBNYWtlIHN1cmUgY2FsbGJhY2tzIHJlZmVyIHRvIHRoZSBzYW1lIGluc3RhbmNlXG4gICAgICAgICAgICBjb25zdCB0aW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJzdHJlYW0gJXM6JXMgc3RpbGwgb3BlbiwgZGVzdHJveWluZyBpdFwiLCBzdHJlYW0ucmVtb3RlQWRkcmVzcywgc3RyZWFtLnJlbW90ZVBvcnQpO1xuICAgICAgICAgICAgICAgIHN0cmVhbS5kZXN0cm95KCk7XG4gICAgICAgICAgICB9LCB0aGlzLmRpc2Nvbm5lY3RUaW1lb3V0KTtcbiAgICAgICAgICAgIHN0cmVhbS5vbihcImNsb3NlXCIsICgpID0+IGNsZWFyVGltZW91dCh0aW1lb3V0KSk7XG4gICAgICAgICAgICBzdHJlYW0uZW5kKCk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBBYnN0cmFjdENvbm5lY3RvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/AbstractConnector.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FailoverDetector = void 0;\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst debug = (0, utils_1.Debug)(\"FailoverDetector\");\nconst CHANNEL_NAME = \"+switch-master\";\nclass FailoverDetector {\n    // sentinels can't be used for regular commands after this\n    constructor(connector, sentinels) {\n        this.isDisconnected = false;\n        this.connector = connector;\n        this.sentinels = sentinels;\n    }\n    cleanup() {\n        this.isDisconnected = true;\n        for (const sentinel of this.sentinels) {\n            sentinel.client.disconnect();\n        }\n    }\n    async subscribe() {\n        debug(\"Starting FailoverDetector\");\n        const promises = [];\n        for (const sentinel of this.sentinels) {\n            const promise = sentinel.client.subscribe(CHANNEL_NAME).catch((err) => {\n                debug(\"Failed to subscribe to failover messages on sentinel %s:%s (%s)\", sentinel.address.host || \"127.0.0.1\", sentinel.address.port || 26739, err.message);\n            });\n            promises.push(promise);\n            sentinel.client.on(\"message\", (channel) => {\n                if (!this.isDisconnected && channel === CHANNEL_NAME) {\n                    this.disconnect();\n                }\n            });\n        }\n        await Promise.all(promises);\n    }\n    disconnect() {\n        // Avoid disconnecting more than once per failover.\n        // A new FailoverDetector will be created after reconnecting.\n        this.isDisconnected = true;\n        debug(\"Failover detected, disconnecting\");\n        // Will call this.cleanup()\n        this.connector.disconnect();\n    }\n}\nexports.FailoverDetector = FailoverDetector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9GYWlsb3ZlckRldGVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELHdCQUF3QjtBQUN4QixnQkFBZ0IsbUJBQU8sQ0FBQywyR0FBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvRmFpbG92ZXJEZXRlY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRmFpbG92ZXJEZXRlY3RvciA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbHNcIik7XG5jb25zdCBkZWJ1ZyA9ICgwLCB1dGlsc18xLkRlYnVnKShcIkZhaWxvdmVyRGV0ZWN0b3JcIik7XG5jb25zdCBDSEFOTkVMX05BTUUgPSBcIitzd2l0Y2gtbWFzdGVyXCI7XG5jbGFzcyBGYWlsb3ZlckRldGVjdG9yIHtcbiAgICAvLyBzZW50aW5lbHMgY2FuJ3QgYmUgdXNlZCBmb3IgcmVndWxhciBjb21tYW5kcyBhZnRlciB0aGlzXG4gICAgY29uc3RydWN0b3IoY29ubmVjdG9yLCBzZW50aW5lbHMpIHtcbiAgICAgICAgdGhpcy5pc0Rpc2Nvbm5lY3RlZCA9IGZhbHNlO1xuICAgICAgICB0aGlzLmNvbm5lY3RvciA9IGNvbm5lY3RvcjtcbiAgICAgICAgdGhpcy5zZW50aW5lbHMgPSBzZW50aW5lbHM7XG4gICAgfVxuICAgIGNsZWFudXAoKSB7XG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbnRpbmVsIG9mIHRoaXMuc2VudGluZWxzKSB7XG4gICAgICAgICAgICBzZW50aW5lbC5jbGllbnQuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHN1YnNjcmliZSgpIHtcbiAgICAgICAgZGVidWcoXCJTdGFydGluZyBGYWlsb3ZlckRldGVjdG9yXCIpO1xuICAgICAgICBjb25zdCBwcm9taXNlcyA9IFtdO1xuICAgICAgICBmb3IgKGNvbnN0IHNlbnRpbmVsIG9mIHRoaXMuc2VudGluZWxzKSB7XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gc2VudGluZWwuY2xpZW50LnN1YnNjcmliZShDSEFOTkVMX05BTUUpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcIkZhaWxlZCB0byBzdWJzY3JpYmUgdG8gZmFpbG92ZXIgbWVzc2FnZXMgb24gc2VudGluZWwgJXM6JXMgKCVzKVwiLCBzZW50aW5lbC5hZGRyZXNzLmhvc3QgfHwgXCIxMjcuMC4wLjFcIiwgc2VudGluZWwuYWRkcmVzcy5wb3J0IHx8IDI2NzM5LCBlcnIubWVzc2FnZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb21pc2VzLnB1c2gocHJvbWlzZSk7XG4gICAgICAgICAgICBzZW50aW5lbC5jbGllbnQub24oXCJtZXNzYWdlXCIsIChjaGFubmVsKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLmlzRGlzY29ubmVjdGVkICYmIGNoYW5uZWwgPT09IENIQU5ORUxfTkFNRSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBhd2FpdCBQcm9taXNlLmFsbChwcm9taXNlcyk7XG4gICAgfVxuICAgIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIC8vIEF2b2lkIGRpc2Nvbm5lY3RpbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGZhaWxvdmVyLlxuICAgICAgICAvLyBBIG5ldyBGYWlsb3ZlckRldGVjdG9yIHdpbGwgYmUgY3JlYXRlZCBhZnRlciByZWNvbm5lY3RpbmcuXG4gICAgICAgIHRoaXMuaXNEaXNjb25uZWN0ZWQgPSB0cnVlO1xuICAgICAgICBkZWJ1ZyhcIkZhaWxvdmVyIGRldGVjdGVkLCBkaXNjb25uZWN0aW5nXCIpO1xuICAgICAgICAvLyBXaWxsIGNhbGwgdGhpcy5jbGVhbnVwKClcbiAgICAgICAgdGhpcy5jb25uZWN0b3IuZGlzY29ubmVjdCgpO1xuICAgIH1cbn1cbmV4cG9ydHMuRmFpbG92ZXJEZXRlY3RvciA9IEZhaWxvdmVyRGV0ZWN0b3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js":
/*!**************************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js ***!
  \**************************************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction isSentinelEql(a, b) {\n    return ((a.host || \"127.0.0.1\") === (b.host || \"127.0.0.1\") &&\n        (a.port || 26379) === (b.port || 26379));\n}\nclass SentinelIterator {\n    constructor(sentinels) {\n        this.cursor = 0;\n        this.sentinels = sentinels.slice(0);\n    }\n    next() {\n        const done = this.cursor >= this.sentinels.length;\n        return { done, value: done ? undefined : this.sentinels[this.cursor++] };\n    }\n    reset(moveCurrentEndpointToFirst) {\n        if (moveCurrentEndpointToFirst &&\n            this.sentinels.length > 1 &&\n            this.cursor !== 1) {\n            this.sentinels.unshift(...this.sentinels.splice(this.cursor - 1));\n        }\n        this.cursor = 0;\n    }\n    add(sentinel) {\n        for (let i = 0; i < this.sentinels.length; i++) {\n            if (isSentinelEql(sentinel, this.sentinels[i])) {\n                return false;\n            }\n        }\n        this.sentinels.push(sentinel);\n        return true;\n    }\n    toString() {\n        return `${JSON.stringify(this.sentinels)} @${this.cursor}`;\n    }\n}\nexports[\"default\"] = SentinelIterator;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9TZW50aW5lbEl0ZXJhdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsMkJBQTJCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsZ0NBQWdDLEdBQUcsWUFBWTtBQUNqRTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvU2VudGluZWxJdGVyYXRvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGlzU2VudGluZWxFcWwoYSwgYikge1xuICAgIHJldHVybiAoKGEuaG9zdCB8fCBcIjEyNy4wLjAuMVwiKSA9PT0gKGIuaG9zdCB8fCBcIjEyNy4wLjAuMVwiKSAmJlxuICAgICAgICAoYS5wb3J0IHx8IDI2Mzc5KSA9PT0gKGIucG9ydCB8fCAyNjM3OSkpO1xufVxuY2xhc3MgU2VudGluZWxJdGVyYXRvciB7XG4gICAgY29uc3RydWN0b3Ioc2VudGluZWxzKSB7XG4gICAgICAgIHRoaXMuY3Vyc29yID0gMDtcbiAgICAgICAgdGhpcy5zZW50aW5lbHMgPSBzZW50aW5lbHMuc2xpY2UoMCk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IGRvbmUgPSB0aGlzLmN1cnNvciA+PSB0aGlzLnNlbnRpbmVscy5sZW5ndGg7XG4gICAgICAgIHJldHVybiB7IGRvbmUsIHZhbHVlOiBkb25lID8gdW5kZWZpbmVkIDogdGhpcy5zZW50aW5lbHNbdGhpcy5jdXJzb3IrK10gfTtcbiAgICB9XG4gICAgcmVzZXQobW92ZUN1cnJlbnRFbmRwb2ludFRvRmlyc3QpIHtcbiAgICAgICAgaWYgKG1vdmVDdXJyZW50RW5kcG9pbnRUb0ZpcnN0ICYmXG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVscy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICB0aGlzLmN1cnNvciAhPT0gMSkge1xuICAgICAgICAgICAgdGhpcy5zZW50aW5lbHMudW5zaGlmdCguLi50aGlzLnNlbnRpbmVscy5zcGxpY2UodGhpcy5jdXJzb3IgLSAxKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgIH1cbiAgICBhZGQoc2VudGluZWwpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLnNlbnRpbmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGlzU2VudGluZWxFcWwoc2VudGluZWwsIHRoaXMuc2VudGluZWxzW2ldKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbnRpbmVscy5wdXNoKHNlbnRpbmVsKTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gYCR7SlNPTi5zdHJpbmdpZnkodGhpcy5zZW50aW5lbHMpfSBAJHt0aGlzLmN1cnNvcn1gO1xuICAgIH1cbn1cbmV4cG9ydHMuZGVmYXVsdCA9IFNlbnRpbmVsSXRlcmF0b3I7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/index.js":
/*!***************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/index.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SentinelIterator = void 0;\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst utils_1 = __webpack_require__(/*! ../../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst SentinelIterator_1 = __webpack_require__(/*! ./SentinelIterator */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/SentinelIterator.js\");\nexports.SentinelIterator = SentinelIterator_1.default;\nconst AbstractConnector_1 = __webpack_require__(/*! ../AbstractConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/AbstractConnector.js\");\nconst Redis_1 = __webpack_require__(/*! ../../Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\");\nconst FailoverDetector_1 = __webpack_require__(/*! ./FailoverDetector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/FailoverDetector.js\");\nconst debug = (0, utils_1.Debug)(\"SentinelConnector\");\nclass SentinelConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super(options.disconnectTimeout);\n        this.options = options;\n        this.emitter = null;\n        this.failoverDetector = null;\n        if (!this.options.sentinels.length) {\n            throw new Error(\"Requires at least one sentinel to connect to.\");\n        }\n        if (!this.options.name) {\n            throw new Error(\"Requires the name of master.\");\n        }\n        this.sentinelIterator = new SentinelIterator_1.default(this.options.sentinels);\n    }\n    check(info) {\n        const roleMatches = !info.role || this.options.role === info.role;\n        if (!roleMatches) {\n            debug(\"role invalid, expected %s, but got %s\", this.options.role, info.role);\n            // Start from the next item.\n            // Note that `reset` will move the cursor to the previous element,\n            // so we advance two steps here.\n            this.sentinelIterator.next();\n            this.sentinelIterator.next();\n            this.sentinelIterator.reset(true);\n        }\n        return roleMatches;\n    }\n    disconnect() {\n        super.disconnect();\n        if (this.failoverDetector) {\n            this.failoverDetector.cleanup();\n        }\n    }\n    connect(eventEmitter) {\n        this.connecting = true;\n        this.retryAttempts = 0;\n        let lastError;\n        const connectToNext = async () => {\n            const endpoint = this.sentinelIterator.next();\n            if (endpoint.done) {\n                this.sentinelIterator.reset(false);\n                const retryDelay = typeof this.options.sentinelRetryStrategy === \"function\"\n                    ? this.options.sentinelRetryStrategy(++this.retryAttempts)\n                    : null;\n                let errorMsg = typeof retryDelay !== \"number\"\n                    ? \"All sentinels are unreachable and retry is disabled.\"\n                    : `All sentinels are unreachable. Retrying from scratch after ${retryDelay}ms.`;\n                if (lastError) {\n                    errorMsg += ` Last error: ${lastError.message}`;\n                }\n                debug(errorMsg);\n                const error = new Error(errorMsg);\n                if (typeof retryDelay === \"number\") {\n                    eventEmitter(\"error\", error);\n                    await new Promise((resolve) => setTimeout(resolve, retryDelay));\n                    return connectToNext();\n                }\n                else {\n                    throw error;\n                }\n            }\n            let resolved = null;\n            let err = null;\n            try {\n                resolved = await this.resolve(endpoint.value);\n            }\n            catch (error) {\n                err = error;\n            }\n            if (!this.connecting) {\n                throw new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG);\n            }\n            const endpointAddress = endpoint.value.host + \":\" + endpoint.value.port;\n            if (resolved) {\n                debug(\"resolved: %s:%s from sentinel %s\", resolved.host, resolved.port, endpointAddress);\n                if (this.options.enableTLSForSentinelMode && this.options.tls) {\n                    Object.assign(resolved, this.options.tls);\n                    this.stream = (0, tls_1.connect)(resolved);\n                    this.stream.once(\"secureConnect\", this.initFailoverDetector.bind(this));\n                }\n                else {\n                    this.stream = (0, net_1.createConnection)(resolved);\n                    this.stream.once(\"connect\", this.initFailoverDetector.bind(this));\n                }\n                this.stream.once(\"error\", (err) => {\n                    this.firstError = err;\n                });\n                return this.stream;\n            }\n            else {\n                const errorMsg = err\n                    ? \"failed to connect to sentinel \" +\n                        endpointAddress +\n                        \" because \" +\n                        err.message\n                    : \"connected to sentinel \" +\n                        endpointAddress +\n                        \" successfully, but got an invalid reply: \" +\n                        resolved;\n                debug(errorMsg);\n                eventEmitter(\"sentinelError\", new Error(errorMsg));\n                if (err) {\n                    lastError = err;\n                }\n                return connectToNext();\n            }\n        };\n        return connectToNext();\n    }\n    async updateSentinels(client) {\n        if (!this.options.updateSentinels) {\n            return;\n        }\n        const result = await client.sentinel(\"sentinels\", this.options.name);\n        if (!Array.isArray(result)) {\n            return;\n        }\n        result\n            .map(utils_1.packObject)\n            .forEach((sentinel) => {\n            const flags = sentinel.flags ? sentinel.flags.split(\",\") : [];\n            if (flags.indexOf(\"disconnected\") === -1 &&\n                sentinel.ip &&\n                sentinel.port) {\n                const endpoint = this.sentinelNatResolve(addressResponseToAddress(sentinel));\n                if (this.sentinelIterator.add(endpoint)) {\n                    debug(\"adding sentinel %s:%s\", endpoint.host, endpoint.port);\n                }\n            }\n        });\n        debug(\"Updated internal sentinels: %s\", this.sentinelIterator);\n    }\n    async resolveMaster(client) {\n        const result = await client.sentinel(\"get-master-addr-by-name\", this.options.name);\n        await this.updateSentinels(client);\n        return this.sentinelNatResolve(Array.isArray(result)\n            ? { host: result[0], port: Number(result[1]) }\n            : null);\n    }\n    async resolveSlave(client) {\n        const result = await client.sentinel(\"slaves\", this.options.name);\n        if (!Array.isArray(result)) {\n            return null;\n        }\n        const availableSlaves = result\n            .map(utils_1.packObject)\n            .filter((slave) => slave.flags && !slave.flags.match(/(disconnected|s_down|o_down)/));\n        return this.sentinelNatResolve(selectPreferredSentinel(availableSlaves, this.options.preferredSlaves));\n    }\n    sentinelNatResolve(item) {\n        if (!item || !this.options.natMap)\n            return item;\n        const key = `${item.host}:${item.port}`;\n        let result = item;\n        if (typeof this.options.natMap === \"function\") {\n            result = this.options.natMap(key) || item;\n        }\n        else if (typeof this.options.natMap === \"object\") {\n            result = this.options.natMap[key] || item;\n        }\n        return result;\n    }\n    connectToSentinel(endpoint, options) {\n        const redis = new Redis_1.default({\n            port: endpoint.port || 26379,\n            host: endpoint.host,\n            username: this.options.sentinelUsername || null,\n            password: this.options.sentinelPassword || null,\n            family: endpoint.family ||\n                // @ts-expect-error\n                (\"path\" in this.options && this.options.path\n                    ? undefined\n                    : // @ts-expect-error\n                        this.options.family),\n            tls: this.options.sentinelTLS,\n            retryStrategy: null,\n            enableReadyCheck: false,\n            connectTimeout: this.options.connectTimeout,\n            commandTimeout: this.options.sentinelCommandTimeout,\n            ...options,\n        });\n        // @ts-expect-error\n        return redis;\n    }\n    async resolve(endpoint) {\n        const client = this.connectToSentinel(endpoint);\n        // ignore the errors since resolve* methods will handle them\n        client.on(\"error\", noop);\n        try {\n            if (this.options.role === \"slave\") {\n                return await this.resolveSlave(client);\n            }\n            else {\n                return await this.resolveMaster(client);\n            }\n        }\n        finally {\n            client.disconnect();\n        }\n    }\n    async initFailoverDetector() {\n        var _a;\n        if (!this.options.failoverDetector) {\n            return;\n        }\n        // Move the current sentinel to the first position\n        this.sentinelIterator.reset(true);\n        const sentinels = [];\n        // In case of a large amount of sentinels, limit the number of concurrent connections\n        while (sentinels.length < this.options.sentinelMaxConnections) {\n            const { done, value } = this.sentinelIterator.next();\n            if (done) {\n                break;\n            }\n            const client = this.connectToSentinel(value, {\n                lazyConnect: true,\n                retryStrategy: this.options.sentinelReconnectStrategy,\n            });\n            client.on(\"reconnecting\", () => {\n                var _a;\n                // Tests listen to this event\n                (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"sentinelReconnecting\");\n            });\n            sentinels.push({ address: value, client });\n        }\n        this.sentinelIterator.reset(false);\n        if (this.failoverDetector) {\n            // Clean up previous detector\n            this.failoverDetector.cleanup();\n        }\n        this.failoverDetector = new FailoverDetector_1.FailoverDetector(this, sentinels);\n        await this.failoverDetector.subscribe();\n        // Tests listen to this event\n        (_a = this.emitter) === null || _a === void 0 ? void 0 : _a.emit(\"failoverSubscribed\");\n    }\n}\nexports[\"default\"] = SentinelConnector;\nfunction selectPreferredSentinel(availableSlaves, preferredSlaves) {\n    if (availableSlaves.length === 0) {\n        return null;\n    }\n    let selectedSlave;\n    if (typeof preferredSlaves === \"function\") {\n        selectedSlave = preferredSlaves(availableSlaves);\n    }\n    else if (preferredSlaves !== null && typeof preferredSlaves === \"object\") {\n        const preferredSlavesArray = Array.isArray(preferredSlaves)\n            ? preferredSlaves\n            : [preferredSlaves];\n        // sort by priority\n        preferredSlavesArray.sort((a, b) => {\n            // default the priority to 1\n            if (!a.prio) {\n                a.prio = 1;\n            }\n            if (!b.prio) {\n                b.prio = 1;\n            }\n            // lowest priority first\n            if (a.prio < b.prio) {\n                return -1;\n            }\n            if (a.prio > b.prio) {\n                return 1;\n            }\n            return 0;\n        });\n        // loop over preferred slaves and return the first match\n        for (let p = 0; p < preferredSlavesArray.length; p++) {\n            for (let a = 0; a < availableSlaves.length; a++) {\n                const slave = availableSlaves[a];\n                if (slave.ip === preferredSlavesArray[p].ip) {\n                    if (slave.port === preferredSlavesArray[p].port) {\n                        selectedSlave = slave;\n                        break;\n                    }\n                }\n            }\n            if (selectedSlave) {\n                break;\n            }\n        }\n    }\n    // if none of the preferred slaves are available, a random available slave is returned\n    if (!selectedSlave) {\n        selectedSlave = (0, utils_1.sample)(availableSlaves);\n    }\n    return addressResponseToAddress(selectedSlave);\n}\nfunction addressResponseToAddress(input) {\n    return { host: input.ip, port: Number(input.port) };\n}\nfunction noop() { }\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TZW50aW5lbENvbm5lY3Rvci9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx3QkFBd0I7QUFDeEIsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGdCQUFnQixtQkFBTyxDQUFDLDJHQUFhO0FBQ3JDLGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQiwyQkFBMkIsbUJBQU8sQ0FBQyxvSkFBb0I7QUFDdkQsd0JBQXdCO0FBQ3hCLDRCQUE0QixtQkFBTyxDQUFDLHFJQUFzQjtBQUMxRCxnQkFBZ0IsbUJBQU8sQ0FBQyxxR0FBYTtBQUNyQywyQkFBMkIsbUJBQU8sQ0FBQyxvSkFBb0I7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9GQUFvRixXQUFXO0FBQy9GO0FBQ0EsZ0RBQWdELGtCQUFrQjtBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVLEdBQUcsVUFBVTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixjQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYiw2QkFBNkIsd0JBQXdCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLHdCQUF3QixpQ0FBaUM7QUFDekQsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3IvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNlbnRpbmVsSXRlcmF0b3IgPSB2b2lkIDA7XG5jb25zdCBuZXRfMSA9IHJlcXVpcmUoXCJuZXRcIik7XG5jb25zdCB1dGlsc18xID0gcmVxdWlyZShcIi4uLy4uL3V0aWxzXCIpO1xuY29uc3QgdGxzXzEgPSByZXF1aXJlKFwidGxzXCIpO1xuY29uc3QgU2VudGluZWxJdGVyYXRvcl8xID0gcmVxdWlyZShcIi4vU2VudGluZWxJdGVyYXRvclwiKTtcbmV4cG9ydHMuU2VudGluZWxJdGVyYXRvciA9IFNlbnRpbmVsSXRlcmF0b3JfMS5kZWZhdWx0O1xuY29uc3QgQWJzdHJhY3RDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuLi9BYnN0cmFjdENvbm5lY3RvclwiKTtcbmNvbnN0IFJlZGlzXzEgPSByZXF1aXJlKFwiLi4vLi4vUmVkaXNcIik7XG5jb25zdCBGYWlsb3ZlckRldGVjdG9yXzEgPSByZXF1aXJlKFwiLi9GYWlsb3ZlckRldGVjdG9yXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJTZW50aW5lbENvbm5lY3RvclwiKTtcbmNsYXNzIFNlbnRpbmVsQ29ubmVjdG9yIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0b3JfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGlzY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgICB0aGlzLmVtaXR0ZXIgPSBudWxsO1xuICAgICAgICB0aGlzLmZhaWxvdmVyRGV0ZWN0b3IgPSBudWxsO1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy5zZW50aW5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJSZXF1aXJlcyBhdCBsZWFzdCBvbmUgc2VudGluZWwgdG8gY29ubmVjdCB0by5cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMubmFtZSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUmVxdWlyZXMgdGhlIG5hbWUgb2YgbWFzdGVyLlwiKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IgPSBuZXcgU2VudGluZWxJdGVyYXRvcl8xLmRlZmF1bHQodGhpcy5vcHRpb25zLnNlbnRpbmVscyk7XG4gICAgfVxuICAgIGNoZWNrKGluZm8pIHtcbiAgICAgICAgY29uc3Qgcm9sZU1hdGNoZXMgPSAhaW5mby5yb2xlIHx8IHRoaXMub3B0aW9ucy5yb2xlID09PSBpbmZvLnJvbGU7XG4gICAgICAgIGlmICghcm9sZU1hdGNoZXMpIHtcbiAgICAgICAgICAgIGRlYnVnKFwicm9sZSBpbnZhbGlkLCBleHBlY3RlZCAlcywgYnV0IGdvdCAlc1wiLCB0aGlzLm9wdGlvbnMucm9sZSwgaW5mby5yb2xlKTtcbiAgICAgICAgICAgIC8vIFN0YXJ0IGZyb20gdGhlIG5leHQgaXRlbS5cbiAgICAgICAgICAgIC8vIE5vdGUgdGhhdCBgcmVzZXRgIHdpbGwgbW92ZSB0aGUgY3Vyc29yIHRvIHRoZSBwcmV2aW91cyBlbGVtZW50LFxuICAgICAgICAgICAgLy8gc28gd2UgYWR2YW5jZSB0d28gc3RlcHMgaGVyZS5cbiAgICAgICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICB0aGlzLnNlbnRpbmVsSXRlcmF0b3IubmV4dCgpO1xuICAgICAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLnJlc2V0KHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByb2xlTWF0Y2hlcztcbiAgICB9XG4gICAgZGlzY29ubmVjdCgpIHtcbiAgICAgICAgc3VwZXIuZGlzY29ubmVjdCgpO1xuICAgICAgICBpZiAodGhpcy5mYWlsb3ZlckRldGVjdG9yKSB7XG4gICAgICAgICAgICB0aGlzLmZhaWxvdmVyRGV0ZWN0b3IuY2xlYW51cCgpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbm5lY3QoZXZlbnRFbWl0dGVyKSB7XG4gICAgICAgIHRoaXMuY29ubmVjdGluZyA9IHRydWU7XG4gICAgICAgIHRoaXMucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgIGxldCBsYXN0RXJyb3I7XG4gICAgICAgIGNvbnN0IGNvbm5lY3RUb05leHQgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBlbmRwb2ludCA9IHRoaXMuc2VudGluZWxJdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBpZiAoZW5kcG9pbnQuZG9uZSkge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5yZXNldChmYWxzZSk7XG4gICAgICAgICAgICAgICAgY29uc3QgcmV0cnlEZWxheSA9IHR5cGVvZiB0aGlzLm9wdGlvbnMuc2VudGluZWxSZXRyeVN0cmF0ZWd5ID09PSBcImZ1bmN0aW9uXCJcbiAgICAgICAgICAgICAgICAgICAgPyB0aGlzLm9wdGlvbnMuc2VudGluZWxSZXRyeVN0cmF0ZWd5KCsrdGhpcy5yZXRyeUF0dGVtcHRzKVxuICAgICAgICAgICAgICAgICAgICA6IG51bGw7XG4gICAgICAgICAgICAgICAgbGV0IGVycm9yTXNnID0gdHlwZW9mIHJldHJ5RGVsYXkgIT09IFwibnVtYmVyXCJcbiAgICAgICAgICAgICAgICAgICAgPyBcIkFsbCBzZW50aW5lbHMgYXJlIHVucmVhY2hhYmxlIGFuZCByZXRyeSBpcyBkaXNhYmxlZC5cIlxuICAgICAgICAgICAgICAgICAgICA6IGBBbGwgc2VudGluZWxzIGFyZSB1bnJlYWNoYWJsZS4gUmV0cnlpbmcgZnJvbSBzY3JhdGNoIGFmdGVyICR7cmV0cnlEZWxheX1tcy5gO1xuICAgICAgICAgICAgICAgIGlmIChsYXN0RXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyb3JNc2cgKz0gYCBMYXN0IGVycm9yOiAke2xhc3RFcnJvci5tZXNzYWdlfWA7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlYnVnKGVycm9yTXNnKTtcbiAgICAgICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBFcnJvcihlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiByZXRyeURlbGF5ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICAgICAgICAgIGV2ZW50RW1pdHRlcihcImVycm9yXCIsIGVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgbmV3IFByb21pc2UoKHJlc29sdmUpID0+IHNldFRpbWVvdXQocmVzb2x2ZSwgcmV0cnlEZWxheSkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gY29ubmVjdFRvTmV4dCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbGV0IHJlc29sdmVkID0gbnVsbDtcbiAgICAgICAgICAgIGxldCBlcnIgPSBudWxsO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICByZXNvbHZlZCA9IGF3YWl0IHRoaXMucmVzb2x2ZShlbmRwb2ludC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnIgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdGhpcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50QWRkcmVzcyA9IGVuZHBvaW50LnZhbHVlLmhvc3QgKyBcIjpcIiArIGVuZHBvaW50LnZhbHVlLnBvcnQ7XG4gICAgICAgICAgICBpZiAocmVzb2x2ZWQpIHtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhcInJlc29sdmVkOiAlczolcyBmcm9tIHNlbnRpbmVsICVzXCIsIHJlc29sdmVkLmhvc3QsIHJlc29sdmVkLnBvcnQsIGVuZHBvaW50QWRkcmVzcyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5lbmFibGVUTFNGb3JTZW50aW5lbE1vZGUgJiYgdGhpcy5vcHRpb25zLnRscykge1xuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHJlc29sdmVkLCB0aGlzLm9wdGlvbnMudGxzKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSAoMCwgdGxzXzEuY29ubmVjdCkocmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKFwic2VjdXJlQ29ubmVjdFwiLCB0aGlzLmluaXRGYWlsb3ZlckRldGVjdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdHJlYW0gPSAoMCwgbmV0XzEuY3JlYXRlQ29ubmVjdGlvbikocmVzb2x2ZWQpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKFwiY29ubmVjdFwiLCB0aGlzLmluaXRGYWlsb3ZlckRldGVjdG9yLmJpbmQodGhpcykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc3RyZWFtO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZXJyb3JNc2cgPSBlcnJcbiAgICAgICAgICAgICAgICAgICAgPyBcImZhaWxlZCB0byBjb25uZWN0IHRvIHNlbnRpbmVsIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVuZHBvaW50QWRkcmVzcyArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiBiZWNhdXNlIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVyci5tZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgIDogXCJjb25uZWN0ZWQgdG8gc2VudGluZWwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgZW5kcG9pbnRBZGRyZXNzICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIHN1Y2Nlc3NmdWxseSwgYnV0IGdvdCBhbiBpbnZhbGlkIHJlcGx5OiBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNvbHZlZDtcbiAgICAgICAgICAgICAgICBkZWJ1ZyhlcnJvck1zZyk7XG4gICAgICAgICAgICAgICAgZXZlbnRFbWl0dGVyKFwic2VudGluZWxFcnJvclwiLCBuZXcgRXJyb3IoZXJyb3JNc2cpKTtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxhc3RFcnJvciA9IGVycjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGNvbm5lY3RUb05leHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGNvbm5lY3RUb05leHQoKTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlU2VudGluZWxzKGNsaWVudCkge1xuICAgICAgICBpZiAoIXRoaXMub3B0aW9ucy51cGRhdGVTZW50aW5lbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuc2VudGluZWwoXCJzZW50aW5lbHNcIiwgdGhpcy5vcHRpb25zLm5hbWUpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgLm1hcCh1dGlsc18xLnBhY2tPYmplY3QpXG4gICAgICAgICAgICAuZm9yRWFjaCgoc2VudGluZWwpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGZsYWdzID0gc2VudGluZWwuZmxhZ3MgPyBzZW50aW5lbC5mbGFncy5zcGxpdChcIixcIikgOiBbXTtcbiAgICAgICAgICAgIGlmIChmbGFncy5pbmRleE9mKFwiZGlzY29ubmVjdGVkXCIpID09PSAtMSAmJlxuICAgICAgICAgICAgICAgIHNlbnRpbmVsLmlwICYmXG4gICAgICAgICAgICAgICAgc2VudGluZWwucG9ydCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVuZHBvaW50ID0gdGhpcy5zZW50aW5lbE5hdFJlc29sdmUoYWRkcmVzc1Jlc3BvbnNlVG9BZGRyZXNzKHNlbnRpbmVsKSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc2VudGluZWxJdGVyYXRvci5hZGQoZW5kcG9pbnQpKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwiYWRkaW5nIHNlbnRpbmVsICVzOiVzXCIsIGVuZHBvaW50Lmhvc3QsIGVuZHBvaW50LnBvcnQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGRlYnVnKFwiVXBkYXRlZCBpbnRlcm5hbCBzZW50aW5lbHM6ICVzXCIsIHRoaXMuc2VudGluZWxJdGVyYXRvcik7XG4gICAgfVxuICAgIGFzeW5jIHJlc29sdmVNYXN0ZXIoY2xpZW50KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGNsaWVudC5zZW50aW5lbChcImdldC1tYXN0ZXItYWRkci1ieS1uYW1lXCIsIHRoaXMub3B0aW9ucy5uYW1lKTtcbiAgICAgICAgYXdhaXQgdGhpcy51cGRhdGVTZW50aW5lbHMoY2xpZW50KTtcbiAgICAgICAgcmV0dXJuIHRoaXMuc2VudGluZWxOYXRSZXNvbHZlKEFycmF5LmlzQXJyYXkocmVzdWx0KVxuICAgICAgICAgICAgPyB7IGhvc3Q6IHJlc3VsdFswXSwgcG9ydDogTnVtYmVyKHJlc3VsdFsxXSkgfVxuICAgICAgICAgICAgOiBudWxsKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZVNsYXZlKGNsaWVudCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBjbGllbnQuc2VudGluZWwoXCJzbGF2ZXNcIiwgdGhpcy5vcHRpb25zLm5hbWUpO1xuICAgICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVzdWx0KSkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYXZhaWxhYmxlU2xhdmVzID0gcmVzdWx0XG4gICAgICAgICAgICAubWFwKHV0aWxzXzEucGFja09iamVjdClcbiAgICAgICAgICAgIC5maWx0ZXIoKHNsYXZlKSA9PiBzbGF2ZS5mbGFncyAmJiAhc2xhdmUuZmxhZ3MubWF0Y2goLyhkaXNjb25uZWN0ZWR8c19kb3dufG9fZG93bikvKSk7XG4gICAgICAgIHJldHVybiB0aGlzLnNlbnRpbmVsTmF0UmVzb2x2ZShzZWxlY3RQcmVmZXJyZWRTZW50aW5lbChhdmFpbGFibGVTbGF2ZXMsIHRoaXMub3B0aW9ucy5wcmVmZXJyZWRTbGF2ZXMpKTtcbiAgICB9XG4gICAgc2VudGluZWxOYXRSZXNvbHZlKGl0ZW0pIHtcbiAgICAgICAgaWYgKCFpdGVtIHx8ICF0aGlzLm9wdGlvbnMubmF0TWFwKVxuICAgICAgICAgICAgcmV0dXJuIGl0ZW07XG4gICAgICAgIGNvbnN0IGtleSA9IGAke2l0ZW0uaG9zdH06JHtpdGVtLnBvcnR9YDtcbiAgICAgICAgbGV0IHJlc3VsdCA9IGl0ZW07XG4gICAgICAgIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm5hdE1hcCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICByZXN1bHQgPSB0aGlzLm9wdGlvbnMubmF0TWFwKGtleSkgfHwgaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgdGhpcy5vcHRpb25zLm5hdE1hcCA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgcmVzdWx0ID0gdGhpcy5vcHRpb25zLm5hdE1hcFtrZXldIHx8IGl0ZW07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgY29ubmVjdFRvU2VudGluZWwoZW5kcG9pbnQsIG9wdGlvbnMpIHtcbiAgICAgICAgY29uc3QgcmVkaXMgPSBuZXcgUmVkaXNfMS5kZWZhdWx0KHtcbiAgICAgICAgICAgIHBvcnQ6IGVuZHBvaW50LnBvcnQgfHwgMjYzNzksXG4gICAgICAgICAgICBob3N0OiBlbmRwb2ludC5ob3N0LFxuICAgICAgICAgICAgdXNlcm5hbWU6IHRoaXMub3B0aW9ucy5zZW50aW5lbFVzZXJuYW1lIHx8IG51bGwsXG4gICAgICAgICAgICBwYXNzd29yZDogdGhpcy5vcHRpb25zLnNlbnRpbmVsUGFzc3dvcmQgfHwgbnVsbCxcbiAgICAgICAgICAgIGZhbWlseTogZW5kcG9pbnQuZmFtaWx5IHx8XG4gICAgICAgICAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICAgICAgICAgIChcInBhdGhcIiBpbiB0aGlzLm9wdGlvbnMgJiYgdGhpcy5vcHRpb25zLnBhdGhcbiAgICAgICAgICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgICAgICAgICAgOiAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLm9wdGlvbnMuZmFtaWx5KSxcbiAgICAgICAgICAgIHRsczogdGhpcy5vcHRpb25zLnNlbnRpbmVsVExTLFxuICAgICAgICAgICAgcmV0cnlTdHJhdGVneTogbnVsbCxcbiAgICAgICAgICAgIGVuYWJsZVJlYWR5Q2hlY2s6IGZhbHNlLFxuICAgICAgICAgICAgY29ubmVjdFRpbWVvdXQ6IHRoaXMub3B0aW9ucy5jb25uZWN0VGltZW91dCxcbiAgICAgICAgICAgIGNvbW1hbmRUaW1lb3V0OiB0aGlzLm9wdGlvbnMuc2VudGluZWxDb21tYW5kVGltZW91dCxcbiAgICAgICAgICAgIC4uLm9wdGlvbnMsXG4gICAgICAgIH0pO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHJldHVybiByZWRpcztcbiAgICB9XG4gICAgYXN5bmMgcmVzb2x2ZShlbmRwb2ludCkge1xuICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RUb1NlbnRpbmVsKGVuZHBvaW50KTtcbiAgICAgICAgLy8gaWdub3JlIHRoZSBlcnJvcnMgc2luY2UgcmVzb2x2ZSogbWV0aG9kcyB3aWxsIGhhbmRsZSB0aGVtXG4gICAgICAgIGNsaWVudC5vbihcImVycm9yXCIsIG5vb3ApO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yb2xlID09PSBcInNsYXZlXCIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gYXdhaXQgdGhpcy5yZXNvbHZlU2xhdmUoY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybiBhd2FpdCB0aGlzLnJlc29sdmVNYXN0ZXIoY2xpZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgIGNsaWVudC5kaXNjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgaW5pdEZhaWxvdmVyRGV0ZWN0b3IoKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgaWYgKCF0aGlzLm9wdGlvbnMuZmFpbG92ZXJEZXRlY3Rvcikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8vIE1vdmUgdGhlIGN1cnJlbnQgc2VudGluZWwgdG8gdGhlIGZpcnN0IHBvc2l0aW9uXG4gICAgICAgIHRoaXMuc2VudGluZWxJdGVyYXRvci5yZXNldCh0cnVlKTtcbiAgICAgICAgY29uc3Qgc2VudGluZWxzID0gW107XG4gICAgICAgIC8vIEluIGNhc2Ugb2YgYSBsYXJnZSBhbW91bnQgb2Ygc2VudGluZWxzLCBsaW1pdCB0aGUgbnVtYmVyIG9mIGNvbmN1cnJlbnQgY29ubmVjdGlvbnNcbiAgICAgICAgd2hpbGUgKHNlbnRpbmVscy5sZW5ndGggPCB0aGlzLm9wdGlvbnMuc2VudGluZWxNYXhDb25uZWN0aW9ucykge1xuICAgICAgICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gdGhpcy5zZW50aW5lbEl0ZXJhdG9yLm5leHQoKTtcbiAgICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBjbGllbnQgPSB0aGlzLmNvbm5lY3RUb1NlbnRpbmVsKHZhbHVlLCB7XG4gICAgICAgICAgICAgICAgbGF6eUNvbm5lY3Q6IHRydWUsXG4gICAgICAgICAgICAgICAgcmV0cnlTdHJhdGVneTogdGhpcy5vcHRpb25zLnNlbnRpbmVsUmVjb25uZWN0U3RyYXRlZ3ksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNsaWVudC5vbihcInJlY29ubmVjdGluZ1wiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIC8vIFRlc3RzIGxpc3RlbiB0byB0aGlzIGV2ZW50XG4gICAgICAgICAgICAgICAgKF9hID0gdGhpcy5lbWl0dGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdChcInNlbnRpbmVsUmVjb25uZWN0aW5nXCIpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZW50aW5lbHMucHVzaCh7IGFkZHJlc3M6IHZhbHVlLCBjbGllbnQgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZW50aW5lbEl0ZXJhdG9yLnJlc2V0KGZhbHNlKTtcbiAgICAgICAgaWYgKHRoaXMuZmFpbG92ZXJEZXRlY3Rvcikge1xuICAgICAgICAgICAgLy8gQ2xlYW4gdXAgcHJldmlvdXMgZGV0ZWN0b3JcbiAgICAgICAgICAgIHRoaXMuZmFpbG92ZXJEZXRlY3Rvci5jbGVhbnVwKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5mYWlsb3ZlckRldGVjdG9yID0gbmV3IEZhaWxvdmVyRGV0ZWN0b3JfMS5GYWlsb3ZlckRldGVjdG9yKHRoaXMsIHNlbnRpbmVscyk7XG4gICAgICAgIGF3YWl0IHRoaXMuZmFpbG92ZXJEZXRlY3Rvci5zdWJzY3JpYmUoKTtcbiAgICAgICAgLy8gVGVzdHMgbGlzdGVuIHRvIHRoaXMgZXZlbnRcbiAgICAgICAgKF9hID0gdGhpcy5lbWl0dGVyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZW1pdChcImZhaWxvdmVyU3Vic2NyaWJlZFwiKTtcbiAgICB9XG59XG5leHBvcnRzLmRlZmF1bHQgPSBTZW50aW5lbENvbm5lY3RvcjtcbmZ1bmN0aW9uIHNlbGVjdFByZWZlcnJlZFNlbnRpbmVsKGF2YWlsYWJsZVNsYXZlcywgcHJlZmVycmVkU2xhdmVzKSB7XG4gICAgaWYgKGF2YWlsYWJsZVNsYXZlcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGxldCBzZWxlY3RlZFNsYXZlO1xuICAgIGlmICh0eXBlb2YgcHJlZmVycmVkU2xhdmVzID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgc2VsZWN0ZWRTbGF2ZSA9IHByZWZlcnJlZFNsYXZlcyhhdmFpbGFibGVTbGF2ZXMpO1xuICAgIH1cbiAgICBlbHNlIGlmIChwcmVmZXJyZWRTbGF2ZXMgIT09IG51bGwgJiYgdHlwZW9mIHByZWZlcnJlZFNsYXZlcyA9PT0gXCJvYmplY3RcIikge1xuICAgICAgICBjb25zdCBwcmVmZXJyZWRTbGF2ZXNBcnJheSA9IEFycmF5LmlzQXJyYXkocHJlZmVycmVkU2xhdmVzKVxuICAgICAgICAgICAgPyBwcmVmZXJyZWRTbGF2ZXNcbiAgICAgICAgICAgIDogW3ByZWZlcnJlZFNsYXZlc107XG4gICAgICAgIC8vIHNvcnQgYnkgcHJpb3JpdHlcbiAgICAgICAgcHJlZmVycmVkU2xhdmVzQXJyYXkuc29ydCgoYSwgYikgPT4ge1xuICAgICAgICAgICAgLy8gZGVmYXVsdCB0aGUgcHJpb3JpdHkgdG8gMVxuICAgICAgICAgICAgaWYgKCFhLnByaW8pIHtcbiAgICAgICAgICAgICAgICBhLnByaW8gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFiLnByaW8pIHtcbiAgICAgICAgICAgICAgICBiLnByaW8gPSAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gbG93ZXN0IHByaW9yaXR5IGZpcnN0XG4gICAgICAgICAgICBpZiAoYS5wcmlvIDwgYi5wcmlvKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGEucHJpbyA+IGIucHJpbykge1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBsb29wIG92ZXIgcHJlZmVycmVkIHNsYXZlcyBhbmQgcmV0dXJuIHRoZSBmaXJzdCBtYXRjaFxuICAgICAgICBmb3IgKGxldCBwID0gMDsgcCA8IHByZWZlcnJlZFNsYXZlc0FycmF5Lmxlbmd0aDsgcCsrKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBhID0gMDsgYSA8IGF2YWlsYWJsZVNsYXZlcy5sZW5ndGg7IGErKykge1xuICAgICAgICAgICAgICAgIGNvbnN0IHNsYXZlID0gYXZhaWxhYmxlU2xhdmVzW2FdO1xuICAgICAgICAgICAgICAgIGlmIChzbGF2ZS5pcCA9PT0gcHJlZmVycmVkU2xhdmVzQXJyYXlbcF0uaXApIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHNsYXZlLnBvcnQgPT09IHByZWZlcnJlZFNsYXZlc0FycmF5W3BdLnBvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkU2xhdmUgPSBzbGF2ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdGVkU2xhdmUpIHtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBpZiBub25lIG9mIHRoZSBwcmVmZXJyZWQgc2xhdmVzIGFyZSBhdmFpbGFibGUsIGEgcmFuZG9tIGF2YWlsYWJsZSBzbGF2ZSBpcyByZXR1cm5lZFxuICAgIGlmICghc2VsZWN0ZWRTbGF2ZSkge1xuICAgICAgICBzZWxlY3RlZFNsYXZlID0gKDAsIHV0aWxzXzEuc2FtcGxlKShhdmFpbGFibGVTbGF2ZXMpO1xuICAgIH1cbiAgICByZXR1cm4gYWRkcmVzc1Jlc3BvbnNlVG9BZGRyZXNzKHNlbGVjdGVkU2xhdmUpO1xufVxuZnVuY3Rpb24gYWRkcmVzc1Jlc3BvbnNlVG9BZGRyZXNzKGlucHV0KSB7XG4gICAgcmV0dXJuIHsgaG9zdDogaW5wdXQuaXAsIHBvcnQ6IE51bWJlcihpbnB1dC5wb3J0KSB9O1xufVxuZnVuY3Rpb24gbm9vcCgpIHsgfVxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/StandaloneConnector.js":
/*!***********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/StandaloneConnector.js ***!
  \***********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst net_1 = __webpack_require__(/*! net */ \"net\");\nconst tls_1 = __webpack_require__(/*! tls */ \"tls\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst AbstractConnector_1 = __webpack_require__(/*! ./AbstractConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/AbstractConnector.js\");\nclass StandaloneConnector extends AbstractConnector_1.default {\n    constructor(options) {\n        super(options.disconnectTimeout);\n        this.options = options;\n    }\n    connect(_) {\n        const { options } = this;\n        this.connecting = true;\n        let connectionOptions;\n        if (\"path\" in options && options.path) {\n            connectionOptions = {\n                path: options.path,\n            };\n        }\n        else {\n            connectionOptions = {};\n            if (\"port\" in options && options.port != null) {\n                connectionOptions.port = options.port;\n            }\n            if (\"host\" in options && options.host != null) {\n                connectionOptions.host = options.host;\n            }\n            if (\"family\" in options && options.family != null) {\n                connectionOptions.family = options.family;\n            }\n        }\n        if (options.tls) {\n            Object.assign(connectionOptions, options.tls);\n        }\n        // TODO:\n        // We use native Promise here since other Promise\n        // implementation may use different schedulers that\n        // cause issue when the stream is resolved in the\n        // next tick.\n        // Should use the provided promise in the next major\n        // version and do not connect before resolved.\n        return new Promise((resolve, reject) => {\n            process.nextTick(() => {\n                if (!this.connecting) {\n                    reject(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n                    return;\n                }\n                try {\n                    if (options.tls) {\n                        this.stream = (0, tls_1.connect)(connectionOptions);\n                    }\n                    else {\n                        this.stream = (0, net_1.createConnection)(connectionOptions);\n                    }\n                }\n                catch (err) {\n                    reject(err);\n                    return;\n                }\n                this.stream.once(\"error\", (err) => {\n                    this.firstError = err;\n                });\n                resolve(this.stream);\n            });\n        });\n    }\n}\nexports[\"default\"] = StandaloneConnector;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9TdGFuZGFsb25lQ29ubmVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGNBQWMsbUJBQU8sQ0FBQyxnQkFBSztBQUMzQixjQUFjLG1CQUFPLENBQUMsZ0JBQUs7QUFDM0IsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsNEJBQTRCLG1CQUFPLENBQUMsb0lBQXFCO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixVQUFVO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Nvbm5lY3RvcnMvU3RhbmRhbG9uZUNvbm5lY3Rvci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IG5ldF8xID0gcmVxdWlyZShcIm5ldFwiKTtcbmNvbnN0IHRsc18xID0gcmVxdWlyZShcInRsc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBBYnN0cmFjdENvbm5lY3Rvcl8xID0gcmVxdWlyZShcIi4vQWJzdHJhY3RDb25uZWN0b3JcIik7XG5jbGFzcyBTdGFuZGFsb25lQ29ubmVjdG9yIGV4dGVuZHMgQWJzdHJhY3RDb25uZWN0b3JfMS5kZWZhdWx0IHtcbiAgICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgICAgIHN1cGVyKG9wdGlvbnMuZGlzY29ubmVjdFRpbWVvdXQpO1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuICAgIH1cbiAgICBjb25uZWN0KF8pIHtcbiAgICAgICAgY29uc3QgeyBvcHRpb25zIH0gPSB0aGlzO1xuICAgICAgICB0aGlzLmNvbm5lY3RpbmcgPSB0cnVlO1xuICAgICAgICBsZXQgY29ubmVjdGlvbk9wdGlvbnM7XG4gICAgICAgIGlmIChcInBhdGhcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgICAgICAgICAgY29ubmVjdGlvbk9wdGlvbnMgPSB7XG4gICAgICAgICAgICAgICAgcGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zID0ge307XG4gICAgICAgICAgICBpZiAoXCJwb3J0XCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLnBvcnQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLnBvcnQgPSBvcHRpb25zLnBvcnQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJob3N0XCIgaW4gb3B0aW9ucyAmJiBvcHRpb25zLmhvc3QgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25PcHRpb25zLmhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoXCJmYW1pbHlcIiBpbiBvcHRpb25zICYmIG9wdGlvbnMuZmFtaWx5ICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uT3B0aW9ucy5mYW1pbHkgPSBvcHRpb25zLmZhbWlseTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy50bHMpIHtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oY29ubmVjdGlvbk9wdGlvbnMsIG9wdGlvbnMudGxzKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUT0RPOlxuICAgICAgICAvLyBXZSB1c2UgbmF0aXZlIFByb21pc2UgaGVyZSBzaW5jZSBvdGhlciBQcm9taXNlXG4gICAgICAgIC8vIGltcGxlbWVudGF0aW9uIG1heSB1c2UgZGlmZmVyZW50IHNjaGVkdWxlcnMgdGhhdFxuICAgICAgICAvLyBjYXVzZSBpc3N1ZSB3aGVuIHRoZSBzdHJlYW0gaXMgcmVzb2x2ZWQgaW4gdGhlXG4gICAgICAgIC8vIG5leHQgdGljay5cbiAgICAgICAgLy8gU2hvdWxkIHVzZSB0aGUgcHJvdmlkZWQgcHJvbWlzZSBpbiB0aGUgbmV4dCBtYWpvclxuICAgICAgICAvLyB2ZXJzaW9uIGFuZCBkbyBub3QgY29ubmVjdCBiZWZvcmUgcmVzb2x2ZWQuXG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICBwcm9jZXNzLm5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QobmV3IEVycm9yKHV0aWxzXzEuQ09OTkVDVElPTl9DTE9TRURfRVJST1JfTVNHKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wdGlvbnMudGxzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9ICgwLCB0bHNfMS5jb25uZWN0KShjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbSA9ICgwLCBuZXRfMS5jcmVhdGVDb25uZWN0aW9uKShjb25uZWN0aW9uT3B0aW9ucyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB0aGlzLnN0cmVhbS5vbmNlKFwiZXJyb3JcIiwgKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpcnN0RXJyb3IgPSBlcnI7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZSh0aGlzLnN0cmVhbSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gU3RhbmRhbG9uZUNvbm5lY3RvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/StandaloneConnector.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/index.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/index.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SentinelConnector = exports.StandaloneConnector = void 0;\nconst StandaloneConnector_1 = __webpack_require__(/*! ./StandaloneConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/StandaloneConnector.js\");\nexports.StandaloneConnector = StandaloneConnector_1.default;\nconst SentinelConnector_1 = __webpack_require__(/*! ./SentinelConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nexports.SentinelConnector = SentinelConnector_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29ubmVjdG9ycy9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx5QkFBeUIsR0FBRywyQkFBMkI7QUFDdkQsOEJBQThCLG1CQUFPLENBQUMsd0lBQXVCO0FBQzdELDJCQUEyQjtBQUMzQiw0QkFBNEIsbUJBQU8sQ0FBQywwSUFBcUI7QUFDekQseUJBQXlCIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9jb25uZWN0b3JzL2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TZW50aW5lbENvbm5lY3RvciA9IGV4cG9ydHMuU3RhbmRhbG9uZUNvbm5lY3RvciA9IHZvaWQgMDtcbmNvbnN0IFN0YW5kYWxvbmVDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL1N0YW5kYWxvbmVDb25uZWN0b3JcIik7XG5leHBvcnRzLlN0YW5kYWxvbmVDb25uZWN0b3IgPSBTdGFuZGFsb25lQ29ubmVjdG9yXzEuZGVmYXVsdDtcbmNvbnN0IFNlbnRpbmVsQ29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9TZW50aW5lbENvbm5lY3RvclwiKTtcbmV4cG9ydHMuU2VudGluZWxDb25uZWN0b3IgPSBTZW50aW5lbENvbm5lY3Rvcl8xLmRlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/constants/TLSProfiles.js":
/*!**************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/constants/TLSProfiles.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/**\n * TLS settings for Redis Cloud. Updated on 2022-08-19.\n */\nconst RedisCloudCA = `-----BEGIN CERTIFICATE-----\nMIIDTzCCAjegAwIBAgIJAKSVpiDswLcwMA0GCSqGSIb3DQEBBQUAMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTAeFw0xMzEwMDExMjE0NTVaFw0yMzA5MjkxMjE0NTVaMD4xFjAUBgNV\nBAoMDUdhcmFudGlhIERhdGExJDAiBgNVBAMMG1NTTCBDZXJ0aWZpY2F0aW9uIEF1\ndGhvcml0eTCCASIwDQYJKoZIhvcNAQEBBQADggEPADCCAQoCggEBALZqkh/DczWP\nJnxnHLQ7QL0T4B4CDKWBKCcisriGbA6ZePWVNo4hfKQC6JrzfR+081NeD6VcWUiz\nrmd+jtPhIY4c+WVQYm5PKaN6DT1imYdxQw7aqO5j2KUCEh/cznpLxeSHoTxlR34E\nQwF28Wl3eg2vc5ct8LjU3eozWVk3gb7alx9mSA2SgmuX5lEQawl++rSjsBStemY2\nBDwOpAMXIrdEyP/cVn8mkvi/BDs5M5G+09j0gfhyCzRWMQ7Hn71u1eolRxwVxgi3\nTMn+/vTaFSqxKjgck6zuAYjBRPaHe7qLxHNr1So/Mc9nPy+3wHebFwbIcnUojwbp\n4nctkWbjb2cCAwEAAaNQME4wHQYDVR0OBBYEFP1whtcrydmW3ZJeuSoKZIKjze3w\nMB8GA1UdIwQYMBaAFP1whtcrydmW3ZJeuSoKZIKjze3wMAwGA1UdEwQFMAMBAf8w\nDQYJKoZIhvcNAQEFBQADggEBAG2erXhwRAa7+ZOBs0B6X57Hwyd1R4kfmXcs0rta\nlbPpvgULSiB+TCbf3EbhJnHGyvdCY1tvlffLjdA7HJ0PCOn+YYLBA0pTU/dyvrN6\nSu8NuS5yubnt9mb13nDGYo1rnt0YRfxN+8DM3fXIVr038A30UlPX2Ou1ExFJT0MZ\nuFKY6ZvLdI6/1cbgmguMlAhM+DhKyV6Sr5699LM3zqeI816pZmlREETYkGr91q7k\nBpXJu/dtHaGxg1ZGu6w/PCsYGUcECWENYD4VQPd8N32JjOfu6vEgoEAwfPP+3oGp\nZ4m3ewACcWOAenqflb+cQYC4PsF7qbXDmRaWrbKntOlZ3n0=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIGMTCCBBmgAwIBAgICEAAwDQYJKoZIhvcNAQELBQAwajELMAkGA1UEBhMCVVMx\nCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJzMS0w\nKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwHhcN\nMTgwMjI1MTUzNzM3WhcNMjgwMjIzMTUzNzM3WjBfMQswCQYDVQQGEwJVUzELMAkG\nA1UECAwCQ0ExEjAQBgNVBAoMCVJlZGlzTGFiczEvMC0GA1UEAwwmUkNQIEludGVy\nbWVkaWF0ZSBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkwggIiMA0GCSqGSIb3DQEBAQUA\nA4ICDwAwggIKAoICAQDf9dqbxc8Bq7Ctq9rWcxrGNKKHivqLAFpPq02yLPx6fsOv\nTq7GsDChAYBBc4v7Y2Ap9RD5Vs3dIhEANcnolf27QwrG9RMnnvzk8pCvp1o6zSU4\nVuOE1W66/O1/7e2rVxyrnTcP7UgK43zNIXu7+tiAqWsO92uSnuMoGPGpeaUm1jym\nhjWKtkAwDFSqvHY+XL5qDVBEjeUe+WHkYUg40cAXjusAqgm2hZt29c2wnVrxW25W\nP0meNlzHGFdA2AC5z54iRiqj57dTfBTkHoBczQxcyw6hhzxZQ4e5I5zOKjXXEhZN\nr0tA3YC14CTabKRus/JmZieyZzRgEy2oti64tmLYTqSlAD78pRL40VNoaSYetXLw\nhhNsXCHgWaY6d5bLOc/aIQMAV5oLvZQKvuXAF1IDmhPA+bZbpWipp0zagf1P1H3s\nUzsMdn2KM0ejzgotbtNlj5TcrVwpmvE3ktvUAuA+hi3FkVx1US+2Gsp5x4YOzJ7u\nP1WPk6ShF0JgnJH2ILdj6kttTWwFzH17keSFICWDfH/+kM+k7Y1v3EXMQXE7y0T9\nMjvJskz6d/nv+sQhY04xt64xFMGTnZjlJMzfQNi7zWFLTZnDD0lPowq7l3YiPoTT\nt5Xky83lu0KZsZBo0WlWaDG00gLVdtRgVbcuSWxpi5BdLb1kRab66JptWjxwXQID\nAQABo4HrMIHoMDoGA1UdHwQzMDEwL6AtoCuGKWh0dHBzOi8vcmwtY2Etc2VydmVy\nLnJlZGlzbGFicy5jb20vdjEvY3JsMEYGCCsGAQUFBwEBBDowODA2BggrBgEFBQcw\nAYYqaHR0cHM6Ly9ybC1jYS1zZXJ2ZXIucmVkaXNsYWJzLmNvbS92MS9vY3NwMB0G\nA1UdDgQWBBQHar5OKvQUpP2qWt6mckzToeCOHDAfBgNVHSMEGDAWgBQi42wH6hM4\nL2sujEvLM0/u8lRXTzASBgNVHRMBAf8ECDAGAQH/AgEAMA4GA1UdDwEB/wQEAwIB\nhjANBgkqhkiG9w0BAQsFAAOCAgEAirEn/iTsAKyhd+pu2W3Z5NjCko4NPU0EYUbr\nAP7+POK2rzjIrJO3nFYQ/LLuC7KCXG+2qwan2SAOGmqWst13Y+WHp44Kae0kaChW\nvcYLXXSoGQGC8QuFSNUdaeg3RbMDYFT04dOkqufeWVccoHVxyTSg9eD8LZuHn5jw\n7QDLiEECBmIJHk5Eeo2TAZrx4Yx6ufSUX5HeVjlAzqwtAqdt99uCJ/EL8bgpWbe+\nXoSpvUv0SEC1I1dCAhCKAvRlIOA6VBcmzg5Am12KzkqTul12/VEFIgzqu0Zy2Jbc\nAUPrYVu/+tOGXQaijy7YgwH8P8n3s7ZeUa1VABJHcxrxYduDDJBLZi+MjheUDaZ1\njQRHYevI2tlqeSBqdPKG4zBY5lS0GiAlmuze5oENt0P3XboHoZPHiqcK3VECgTVh\n/BkJcuudETSJcZDmQ8YfoKfBzRQNg2sv/hwvUv73Ss51Sco8GEt2lD8uEdib1Q6z\nzDT5lXJowSzOD5ZA9OGDjnSRL+2riNtKWKEqvtEG3VBJoBzu9GoxbAc7wIZLxmli\niF5a/Zf5X+UXD3s4TMmy6C4QZJpAA2egsSQCnraWO2ULhh7iXMysSkF/nzVfZn43\niqpaB8++9a37hWq14ZmOv0TJIDz//b2+KC4VFXWQ5W5QC6whsjT+OlG4p5ZYG0jo\n616pxqo=\n-----END CERTIFICATE-----\n-----BEGIN CERTIFICATE-----\nMIIFujCCA6KgAwIBAgIJAJ1aTT1lu2ScMA0GCSqGSIb3DQEBCwUAMGoxCzAJBgNV\nBAYTAlVTMQswCQYDVQQIDAJDQTELMAkGA1UEBwwCQ0ExEjAQBgNVBAoMCVJlZGlz\nTGFiczEtMCsGA1UEAwwkUmVkaXNMYWJzIFJvb3QgQ2VydGlmaWNhdGUgQXV0aG9y\naXR5MB4XDTE4MDIyNTE1MjA0MloXDTM4MDIyMDE1MjA0MlowajELMAkGA1UEBhMC\nVVMxCzAJBgNVBAgMAkNBMQswCQYDVQQHDAJDQTESMBAGA1UECgwJUmVkaXNMYWJz\nMS0wKwYDVQQDDCRSZWRpc0xhYnMgUm9vdCBDZXJ0aWZpY2F0ZSBBdXRob3JpdHkw\nggIiMA0GCSqGSIb3DQEBAQUAA4ICDwAwggIKAoICAQDLEjXy7YrbN5Waau5cd6g1\nG5C2tMmeTpZ0duFAPxNU4oE3RHS5gGiok346fUXuUxbZ6QkuzeN2/2Z+RmRcJhQY\nDm0ZgdG4x59An1TJfnzKKoWj8ISmoHS/TGNBdFzXV7FYNLBuqZouqePI6ReC6Qhl\npp45huV32Q3a6IDrrvx7Wo5ZczEQeFNbCeCOQYNDdTmCyEkHqc2AGo8eoIlSTutT\nULOC7R5gzJVTS0e1hesQ7jmqHjbO+VQS1NAL4/5K6cuTEqUl+XhVhPdLWBXJQ5ag\n54qhX4v+ojLzeU1R/Vc6NjMvVtptWY6JihpgplprN0Yh2556ewcXMeturcKgXfGJ\nxeYzsjzXerEjrVocX5V8BNrg64NlifzTMKNOOv4fVZszq1SIHR8F9ROrqiOdh8iC\nJpUbLpXH9hWCSEO6VRMB2xJoKu3cgl63kF30s77x7wLFMEHiwsQRKxooE1UhgS9K\n2sO4TlQ1eWUvFvHSTVDQDlGQ6zu4qjbOpb3Q8bQwoK+ai2alkXVR4Ltxe9QlgYK3\nStsnPhruzZGA0wbXdpw0bnM+YdlEm5ffSTpNIfgHeaa7Dtb801FtA71ZlH7A6TaI\nSIQuUST9EKmv7xrJyx0W1pGoPOLw5T029aTjnICSLdtV9bLwysrLhIYG5bnPq78B\ncS+jZHFGzD7PUVGQD01nOQIDAQABo2MwYTAdBgNVHQ4EFgQUIuNsB+oTOC9rLoxL\nyzNP7vJUV08wHwYDVR0jBBgwFoAUIuNsB+oTOC9rLoxLyzNP7vJUV08wDwYDVR0T\nAQH/BAUwAwEB/zAOBgNVHQ8BAf8EBAMCAYYwDQYJKoZIhvcNAQELBQADggIBAHfg\nz5pMNUAKdMzK1aS1EDdK9yKz4qicILz5czSLj1mC7HKDRy8cVADUxEICis++CsCu\nrYOvyCVergHQLREcxPq4rc5Nq1uj6J6649NEeh4WazOOjL4ZfQ1jVznMbGy+fJm3\n3Hoelv6jWRG9iqeJZja7/1s6YC6bWymI/OY1e4wUKeNHAo+Vger7MlHV+RuabaX+\nhSJ8bJAM59NCM7AgMTQpJCncrcdLeceYniGy5Q/qt2b5mJkQVkIdy4TPGGB+AXDJ\nD0q3I/JDRkDUFNFdeW0js7fHdsvCR7O3tJy5zIgEV/o/BCkmJVtuwPYOrw/yOlKj\nTY/U7ATAx9VFF6/vYEOMYSmrZlFX+98L6nJtwDqfLB5VTltqZ4H/KBxGE3IRSt9l\nFXy40U+LnXzhhW+7VBAvyYX8GEXhHkKU8Gqk1xitrqfBXY74xKgyUSTolFSfFVgj\nmcM/X4K45bka+qpkj7Kfv/8D4j6aZekwhN2ly6hhC1SmQ8qjMjpG/mrWOSSHZFmf\nybu9iD2AYHeIOkshIl6xYIa++Q/00/vs46IzAbQyriOi0XxlSMMVtPx0Q3isp+ji\nn8Mq9eOuxYOEQ4of8twUkUDd528iwGtEdwf0Q01UyT84S62N8AySl1ZBKXJz6W4F\nUhWfa/HQYOAPDdEjNgnVwLI23b8t0TozyCWw7q8h\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIEjzCCA3egAwIBAgIQe55B/ALCKJDZtdNT8kD6hTANBgkqhkiG9w0BAQsFADBM\nMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEGA1UEChMKR2xv\nYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjAeFw0yMjAxMjYxMjAwMDBaFw0y\nNTAxMjYwMDAwMDBaMFgxCzAJBgNVBAYTAkJFMRkwFwYDVQQKExBHbG9iYWxTaWdu\nIG52LXNhMS4wLAYDVQQDEyVHbG9iYWxTaWduIEF0bGFzIFIzIE9WIFRMUyBDQSAy\nMDIyIFEyMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAmGmg1LW9b7Lf\n8zDD83yBDTEkt+FOxKJZqF4veWc5KZsQj9HfnUS2e5nj/E+JImlGPsQuoiosLuXD\nBVBNAMcUFa11buFMGMeEMwiTmCXoXRrXQmH0qjpOfKgYc5gHG3BsRGaRrf7VR4eg\nofNMG9wUBw4/g/TT7+bQJdA4NfE7Y4d5gEryZiBGB/swaX6Jp/8MF4TgUmOWmalK\ndZCKyb4sPGQFRTtElk67F7vU+wdGcrcOx1tDcIB0ncjLPMnaFicagl+daWGsKqTh\ncounQb6QJtYHa91KvCfKWocMxQ7OIbB5UARLPmC4CJ1/f8YFm35ebfzAeULYdGXu\njE9CLor0OwIDAQABo4IBXzCCAVswDgYDVR0PAQH/BAQDAgGGMB0GA1UdJQQWMBQG\nCCsGAQUFBwMBBggrBgEFBQcDAjASBgNVHRMBAf8ECDAGAQH/AgEAMB0GA1UdDgQW\nBBSH5Zq7a7B/t95GfJWkDBpA8HHqdjAfBgNVHSMEGDAWgBSP8Et/qC5FJK5NUPpj\nmove4t0bvDB7BggrBgEFBQcBAQRvMG0wLgYIKwYBBQUHMAGGImh0dHA6Ly9vY3Nw\nMi5nbG9iYWxzaWduLmNvbS9yb290cjMwOwYIKwYBBQUHMAKGL2h0dHA6Ly9zZWN1\ncmUuZ2xvYmFsc2lnbi5jb20vY2FjZXJ0L3Jvb3QtcjMuY3J0MDYGA1UdHwQvMC0w\nK6ApoCeGJWh0dHA6Ly9jcmwuZ2xvYmFsc2lnbi5jb20vcm9vdC1yMy5jcmwwIQYD\nVR0gBBowGDAIBgZngQwBAgIwDAYKKwYBBAGgMgoBAjANBgkqhkiG9w0BAQsFAAOC\nAQEAKRic9/f+nmhQU/wz04APZLjgG5OgsuUOyUEZjKVhNGDwxGTvKhyXGGAMW2B/\n3bRi+aElpXwoxu3pL6fkElbX3B0BeS5LoDtxkyiVEBMZ8m+sXbocwlPyxrPbX6mY\n0rVIvnuUeBH8X0L5IwfpNVvKnBIilTbcebfHyXkPezGwz7E1yhUULjJFm2bt0SdX\ny+4X/WeiiYIv+fTVgZZgl+/2MKIsu/qdBJc3f3TvJ8nz+Eax1zgZmww+RSQWeOj3\n15Iw6Z5FX+NwzY/Ab+9PosR5UosSeq+9HhtaxZttXG1nVh+avYPGYddWmiMT90J5\nZgKnO/Fx2hBgTxhOTMYaD312kg==\n-----END CERTIFICATE-----\n\n-----BEGIN CERTIFICATE-----\nMIIDXzCCAkegAwIBAgILBAAAAAABIVhTCKIwDQYJKoZIhvcNAQELBQAwTDEgMB4G\nA1UECxMXR2xvYmFsU2lnbiBSb290IENBIC0gUjMxEzARBgNVBAoTCkdsb2JhbFNp\nZ24xEzARBgNVBAMTCkdsb2JhbFNpZ24wHhcNMDkwMzE4MTAwMDAwWhcNMjkwMzE4\nMTAwMDAwWjBMMSAwHgYDVQQLExdHbG9iYWxTaWduIFJvb3QgQ0EgLSBSMzETMBEG\nA1UEChMKR2xvYmFsU2lnbjETMBEGA1UEAxMKR2xvYmFsU2lnbjCCASIwDQYJKoZI\nhvcNAQEBBQADggEPADCCAQoCggEBAMwldpB5BngiFvXAg7aEyiie/QV2EcWtiHL8\nRgJDx7KKnQRfJMsuS+FggkbhUqsMgUdwbN1k0ev1LKMPgj0MK66X17YUhhB5uzsT\ngHeMCOFJ0mpiLx9e+pZo34knlTifBtc+ycsmWQ1z3rDI6SYOgxXG71uL0gRgykmm\nKPZpO/bLyCiR5Z2KYVc3rHQU3HTgOu5yLy6c+9C7v/U9AOEGM+iCK65TpjoWc4zd\nQQ4gOsC0p6Hpsk+QLjJg6VfLuQSSaGjlOCZgdbKfd/+RFO+uIEn8rUAVSNECMWEZ\nXriX7613t2Saer9fwRPvm2L7DWzgVGkWqQPabumDk3F2xmmFghcCAwEAAaNCMEAw\nDgYDVR0PAQH/BAQDAgEGMA8GA1UdEwEB/wQFMAMBAf8wHQYDVR0OBBYEFI/wS3+o\nLkUkrk1Q+mOai97i3Ru8MA0GCSqGSIb3DQEBCwUAA4IBAQBLQNvAUKr+yAzv95ZU\nRUm7lgAJQayzE4aGKAczymvmdLm6AC2upArT9fHxD4q/c2dKg8dEe3jgr25sbwMp\njjM5RcOO5LlXbKr8EpbsU8Yt5CRsuZRj+9xTaGdWPoO4zzUhw8lo/s7awlOqzJCK\n6fBdRoyV3XpYKBovHd7NADdBj+1EbddTKJd+82cEHhXXipa0095MJ6RMG3NzdvQX\nmcIfeg7jLQitChws/zyrVQ4PkX4268NXSb7hLi18YIvDQVETI53O9zJrlAGomecs\nMx86OyXShkDOOyyGeMlhLxS67ttVb9+E7gUJTb0o2HLO02JQZR7rkpeDMdmztcpH\nWD9f\n-----END CERTIFICATE-----`;\nconst TLSProfiles = {\n    RedisCloudFixed: { ca: RedisCloudCA },\n    RedisCloudFlexible: { ca: RedisCloudCA },\n};\nexports[\"default\"] = TLSProfiles;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvY29uc3RhbnRzL1RMU1Byb2ZpbGVzLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGtCQUFrQjtBQUN6QywwQkFBMEIsa0JBQWtCO0FBQzVDO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2NvbnN0YW50cy9UTFNQcm9maWxlcy5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKlxuICogVExTIHNldHRpbmdzIGZvciBSZWRpcyBDbG91ZC4gVXBkYXRlZCBvbiAyMDIyLTA4LTE5LlxuICovXG5jb25zdCBSZWRpc0Nsb3VkQ0EgPSBgLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlEVHpDQ0FqZWdBd0lCQWdJSkFLU1ZwaURzd0xjd01BMEdDU3FHU0liM0RRRUJCUVVBTUQ0eEZqQVVCZ05WXG5CQW9NRFVkaGNtRnVkR2xoSUVSaGRHRXhKREFpQmdOVkJBTU1HMU5UVENCRFpYSjBhV1pwWTJGMGFXOXVJRUYxXG5kR2h2Y21sMGVUQWVGdzB4TXpFd01ERXhNakUwTlRWYUZ3MHlNekE1TWpreE1qRTBOVFZhTUQ0eEZqQVVCZ05WXG5CQW9NRFVkaGNtRnVkR2xoSUVSaGRHRXhKREFpQmdOVkJBTU1HMU5UVENCRFpYSjBhV1pwWTJGMGFXOXVJRUYxXG5kR2h2Y21sMGVUQ0NBU0l3RFFZSktvWklodmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQUxacWtoL0RjeldQXG5KbnhuSExRN1FMMFQ0QjRDREtXQktDY2lzcmlHYkE2WmVQV1ZObzRoZktRQzZKcnpmUiswODFOZUQ2VmNXVWl6XG5ybWQranRQaElZNGMrV1ZRWW01UEthTjZEVDFpbVlkeFF3N2FxTzVqMktVQ0VoL2N6bnBMeGVTSG9UeGxSMzRFXG5Rd0YyOFdsM2VnMnZjNWN0OExqVTNlb3pXVmszZ2I3YWx4OW1TQTJTZ211WDVsRVFhd2wrK3JTanNCU3RlbVkyXG5CRHdPcEFNWElyZEV5UC9jVm44bWt2aS9CRHM1TTVHKzA5ajBnZmh5Q3pSV01RN0huNzF1MWVvbFJ4d1Z4Z2kzXG5UTW4rL3ZUYUZTcXhLamdjazZ6dUFZakJSUGFIZTdxTHhITnIxU28vTWM5blB5KzN3SGViRndiSWNuVW9qd2JwXG40bmN0a1diamIyY0NBd0VBQWFOUU1FNHdIUVlEVlIwT0JCWUVGUDF3aHRjcnlkbVczWkpldVNvS1pJS2p6ZTN3XG5NQjhHQTFVZEl3UVlNQmFBRlAxd2h0Y3J5ZG1XM1pKZXVTb0taSUtqemUzd01Bd0dBMVVkRXdRRk1BTUJBZjh3XG5EUVlKS29aSWh2Y05BUUVGQlFBRGdnRUJBRzJlclhod1JBYTcrWk9CczBCNlg1N0h3eWQxUjRrZm1YY3MwcnRhXG5sYlBwdmdVTFNpQitUQ2JmM0ViaEpuSEd5dmRDWTF0dmxmZkxqZEE3SEowUENPbitZWUxCQTBwVFUvZHl2ck42XG5TdThOdVM1eXVibnQ5bWIxM25ER1lvMXJudDBZUmZ4Tis4RE0zZlhJVnIwMzhBMzBVbFBYMk91MUV4RkpUME1aXG51RktZNlp2TGRJNi8xY2JnbWd1TWxBaE0rRGhLeVY2U3I1Njk5TE0zenFlSTgxNnBabWxSRUVUWWtHcjkxcTdrXG5CcFhKdS9kdEhhR3hnMVpHdTZ3L1BDc1lHVWNFQ1dFTllENFZRUGQ4TjMySmpPZnU2dkVnb0VBd2ZQUCszb0dwXG5aNG0zZXdBQ2NXT0FlbnFmbGIrY1FZQzRQc0Y3cWJYRG1SYVdyYktudE9sWjNuMD1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cbi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJR01UQ0NCQm1nQXdJQkFnSUNFQUF3RFFZSktvWklodmNOQVFFTEJRQXdhakVMTUFrR0ExVUVCaE1DVlZNeFxuQ3pBSkJnTlZCQWdNQWtOQk1Rc3dDUVlEVlFRSERBSkRRVEVTTUJBR0ExVUVDZ3dKVW1Wa2FYTk1ZV0p6TVMwd1xuS3dZRFZRUUREQ1JTWldScGMweGhZbk1nVW05dmRDQkRaWEowYVdacFkyRjBaU0JCZFhSb2IzSnBkSGt3SGhjTlxuTVRnd01qSTFNVFV6TnpNM1doY05Namd3TWpJek1UVXpOek0zV2pCZk1Rc3dDUVlEVlFRR0V3SlZVekVMTUFrR1xuQTFVRUNBd0NRMEV4RWpBUUJnTlZCQW9NQ1ZKbFpHbHpUR0ZpY3pFdk1DMEdBMVVFQXd3bVVrTlFJRWx1ZEdWeVxuYldWa2FXRjBaU0JEWlhKMGFXWnBZMkYwWlNCQmRYUm9iM0pwZEhrd2dnSWlNQTBHQ1NxR1NJYjNEUUVCQVFVQVxuQTRJQ0R3QXdnZ0lLQW9JQ0FRRGY5ZHFieGM4QnE3Q3RxOXJXY3hyR05LS0hpdnFMQUZwUHEwMnlMUHg2ZnNPdlxuVHE3R3NEQ2hBWUJCYzR2N1kyQXA5UkQ1VnMzZEloRUFOY25vbGYyN1F3ckc5Uk1ubnZ6azhwQ3ZwMW82elNVNFxuVnVPRTFXNjYvTzEvN2UyclZ4eXJuVGNQN1VnSzQzek5JWHU3K3RpQXFXc085MnVTbnVNb0dQR3BlYVVtMWp5bVxuaGpXS3RrQXdERlNxdkhZK1hMNXFEVkJFamVVZStXSGtZVWc0MGNBWGp1c0FxZ20yaFp0MjljMnduVnJ4VzI1V1xuUDBtZU5sekhHRmRBMkFDNXo1NGlSaXFqNTdkVGZCVGtIb0JjelF4Y3l3NmhoenhaUTRlNUk1ek9LalhYRWhaTlxucjB0QTNZQzE0Q1RhYktSdXMvSm1aaWV5WnpSZ0V5Mm90aTY0dG1MWVRxU2xBRDc4cFJMNDBWTm9hU1lldFhMd1xuaGhOc1hDSGdXYVk2ZDViTE9jL2FJUU1BVjVvTHZaUUt2dVhBRjFJRG1oUEErYlpicFdpcHAwemFnZjFQMUgzc1xuVXpzTWRuMktNMGVqemdvdGJ0TmxqNVRjclZ3cG12RTNrdHZVQXVBK2hpM0ZrVngxVVMrMkdzcDV4NFlPeko3dVxuUDFXUGs2U2hGMEpnbkpIMklMZGo2a3R0VFd3RnpIMTdrZVNGSUNXRGZILytrTStrN1kxdjNFWE1RWEU3eTBUOVxuTWp2SnNrejZkL252K3NRaFkwNHh0NjR4Rk1HVG5aamxKTXpmUU5pN3pXRkxUWm5ERDBsUG93cTdsM1lpUG9UVFxudDVYa3k4M2x1MEtac1pCbzBXbFdhREcwMGdMVmR0UmdWYmN1U1d4cGk1QmRMYjFrUmFiNjZKcHRXanh3WFFJRFxuQVFBQm80SHJNSUhvTURvR0ExVWRId1F6TURFd0w2QXRvQ3VHS1doMGRIQnpPaTh2Y213dFkyRXRjMlZ5ZG1WeVxuTG5KbFpHbHpiR0ZpY3k1amIyMHZkakV2WTNKc01FWUdDQ3NHQVFVRkJ3RUJCRG93T0RBMkJnZ3JCZ0VGQlFjd1xuQVlZcWFIUjBjSE02THk5eWJDMWpZUzF6WlhKMlpYSXVjbVZrYVhOc1lXSnpMbU52YlM5Mk1TOXZZM053TUIwR1xuQTFVZERnUVdCQlFIYXI1T0t2UVVwUDJxV3Q2bWNrelRvZUNPSERBZkJnTlZIU01FR0RBV2dCUWk0MndINmhNNFxuTDJzdWpFdkxNMC91OGxSWFR6QVNCZ05WSFJNQkFmOEVDREFHQVFIL0FnRUFNQTRHQTFVZER3RUIvd1FFQXdJQlxuaGpBTkJna3Foa2lHOXcwQkFRc0ZBQU9DQWdFQWlyRW4vaVRzQUt5aGQrcHUyVzNaNU5qQ2tvNE5QVTBFWVViclxuQVA3K1BPSzJyempJckpPM25GWVEvTEx1QzdLQ1hHKzJxd2FuMlNBT0dtcVdzdDEzWStXSHA0NEthZTBrYUNoV1xudmNZTFhYU29HUUdDOFF1RlNOVWRhZWczUmJNRFlGVDA0ZE9rcXVmZVdWY2NvSFZ4eVRTZzllRDhMWnVIbjVqd1xuN1FETGlFRUNCbUlKSGs1RWVvMlRBWnJ4NFl4NnVmU1VYNUhlVmpsQXpxd3RBcWR0OTl1Q0ovRUw4YmdwV2JlK1xuWG9TcHZVdjBTRUMxSTFkQ0FoQ0tBdlJsSU9BNlZCY216ZzVBbTEyS3prcVR1bDEyL1ZFRklnenF1MFp5MkpiY1xuQVVQcllWdS8rdE9HWFFhaWp5N1lnd0g4UDhuM3M3WmVVYTFWQUJKSGN4cnhZZHVEREpCTFppK01qaGVVRGFaMVxualFSSFlldkkydGxxZVNCcWRQS0c0ekJZNWxTMEdpQWxtdXplNW9FTnQwUDNYYm9Ib1pQSGlxY0szVkVDZ1RWaFxuL0JrSmN1dWRFVFNKY1pEbVE4WWZvS2ZCelJRTmcyc3YvaHd2VXY3M1NzNTFTY284R0V0MmxEOHVFZGliMVE2elxuekRUNWxYSm93U3pPRDVaQTlPR0RqblNSTCsycmlOdEtXS0VxdnRFRzNWQkpvQnp1OUdveGJBYzd3SVpMeG1saVxuaUY1YS9aZjVYK1VYRDNzNFRNbXk2QzRRWkpwQUEyZWdzU1FDbnJhV08yVUxoaDdpWE15c1NrRi9uelZmWm40M1xuaXFwYUI4Kys5YTM3aFdxMTRabU92MFRKSUR6Ly9iMitLQzRWRlhXUTVXNVFDNndoc2pUK09sRzRwNVpZRzBqb1xuNjE2cHhxbz1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cbi0tLS0tQkVHSU4gQ0VSVElGSUNBVEUtLS0tLVxuTUlJRnVqQ0NBNktnQXdJQkFnSUpBSjFhVFQxbHUyU2NNQTBHQ1NxR1NJYjNEUUVCQ3dVQU1Hb3hDekFKQmdOVlxuQkFZVEFsVlRNUXN3Q1FZRFZRUUlEQUpEUVRFTE1Ba0dBMVVFQnd3Q1EwRXhFakFRQmdOVkJBb01DVkpsWkdselxuVEdGaWN6RXRNQ3NHQTFVRUF3d2tVbVZrYVhOTVlXSnpJRkp2YjNRZ1EyVnlkR2xtYVdOaGRHVWdRWFYwYUc5eVxuYVhSNU1CNFhEVEU0TURJeU5URTFNakEwTWxvWERUTTRNREl5TURFMU1qQTBNbG93YWpFTE1Ba0dBMVVFQmhNQ1xuVlZNeEN6QUpCZ05WQkFnTUFrTkJNUXN3Q1FZRFZRUUhEQUpEUVRFU01CQUdBMVVFQ2d3SlVtVmthWE5NWVdKelxuTVMwd0t3WURWUVFERENSU1pXUnBjMHhoWW5NZ1VtOXZkQ0JEWlhKMGFXWnBZMkYwWlNCQmRYUm9iM0pwZEhrd1xuZ2dJaU1BMEdDU3FHU0liM0RRRUJBUVVBQTRJQ0R3QXdnZ0lLQW9JQ0FRRExFalh5N1lyYk41V2FhdTVjZDZnMVxuRzVDMnRNbWVUcFowZHVGQVB4TlU0b0UzUkhTNWdHaW9rMzQ2ZlVYdVV4Ylo2UWt1emVOMi8yWitSbVJjSmhRWVxuRG0wWmdkRzR4NTlBbjFUSmZuektLb1dqOElTbW9IUy9UR05CZEZ6WFY3RllOTEJ1cVpvdXFlUEk2UmVDNlFobFxucHA0NWh1VjMyUTNhNklEcnJ2eDdXbzVaY3pFUWVGTmJDZUNPUVlORGRUbUN5RWtIcWMyQUdvOGVvSWxTVHV0VFxuVUxPQzdSNWd6SlZUUzBlMWhlc1E3am1xSGpiTytWUVMxTkFMNC81SzZjdVRFcVVsK1hoVmhQZExXQlhKUTVhZ1xuNTRxaFg0ditvakx6ZVUxUi9WYzZOak12VnRwdFdZNkppaHBncGxwck4wWWgyNTU2ZXdjWE1ldHVyY0tnWGZHSlxueGVZenNqelhlckVqclZvY1g1VjhCTnJnNjRObGlmelRNS05PT3Y0ZlZac3pxMVNJSFI4RjlST3JxaU9kaDhpQ1xuSnBVYkxwWEg5aFdDU0VPNlZSTUIyeEpvS3UzY2dsNjNrRjMwczc3eDd3TEZNRUhpd3NRUkt4b29FMVVoZ1M5S1xuMnNPNFRsUTFlV1V2RnZIU1RWRFFEbEdRNnp1NHFqYk9wYjNROGJRd29LK2FpMmFsa1hWUjRMdHhlOVFsZ1lLM1xuU3RzblBocnV6WkdBMHdiWGRwdzBibk0rWWRsRW01ZmZTVHBOSWZnSGVhYTdEdGI4MDFGdEE3MVpsSDdBNlRhSVxuU0lRdVVTVDlFS212N3hySnl4MFcxcEdvUE9MdzVUMDI5YVRqbklDU0xkdFY5Ykx3eXNyTGhJWUc1Ym5QcTc4QlxuY1MralpIRkd6RDdQVVZHUUQwMW5PUUlEQVFBQm8yTXdZVEFkQmdOVkhRNEVGZ1FVSXVOc0Irb1RPQzlyTG94TFxueXpOUDd2SlVWMDh3SHdZRFZSMGpCQmd3Rm9BVUl1TnNCK29UT0M5ckxveEx5ek5QN3ZKVVYwOHdEd1lEVlIwVFxuQVFIL0JBVXdBd0VCL3pBT0JnTlZIUThCQWY4RUJBTUNBWVl3RFFZSktvWklodmNOQVFFTEJRQURnZ0lCQUhmZ1xuejVwTU5VQUtkTXpLMWFTMUVEZEs5eUt6NHFpY0lMejVjelNMajFtQzdIS0RSeThjVkFEVXhFSUNpcysrQ3NDdVxucllPdnlDVmVyZ0hRTFJFY3hQcTRyYzVOcTF1ajZKNjY0OU5FZWg0V2F6T09qTDRaZlExalZ6bk1iR3krZkptM1xuM0hvZWx2NmpXUkc5aXFlSlpqYTcvMXM2WUM2Yld5bUkvT1kxZTR3VUtlTkhBbytWZ2VyN01sSFYrUnVhYmFYK1xuaFNKOGJKQU01OU5DTTdBZ01UUXBKQ25jcmNkTGVjZVluaUd5NVEvcXQyYjVtSmtRVmtJZHk0VFBHR0IrQVhESlxuRDBxM0kvSkRSa0RVRk5GZGVXMGpzN2ZIZHN2Q1I3TzN0Snk1eklnRVYvby9CQ2ttSlZ0dXdQWU9ydy95T2xLalxuVFkvVTdBVEF4OVZGRjYvdllFT01ZU21yWmxGWCs5OEw2bkp0d0RxZkxCNVZUbHRxWjRIL0tCeEdFM0lSU3Q5bFxuRlh5NDBVK0xuWHpoaFcrN1ZCQXZ5WVg4R0VYaEhrS1U4R3FrMXhpdHJxZkJYWTc0eEtneVVTVG9sRlNmRlZnalxubWNNL1g0SzQ1YmthK3Fwa2o3S2Z2LzhENGo2YVpla3doTjJseTZoaEMxU21ROHFqTWpwRy9tcldPU1NIWkZtZlxueWJ1OWlEMkFZSGVJT2tzaElsNnhZSWErK1EvMDAvdnM0Nkl6QWJReXJpT2kwWHhsU01NVnRQeDBRM2lzcCtqaVxubjhNcTllT3V4WU9FUTRvZjh0d1VrVURkNTI4aXdHdEVkd2YwUTAxVXlUODRTNjJOOEF5U2wxWkJLWEp6Nlc0RlxuVWhXZmEvSFFZT0FQRGRFak5nblZ3TEkyM2I4dDBUb3p5Q1d3N3E4aFxuLS0tLS1FTkQgQ0VSVElGSUNBVEUtLS0tLVxuXG4tLS0tLUJFR0lOIENFUlRJRklDQVRFLS0tLS1cbk1JSUVqekNDQTNlZ0F3SUJBZ0lRZTU1Qi9BTENLSkRadGROVDhrRDZoVEFOQmdrcWhraUc5dzBCQVFzRkFEQk1cbk1TQXdIZ1lEVlFRTEV4ZEhiRzlpWVd4VGFXZHVJRkp2YjNRZ1EwRWdMU0JTTXpFVE1CRUdBMVVFQ2hNS1IyeHZcblltRnNVMmxuYmpFVE1CRUdBMVVFQXhNS1IyeHZZbUZzVTJsbmJqQWVGdzB5TWpBeE1qWXhNakF3TURCYUZ3MHlcbk5UQXhNall3TURBd01EQmFNRmd4Q3pBSkJnTlZCQVlUQWtKRk1Sa3dGd1lEVlFRS0V4QkhiRzlpWVd4VGFXZHVcbklHNTJMWE5oTVM0d0xBWURWUVFERXlWSGJHOWlZV3hUYVdkdUlFRjBiR0Z6SUZJeklFOVdJRlJNVXlCRFFTQXlcbk1ESXlJRkV5TUlJQklqQU5CZ2txaGtpRzl3MEJBUUVGQUFPQ0FROEFNSUlCQ2dLQ0FRRUFtR21nMUxXOWI3TGZcbjh6REQ4M3lCRFRFa3QrRk94S0pacUY0dmVXYzVLWnNRajlIZm5VUzJlNW5qL0UrSkltbEdQc1F1b2lvc0x1WERcbkJWQk5BTWNVRmExMWJ1Rk1HTWVFTXdpVG1DWG9YUnJYUW1IMHFqcE9mS2dZYzVnSEczQnNSR2FScmY3VlI0ZWdcbm9mTk1HOXdVQnc0L2cvVFQ3K2JRSmRBNE5mRTdZNGQ1Z0VyeVppQkdCL3N3YVg2SnAvOE1GNFRnVW1PV21hbEtcbmRaQ0t5YjRzUEdRRlJUdEVsazY3Rjd2VSt3ZEdjcmNPeDF0RGNJQjBuY2pMUE1uYUZpY2FnbCtkYVdHc0txVGhcbmNvdW5RYjZRSnRZSGE5MUt2Q2ZLV29jTXhRN09JYkI1VUFSTFBtQzRDSjEvZjhZRm0zNWViZnpBZVVMWWRHWHVcbmpFOUNMb3IwT3dJREFRQUJvNElCWHpDQ0FWc3dEZ1lEVlIwUEFRSC9CQVFEQWdHR01CMEdBMVVkSlFRV01CUUdcbkNDc0dBUVVGQndNQkJnZ3JCZ0VGQlFjREFqQVNCZ05WSFJNQkFmOEVDREFHQVFIL0FnRUFNQjBHQTFVZERnUVdcbkJCU0g1WnE3YTdCL3Q5NUdmSldrREJwQThISHFkakFmQmdOVkhTTUVHREFXZ0JTUDhFdC9xQzVGSks1TlVQcGpcbm1vdmU0dDBidkRCN0JnZ3JCZ0VGQlFjQkFRUnZNRzB3TGdZSUt3WUJCUVVITUFHR0ltaDBkSEE2THk5dlkzTndcbk1pNW5iRzlpWVd4emFXZHVMbU52YlM5eWIyOTBjak13T3dZSUt3WUJCUVVITUFLR0wyaDBkSEE2THk5elpXTjFcbmNtVXVaMnh2WW1Gc2MybG5iaTVqYjIwdlkyRmpaWEowTDNKdmIzUXRjak11WTNKME1EWUdBMVVkSHdRdk1DMHdcbks2QXBvQ2VHSldoMGRIQTZMeTlqY213dVoyeHZZbUZzYzJsbmJpNWpiMjB2Y205dmRDMXlNeTVqY213d0lRWURcblZSMGdCQm93R0RBSUJnWm5nUXdCQWdJd0RBWUtLd1lCQkFHZ01nb0JBakFOQmdrcWhraUc5dzBCQVFzRkFBT0NcbkFRRUFLUmljOS9mK25taFFVL3d6MDRBUFpMamdHNU9nc3VVT3lVRVpqS1ZoTkdEd3hHVHZLaHlYR0dBTVcyQi9cbjNiUmkrYUVscFh3b3h1M3BMNmZrRWxiWDNCMEJlUzVMb0R0eGt5aVZFQk1aOG0rc1hib2N3bFB5eHJQYlg2bVlcbjByVkl2bnVVZUJIOFgwTDVJd2ZwTlZ2S25CSWlsVGJjZWJmSHlYa1Blekd3ejdFMXloVVVMakpGbTJidDBTZFhcbnkrNFgvV2VpaVlJditmVFZnWlpnbCsvMk1LSXN1L3FkQkpjM2YzVHZKOG56K0VheDF6Z1ptd3crUlNRV2VPajNcbjE1SXc2WjVGWCtOd3pZL0FiKzlQb3NSNVVvc1NlcSs5SGh0YXhadHRYRzFuVmgrYXZZUEdZZGRXbWlNVDkwSjVcblpnS25PL0Z4MmhCZ1R4aE9UTVlhRDMxMmtnPT1cbi0tLS0tRU5EIENFUlRJRklDQVRFLS0tLS1cblxuLS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tXG5NSUlEWHpDQ0FrZWdBd0lCQWdJTEJBQUFBQUFCSVZoVENLSXdEUVlKS29aSWh2Y05BUUVMQlFBd1RERWdNQjRHXG5BMVVFQ3hNWFIyeHZZbUZzVTJsbmJpQlNiMjkwSUVOQklDMGdVak14RXpBUkJnTlZCQW9UQ2tkc2IySmhiRk5wXG5aMjR4RXpBUkJnTlZCQU1UQ2tkc2IySmhiRk5wWjI0d0hoY05NRGt3TXpFNE1UQXdNREF3V2hjTk1qa3dNekU0XG5NVEF3TURBd1dqQk1NU0F3SGdZRFZRUUxFeGRIYkc5aVlXeFRhV2R1SUZKdmIzUWdRMEVnTFNCU016RVRNQkVHXG5BMVVFQ2hNS1IyeHZZbUZzVTJsbmJqRVRNQkVHQTFVRUF4TUtSMnh2WW1Gc1UybG5iakNDQVNJd0RRWUpLb1pJXG5odmNOQVFFQkJRQURnZ0VQQURDQ0FRb0NnZ0VCQU13bGRwQjVCbmdpRnZYQWc3YUV5aWllL1FWMkVjV3RpSEw4XG5SZ0pEeDdLS25RUmZKTXN1UytGZ2drYmhVcXNNZ1Vkd2JOMWswZXYxTEtNUGdqME1LNjZYMTdZVWhoQjV1enNUXG5nSGVNQ09GSjBtcGlMeDllK3BabzM0a25sVGlmQnRjK3ljc21XUTF6M3JESTZTWU9neFhHNzF1TDBnUmd5a21tXG5LUFpwTy9iTHlDaVI1WjJLWVZjM3JIUVUzSFRnT3U1eUx5NmMrOUM3di9VOUFPRUdNK2lDSzY1VHBqb1djNHpkXG5RUTRnT3NDMHA2SHBzaytRTGpKZzZWZkx1UVNTYUdqbE9DWmdkYktmZC8rUkZPK3VJRW44clVBVlNORUNNV0VaXG5YcmlYNzYxM3QyU2Flcjlmd1JQdm0yTDdEV3pnVkdrV3FRUGFidW1EazNGMnhtbUZnaGNDQXdFQUFhTkNNRUF3XG5EZ1lEVlIwUEFRSC9CQVFEQWdFR01BOEdBMVVkRXdFQi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZJL3dTMytvXG5Ma1VrcmsxUSttT2FpOTdpM1J1OE1BMEdDU3FHU0liM0RRRUJDd1VBQTRJQkFRQkxRTnZBVUtyK3lBenY5NVpVXG5SVW03bGdBSlFheXpFNGFHS0Fjenltdm1kTG02QUMydXBBclQ5Zkh4RDRxL2MyZEtnOGRFZTNqZ3IyNXNid01wXG5qak01UmNPTzVMbFhiS3I4RXBic1U4WXQ1Q1JzdVpSais5eFRhR2RXUG9PNHp6VWh3OGxvL3M3YXdsT3F6SkNLXG42ZkJkUm95VjNYcFlLQm92SGQ3TkFEZEJqKzFFYmRkVEtKZCs4MmNFSGhYWGlwYTAwOTVNSjZSTUczTnpkdlFYXG5tY0lmZWc3akxRaXRDaHdzL3p5clZRNFBrWDQyNjhOWFNiN2hMaTE4WUl2RFFWRVRJNTNPOXpKcmxBR29tZWNzXG5NeDg2T3lYU2hrRE9PeXlHZU1saEx4UzY3dHRWYjkrRTdnVUpUYjBvMkhMTzAySlFaUjdya3BlRE1kbXp0Y3BIXG5XRDlmXG4tLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tYDtcbmNvbnN0IFRMU1Byb2ZpbGVzID0ge1xuICAgIFJlZGlzQ2xvdWRGaXhlZDogeyBjYTogUmVkaXNDbG91ZENBIH0sXG4gICAgUmVkaXNDbG91ZEZsZXhpYmxlOiB7IGNhOiBSZWRpc0Nsb3VkQ0EgfSxcbn07XG5leHBvcnRzLmRlZmF1bHQgPSBUTFNQcm9maWxlcztcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/constants/TLSProfiles.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/ClusterAllFailedError.js":
/*!*********************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/ClusterAllFailedError.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/../../node_modules/.pnpm/redis-errors@1.2.0/node_modules/redis-errors/index.js\");\nclass ClusterAllFailedError extends redis_errors_1.RedisError {\n    constructor(message, lastNodeError) {\n        super(message);\n        this.lastNodeError = lastNodeError;\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = ClusterAllFailedError;\nClusterAllFailedError.defaultMessage = \"Failed to refresh slots cache.\";\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvZXJyb3JzL0NsdXN0ZXJBbGxGYWlsZWRFcnJvci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCx1QkFBdUIsbUJBQU8sQ0FBQywwR0FBYztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFlO0FBQ2YiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2Vycm9ycy9DbHVzdGVyQWxsRmFpbGVkRXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jbGFzcyBDbHVzdGVyQWxsRmFpbGVkRXJyb3IgZXh0ZW5kcyByZWRpc19lcnJvcnNfMS5SZWRpc0Vycm9yIHtcbiAgICBjb25zdHJ1Y3RvcihtZXNzYWdlLCBsYXN0Tm9kZUVycm9yKSB7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICB0aGlzLmxhc3ROb2RlRXJyb3IgPSBsYXN0Tm9kZUVycm9yO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gQ2x1c3RlckFsbEZhaWxlZEVycm9yO1xuQ2x1c3RlckFsbEZhaWxlZEVycm9yLmRlZmF1bHRNZXNzYWdlID0gXCJGYWlsZWQgdG8gcmVmcmVzaCBzbG90cyBjYWNoZS5cIjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/ClusterAllFailedError.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js":
/*!*************************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js ***!
  \*************************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/../../node_modules/.pnpm/redis-errors@1.2.0/node_modules/redis-errors/index.js\");\nclass MaxRetriesPerRequestError extends redis_errors_1.AbortError {\n    constructor(maxRetriesPerRequest) {\n        const message = `Reached the max retries per request limit (which is ${maxRetriesPerRequest}). Refer to \"maxRetriesPerRequest\" option for details.`;\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n    }\n    get name() {\n        return this.constructor.name;\n    }\n}\nexports[\"default\"] = MaxRetriesPerRequestError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvZXJyb3JzL01heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsdUJBQXVCLG1CQUFPLENBQUMsMEdBQWM7QUFDN0M7QUFDQTtBQUNBLCtFQUErRSxxQkFBcUI7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvZXJyb3JzL01heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jbGFzcyBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yIGV4dGVuZHMgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWF4UmV0cmllc1BlclJlcXVlc3QpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZSA9IGBSZWFjaGVkIHRoZSBtYXggcmV0cmllcyBwZXIgcmVxdWVzdCBsaW1pdCAod2hpY2ggaXMgJHttYXhSZXRyaWVzUGVyUmVxdWVzdH0pLiBSZWZlciB0byBcIm1heFJldHJpZXNQZXJSZXF1ZXN0XCIgb3B0aW9uIGZvciBkZXRhaWxzLmA7XG4gICAgICAgIHN1cGVyKG1lc3NhZ2UpO1xuICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCB0aGlzLmNvbnN0cnVjdG9yKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbnN0cnVjdG9yLm5hbWU7XG4gICAgfVxufVxuZXhwb3J0cy5kZWZhdWx0ID0gTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/index.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/index.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.MaxRetriesPerRequestError = void 0;\nconst MaxRetriesPerRequestError_1 = __webpack_require__(/*! ./MaxRetriesPerRequestError */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/MaxRetriesPerRequestError.js\");\nexports.MaxRetriesPerRequestError = MaxRetriesPerRequestError_1.default;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvZXJyb3JzL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELGlDQUFpQztBQUNqQyxvQ0FBb0MsbUJBQU8sQ0FBQyxnSkFBNkI7QUFDekUsaUNBQWlDIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9lcnJvcnMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLk1heFJldHJpZXNQZXJSZXF1ZXN0RXJyb3IgPSB2b2lkIDA7XG5jb25zdCBNYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yXzEgPSByZXF1aXJlKFwiLi9NYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yXCIpO1xuZXhwb3J0cy5NYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yID0gTWF4UmV0cmllc1BlclJlcXVlc3RFcnJvcl8xLmRlZmF1bHQ7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/index.js":
/*!**********************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/index.js ***!
  \**********************************************************************************/
/***/ ((module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.print = exports.ReplyError = exports.SentinelIterator = exports.SentinelConnector = exports.AbstractConnector = exports.Pipeline = exports.ScanStream = exports.Command = exports.Cluster = exports.Redis = exports[\"default\"] = void 0;\nexports = module.exports = __webpack_require__(/*! ./Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\")[\"default\"];\nvar Redis_1 = __webpack_require__(/*! ./Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"default\", ({ enumerable: true, get: function () { return Redis_1.default; } }));\nvar Redis_2 = __webpack_require__(/*! ./Redis */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Redis.js\");\nObject.defineProperty(exports, \"Redis\", ({ enumerable: true, get: function () { return Redis_2.default; } }));\nvar cluster_1 = __webpack_require__(/*! ./cluster */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/cluster/index.js\");\nObject.defineProperty(exports, \"Cluster\", ({ enumerable: true, get: function () { return cluster_1.default; } }));\n/**\n * @ignore\n */\nvar Command_1 = __webpack_require__(/*! ./Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nObject.defineProperty(exports, \"Command\", ({ enumerable: true, get: function () { return Command_1.default; } }));\n/**\n * @ignore\n */\nvar ScanStream_1 = __webpack_require__(/*! ./ScanStream */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/ScanStream.js\");\nObject.defineProperty(exports, \"ScanStream\", ({ enumerable: true, get: function () { return ScanStream_1.default; } }));\n/**\n * @ignore\n */\nvar Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Pipeline.js\");\nObject.defineProperty(exports, \"Pipeline\", ({ enumerable: true, get: function () { return Pipeline_1.default; } }));\n/**\n * @ignore\n */\nvar AbstractConnector_1 = __webpack_require__(/*! ./connectors/AbstractConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/AbstractConnector.js\");\nObject.defineProperty(exports, \"AbstractConnector\", ({ enumerable: true, get: function () { return AbstractConnector_1.default; } }));\n/**\n * @ignore\n */\nvar SentinelConnector_1 = __webpack_require__(/*! ./connectors/SentinelConnector */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/connectors/SentinelConnector/index.js\");\nObject.defineProperty(exports, \"SentinelConnector\", ({ enumerable: true, get: function () { return SentinelConnector_1.default; } }));\nObject.defineProperty(exports, \"SentinelIterator\", ({ enumerable: true, get: function () { return SentinelConnector_1.SentinelIterator; } }));\n// No TS typings\nexports.ReplyError = __webpack_require__(/*! redis-errors */ \"(rsc)/../../node_modules/.pnpm/redis-errors@1.2.0/node_modules/redis-errors/index.js\").ReplyError;\n/**\n * @ignore\n */\nObject.defineProperty(exports, \"Promise\", ({\n    get() {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n        return Promise;\n    },\n    set(_lib) {\n        console.warn(\"ioredis v5 does not support plugging third-party Promise library anymore. Native Promise will be used.\");\n    },\n}));\n/**\n * @ignore\n */\nfunction print(err, reply) {\n    if (err) {\n        console.log(\"Error: \" + err);\n    }\n    else {\n        console.log(\"Reply: \" + reply);\n    }\n}\nexports.print = print;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsYUFBYSxHQUFHLGtCQUFrQixHQUFHLHdCQUF3QixHQUFHLHlCQUF5QixHQUFHLHlCQUF5QixHQUFHLGdCQUFnQixHQUFHLGtCQUFrQixHQUFHLGVBQWUsR0FBRyxlQUFlLEdBQUcsYUFBYSxHQUFHLGtCQUFlO0FBQ25PLFVBQVUsa0pBQTJDO0FBQ3JELGNBQWMsbUJBQU8sQ0FBQyxpR0FBUztBQUMvQiwyQ0FBMEMsRUFBRSxxQ0FBcUMsMkJBQTJCLEVBQUM7QUFDN0csY0FBYyxtQkFBTyxDQUFDLGlHQUFTO0FBQy9CLHlDQUF3QyxFQUFFLHFDQUFxQywyQkFBMkIsRUFBQztBQUMzRyxnQkFBZ0IsbUJBQU8sQ0FBQywyR0FBVztBQUNuQywyQ0FBMEMsRUFBRSxxQ0FBcUMsNkJBQTZCLEVBQUM7QUFDL0c7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMscUdBQVc7QUFDbkMsMkNBQTBDLEVBQUUscUNBQXFDLDZCQUE2QixFQUFDO0FBQy9HO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixtQkFBTyxDQUFDLDJHQUFjO0FBQ3pDLDhDQUE2QyxFQUFFLHFDQUFxQyxnQ0FBZ0MsRUFBQztBQUNySDtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsbUJBQU8sQ0FBQyx1R0FBWTtBQUNyQyw0Q0FBMkMsRUFBRSxxQ0FBcUMsOEJBQThCLEVBQUM7QUFDakg7QUFDQTtBQUNBO0FBQ0EsMEJBQTBCLG1CQUFPLENBQUMsK0lBQWdDO0FBQ2xFLHFEQUFvRCxFQUFFLHFDQUFxQyx1Q0FBdUMsRUFBQztBQUNuSTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsbUJBQU8sQ0FBQyxxSkFBZ0M7QUFDbEUscURBQW9ELEVBQUUscUNBQXFDLHVDQUF1QyxFQUFDO0FBQ25JLG9EQUFtRCxFQUFFLHFDQUFxQyxnREFBZ0QsRUFBQztBQUMzSTtBQUNBLCtKQUF1RDtBQUN2RDtBQUNBO0FBQ0E7QUFDQSwyQ0FBMEM7QUFDMUM7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsQ0FBQyxFQUFDO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWEiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L2luZGV4LmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5wcmludCA9IGV4cG9ydHMuUmVwbHlFcnJvciA9IGV4cG9ydHMuU2VudGluZWxJdGVyYXRvciA9IGV4cG9ydHMuU2VudGluZWxDb25uZWN0b3IgPSBleHBvcnRzLkFic3RyYWN0Q29ubmVjdG9yID0gZXhwb3J0cy5QaXBlbGluZSA9IGV4cG9ydHMuU2NhblN0cmVhbSA9IGV4cG9ydHMuQ29tbWFuZCA9IGV4cG9ydHMuQ2x1c3RlciA9IGV4cG9ydHMuUmVkaXMgPSBleHBvcnRzLmRlZmF1bHQgPSB2b2lkIDA7XG5leHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi9SZWRpc1wiKS5kZWZhdWx0O1xudmFyIFJlZGlzXzEgPSByZXF1aXJlKFwiLi9SZWRpc1wiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIFJlZGlzXzEuZGVmYXVsdDsgfSB9KTtcbnZhciBSZWRpc18yID0gcmVxdWlyZShcIi4vUmVkaXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJSZWRpc1wiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gUmVkaXNfMi5kZWZhdWx0OyB9IH0pO1xudmFyIGNsdXN0ZXJfMSA9IHJlcXVpcmUoXCIuL2NsdXN0ZXJcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJDbHVzdGVyXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBjbHVzdGVyXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4vQ29tbWFuZFwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNvbW1hbmRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIENvbW1hbmRfMS5kZWZhdWx0OyB9IH0pO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbnZhciBTY2FuU3RyZWFtXzEgPSByZXF1aXJlKFwiLi9TY2FuU3RyZWFtXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2NhblN0cmVhbVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2NhblN0cmVhbV8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIFBpcGVsaW5lXzEgPSByZXF1aXJlKFwiLi9QaXBlbGluZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpcGVsaW5lXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBQaXBlbGluZV8xLmRlZmF1bHQ7IH0gfSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xudmFyIEFic3RyYWN0Q29ubmVjdG9yXzEgPSByZXF1aXJlKFwiLi9jb25uZWN0b3JzL0Fic3RyYWN0Q29ubmVjdG9yXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQWJzdHJhY3RDb25uZWN0b3JcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIEFic3RyYWN0Q29ubmVjdG9yXzEuZGVmYXVsdDsgfSB9KTtcbi8qKlxuICogQGlnbm9yZVxuICovXG52YXIgU2VudGluZWxDb25uZWN0b3JfMSA9IHJlcXVpcmUoXCIuL2Nvbm5lY3RvcnMvU2VudGluZWxDb25uZWN0b3JcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTZW50aW5lbENvbm5lY3RvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VudGluZWxDb25uZWN0b3JfMS5kZWZhdWx0OyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiU2VudGluZWxJdGVyYXRvclwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gU2VudGluZWxDb25uZWN0b3JfMS5TZW50aW5lbEl0ZXJhdG9yOyB9IH0pO1xuLy8gTm8gVFMgdHlwaW5nc1xuZXhwb3J0cy5SZXBseUVycm9yID0gcmVxdWlyZShcInJlZGlzLWVycm9yc1wiKS5SZXBseUVycm9yO1xuLyoqXG4gKiBAaWdub3JlXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb21pc2VcIiwge1xuICAgIGdldCgpIHtcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW9yZWRpcyB2NSBkb2VzIG5vdCBzdXBwb3J0IHBsdWdnaW5nIHRoaXJkLXBhcnR5IFByb21pc2UgbGlicmFyeSBhbnltb3JlLiBOYXRpdmUgUHJvbWlzZSB3aWxsIGJlIHVzZWQuXCIpO1xuICAgICAgICByZXR1cm4gUHJvbWlzZTtcbiAgICB9LFxuICAgIHNldChfbGliKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihcImlvcmVkaXMgdjUgZG9lcyBub3Qgc3VwcG9ydCBwbHVnZ2luZyB0aGlyZC1wYXJ0eSBQcm9taXNlIGxpYnJhcnkgYW55bW9yZS4gTmF0aXZlIFByb21pc2Ugd2lsbCBiZSB1c2VkLlwiKTtcbiAgICB9LFxufSk7XG4vKipcbiAqIEBpZ25vcmVcbiAqL1xuZnVuY3Rpb24gcHJpbnQoZXJyLCByZXBseSkge1xuICAgIGlmIChlcnIpIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJFcnJvcjogXCIgKyBlcnIpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgY29uc29sZS5sb2coXCJSZXBseTogXCIgKyByZXBseSk7XG4gICAgfVxufVxuZXhwb3J0cy5wcmludCA9IHByaW50O1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/RedisOptions.js":
/*!***********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/RedisOptions.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.DEFAULT_REDIS_OPTIONS = void 0;\nexports.DEFAULT_REDIS_OPTIONS = {\n    // Connection\n    port: 6379,\n    host: \"localhost\",\n    family: 4,\n    connectTimeout: 10000,\n    disconnectTimeout: 2000,\n    retryStrategy: function (times) {\n        return Math.min(times * 50, 2000);\n    },\n    keepAlive: 0,\n    noDelay: true,\n    connectionName: null,\n    // Sentinel\n    sentinels: null,\n    name: null,\n    role: \"master\",\n    sentinelRetryStrategy: function (times) {\n        return Math.min(times * 10, 1000);\n    },\n    sentinelReconnectStrategy: function () {\n        // This strategy only applies when sentinels are used for detecting\n        // a failover, not during initial master resolution.\n        // The deployment can still function when some of the sentinels are down\n        // for a long period of time, so we may not want to attempt reconnection\n        // very often. Therefore the default interval is fairly long (1 minute).\n        return 60000;\n    },\n    natMap: null,\n    enableTLSForSentinelMode: false,\n    updateSentinels: true,\n    failoverDetector: false,\n    // Status\n    username: null,\n    password: null,\n    db: 0,\n    // Others\n    enableOfflineQueue: true,\n    enableReadyCheck: true,\n    autoResubscribe: true,\n    autoResendUnfulfilledCommands: true,\n    lazyConnect: false,\n    keyPrefix: \"\",\n    reconnectOnError: null,\n    readOnly: false,\n    stringNumbers: false,\n    maxRetriesPerRequest: 20,\n    maxLoadingRetryTime: 10000,\n    enableAutoPipelining: false,\n    autoPipeliningIgnoredCommands: [],\n    sentinelMaxConnections: 10,\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvcmVkaXMvUmVkaXNPcHRpb25zLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELDZCQUE2QjtBQUM3Qiw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBIiwic291cmNlcyI6WyIvVXNlcnMvam9zaHVhamFuc2V2YW5yZW5zYnVyZy9EZXNrdG9wLzQuIENvZGUvcG9kY2FzdC1wbGF0Zm9ybS9ub2RlX21vZHVsZXMvLnBucG0vaW9yZWRpc0A1LjYuMS9ub2RlX21vZHVsZXMvaW9yZWRpcy9idWlsdC9yZWRpcy9SZWRpc09wdGlvbnMuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkRFRkFVTFRfUkVESVNfT1BUSU9OUyA9IHZvaWQgMDtcbmV4cG9ydHMuREVGQVVMVF9SRURJU19PUFRJT05TID0ge1xuICAgIC8vIENvbm5lY3Rpb25cbiAgICBwb3J0OiA2Mzc5LFxuICAgIGhvc3Q6IFwibG9jYWxob3N0XCIsXG4gICAgZmFtaWx5OiA0LFxuICAgIGNvbm5lY3RUaW1lb3V0OiAxMDAwMCxcbiAgICBkaXNjb25uZWN0VGltZW91dDogMjAwMCxcbiAgICByZXRyeVN0cmF0ZWd5OiBmdW5jdGlvbiAodGltZXMpIHtcbiAgICAgICAgcmV0dXJuIE1hdGgubWluKHRpbWVzICogNTAsIDIwMDApO1xuICAgIH0sXG4gICAga2VlcEFsaXZlOiAwLFxuICAgIG5vRGVsYXk6IHRydWUsXG4gICAgY29ubmVjdGlvbk5hbWU6IG51bGwsXG4gICAgLy8gU2VudGluZWxcbiAgICBzZW50aW5lbHM6IG51bGwsXG4gICAgbmFtZTogbnVsbCxcbiAgICByb2xlOiBcIm1hc3RlclwiLFxuICAgIHNlbnRpbmVsUmV0cnlTdHJhdGVneTogZnVuY3Rpb24gKHRpbWVzKSB7XG4gICAgICAgIHJldHVybiBNYXRoLm1pbih0aW1lcyAqIDEwLCAxMDAwKTtcbiAgICB9LFxuICAgIHNlbnRpbmVsUmVjb25uZWN0U3RyYXRlZ3k6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gVGhpcyBzdHJhdGVneSBvbmx5IGFwcGxpZXMgd2hlbiBzZW50aW5lbHMgYXJlIHVzZWQgZm9yIGRldGVjdGluZ1xuICAgICAgICAvLyBhIGZhaWxvdmVyLCBub3QgZHVyaW5nIGluaXRpYWwgbWFzdGVyIHJlc29sdXRpb24uXG4gICAgICAgIC8vIFRoZSBkZXBsb3ltZW50IGNhbiBzdGlsbCBmdW5jdGlvbiB3aGVuIHNvbWUgb2YgdGhlIHNlbnRpbmVscyBhcmUgZG93blxuICAgICAgICAvLyBmb3IgYSBsb25nIHBlcmlvZCBvZiB0aW1lLCBzbyB3ZSBtYXkgbm90IHdhbnQgdG8gYXR0ZW1wdCByZWNvbm5lY3Rpb25cbiAgICAgICAgLy8gdmVyeSBvZnRlbi4gVGhlcmVmb3JlIHRoZSBkZWZhdWx0IGludGVydmFsIGlzIGZhaXJseSBsb25nICgxIG1pbnV0ZSkuXG4gICAgICAgIHJldHVybiA2MDAwMDtcbiAgICB9LFxuICAgIG5hdE1hcDogbnVsbCxcbiAgICBlbmFibGVUTFNGb3JTZW50aW5lbE1vZGU6IGZhbHNlLFxuICAgIHVwZGF0ZVNlbnRpbmVsczogdHJ1ZSxcbiAgICBmYWlsb3ZlckRldGVjdG9yOiBmYWxzZSxcbiAgICAvLyBTdGF0dXNcbiAgICB1c2VybmFtZTogbnVsbCxcbiAgICBwYXNzd29yZDogbnVsbCxcbiAgICBkYjogMCxcbiAgICAvLyBPdGhlcnNcbiAgICBlbmFibGVPZmZsaW5lUXVldWU6IHRydWUsXG4gICAgZW5hYmxlUmVhZHlDaGVjazogdHJ1ZSxcbiAgICBhdXRvUmVzdWJzY3JpYmU6IHRydWUsXG4gICAgYXV0b1Jlc2VuZFVuZnVsZmlsbGVkQ29tbWFuZHM6IHRydWUsXG4gICAgbGF6eUNvbm5lY3Q6IGZhbHNlLFxuICAgIGtleVByZWZpeDogXCJcIixcbiAgICByZWNvbm5lY3RPbkVycm9yOiBudWxsLFxuICAgIHJlYWRPbmx5OiBmYWxzZSxcbiAgICBzdHJpbmdOdW1iZXJzOiBmYWxzZSxcbiAgICBtYXhSZXRyaWVzUGVyUmVxdWVzdDogMjAsXG4gICAgbWF4TG9hZGluZ1JldHJ5VGltZTogMTAwMDAsXG4gICAgZW5hYmxlQXV0b1BpcGVsaW5pbmc6IGZhbHNlLFxuICAgIGF1dG9QaXBlbGluaW5nSWdub3JlZENvbW1hbmRzOiBbXSxcbiAgICBzZW50aW5lbE1heENvbm5lY3Rpb25zOiAxMCxcbn07XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/RedisOptions.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/event_handler.js":
/*!************************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/event_handler.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.readyHandler = exports.errorHandler = exports.closeHandler = exports.connectHandler = void 0;\nconst redis_errors_1 = __webpack_require__(/*! redis-errors */ \"(rsc)/../../node_modules/.pnpm/redis-errors@1.2.0/node_modules/redis-errors/index.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst errors_1 = __webpack_require__(/*! ../errors */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/errors/index.js\");\nconst utils_1 = __webpack_require__(/*! ../utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst DataHandler_1 = __webpack_require__(/*! ../DataHandler */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/DataHandler.js\");\nconst debug = (0, utils_1.Debug)(\"connection\");\nfunction connectHandler(self) {\n    return function () {\n        self.setStatus(\"connect\");\n        self.resetCommandQueue();\n        // AUTH command should be processed before any other commands\n        let flushed = false;\n        const { connectionEpoch } = self;\n        if (self.condition.auth) {\n            self.auth(self.condition.auth, function (err) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (err.message.indexOf(\"no password is set\") !== -1) {\n                        console.warn(\"[WARN] Redis server does not require a password, but a password was supplied.\");\n                    }\n                    else if (err.message.indexOf(\"without any password configured for the default user\") !== -1) {\n                        console.warn(\"[WARN] This Redis server's `default` user does not require a password, but a password was supplied\");\n                    }\n                    else if (err.message.indexOf(\"wrong number of arguments for 'auth' command\") !== -1) {\n                        console.warn(`[ERROR] The server returned \"wrong number of arguments for 'auth' command\". You are probably passing both username and password to Redis version 5 or below. You should only pass the 'password' option for Redis version 5 and under.`);\n                    }\n                    else {\n                        flushed = true;\n                        self.recoverFromFatalError(err, err);\n                    }\n                }\n            });\n        }\n        if (self.condition.select) {\n            self.select(self.condition.select).catch((err) => {\n                // If the node is in cluster mode, select is disallowed.\n                // In this case, reconnect won't help.\n                self.silentEmit(\"error\", err);\n            });\n        }\n        if (!self.options.enableReadyCheck) {\n            exports.readyHandler(self)();\n        }\n        /*\n          No need to keep the reference of DataHandler here\n          because we don't need to do the cleanup.\n          `Stream#end()` will remove all listeners for us.\n        */\n        new DataHandler_1.default(self, {\n            stringNumbers: self.options.stringNumbers,\n        });\n        if (self.options.enableReadyCheck) {\n            self._readyCheck(function (err, info) {\n                if (connectionEpoch !== self.connectionEpoch) {\n                    return;\n                }\n                if (err) {\n                    if (!flushed) {\n                        self.recoverFromFatalError(new Error(\"Ready check failed: \" + err.message), err);\n                    }\n                }\n                else {\n                    if (self.connector.check(info)) {\n                        exports.readyHandler(self)();\n                    }\n                    else {\n                        self.disconnect(true);\n                    }\n                }\n            });\n        }\n    };\n}\nexports.connectHandler = connectHandler;\nfunction abortError(command) {\n    const err = new redis_errors_1.AbortError(\"Command aborted due to connection close\");\n    err.command = {\n        name: command.name,\n        args: command.args,\n    };\n    return err;\n}\n// If a contiguous set of pipeline commands starts from index zero then they\n// can be safely reattempted. If however we have a chain of pipelined commands\n// starting at index 1 or more it means we received a partial response before\n// the connection close and those pipelined commands must be aborted. For\n// example, if the queue looks like this: [2, 3, 4, 0, 1, 2] then after\n// aborting and purging we'll have a queue that looks like this: [0, 1, 2]\nfunction abortIncompletePipelines(commandQueue) {\n    var _a;\n    let expectedIndex = 0;\n    for (let i = 0; i < commandQueue.length;) {\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        const pipelineIndex = command.pipelineIndex;\n        if (pipelineIndex === undefined || pipelineIndex === 0) {\n            expectedIndex = 0;\n        }\n        if (pipelineIndex !== undefined && pipelineIndex !== expectedIndex++) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            continue;\n        }\n        i++;\n    }\n}\n// If only a partial transaction result was received before connection close,\n// we have to abort any transaction fragments that may have ended up in the\n// offline queue\nfunction abortTransactionFragments(commandQueue) {\n    var _a;\n    for (let i = 0; i < commandQueue.length;) {\n        const command = (_a = commandQueue.peekAt(i)) === null || _a === void 0 ? void 0 : _a.command;\n        if (command.name === \"multi\") {\n            break;\n        }\n        if (command.name === \"exec\") {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n            break;\n        }\n        if (command.inTransaction) {\n            commandQueue.remove(i, 1);\n            command.reject(abortError(command));\n        }\n        else {\n            i++;\n        }\n    }\n}\nfunction closeHandler(self) {\n    return function () {\n        const prevStatus = self.status;\n        self.setStatus(\"close\");\n        if (self.commandQueue.length) {\n            abortIncompletePipelines(self.commandQueue);\n        }\n        if (self.offlineQueue.length) {\n            abortTransactionFragments(self.offlineQueue);\n        }\n        if (prevStatus === \"ready\") {\n            if (!self.prevCondition) {\n                self.prevCondition = self.condition;\n            }\n            if (self.commandQueue.length) {\n                self.prevCommandQueue = self.commandQueue;\n            }\n        }\n        if (self.manuallyClosing) {\n            self.manuallyClosing = false;\n            debug(\"skip reconnecting since the connection is manually closed.\");\n            return close();\n        }\n        if (typeof self.options.retryStrategy !== \"function\") {\n            debug(\"skip reconnecting because `retryStrategy` is not a function\");\n            return close();\n        }\n        const retryDelay = self.options.retryStrategy(++self.retryAttempts);\n        if (typeof retryDelay !== \"number\") {\n            debug(\"skip reconnecting because `retryStrategy` doesn't return a number\");\n            return close();\n        }\n        debug(\"reconnect in %sms\", retryDelay);\n        self.setStatus(\"reconnecting\", retryDelay);\n        self.reconnectTimeout = setTimeout(function () {\n            self.reconnectTimeout = null;\n            self.connect().catch(utils_1.noop);\n        }, retryDelay);\n        const { maxRetriesPerRequest } = self.options;\n        if (typeof maxRetriesPerRequest === \"number\") {\n            if (maxRetriesPerRequest < 0) {\n                debug(\"maxRetriesPerRequest is negative, ignoring...\");\n            }\n            else {\n                const remainder = self.retryAttempts % (maxRetriesPerRequest + 1);\n                if (remainder === 0) {\n                    debug(\"reach maxRetriesPerRequest limitation, flushing command queue...\");\n                    self.flushQueue(new errors_1.MaxRetriesPerRequestError(maxRetriesPerRequest));\n                }\n            }\n        }\n    };\n    function close() {\n        self.setStatus(\"end\");\n        self.flushQueue(new Error(utils_1.CONNECTION_CLOSED_ERROR_MSG));\n    }\n}\nexports.closeHandler = closeHandler;\nfunction errorHandler(self) {\n    return function (error) {\n        debug(\"error: %s\", error);\n        self.silentEmit(\"error\", error);\n    };\n}\nexports.errorHandler = errorHandler;\nfunction readyHandler(self) {\n    return function () {\n        self.setStatus(\"ready\");\n        self.retryAttempts = 0;\n        if (self.options.monitor) {\n            self.call(\"monitor\").then(() => self.setStatus(\"monitoring\"), (error) => self.emit(\"error\", error));\n            const { sendCommand } = self;\n            self.sendCommand = function (command) {\n                if (Command_1.default.checkFlag(\"VALID_IN_MONITOR_MODE\", command.name)) {\n                    return sendCommand.call(self, command);\n                }\n                command.reject(new Error(\"Connection is in monitoring mode, can't process commands.\"));\n                return command.promise;\n            };\n            self.once(\"close\", function () {\n                delete self.sendCommand;\n            });\n            return;\n        }\n        const finalSelect = self.prevCondition\n            ? self.prevCondition.select\n            : self.condition.select;\n        if (self.options.connectionName) {\n            debug(\"set the connection name [%s]\", self.options.connectionName);\n            self.client(\"setname\", self.options.connectionName).catch(utils_1.noop);\n        }\n        if (self.options.readOnly) {\n            debug(\"set the connection to readonly mode\");\n            self.readonly().catch(utils_1.noop);\n        }\n        if (self.prevCondition) {\n            const condition = self.prevCondition;\n            self.prevCondition = null;\n            if (condition.subscriber && self.options.autoResubscribe) {\n                // We re-select the previous db first since\n                // `SELECT` command is not valid in sub mode.\n                if (self.condition.select !== finalSelect) {\n                    debug(\"connect to db [%d]\", finalSelect);\n                    self.select(finalSelect);\n                }\n                const subscribeChannels = condition.subscriber.channels(\"subscribe\");\n                if (subscribeChannels.length) {\n                    debug(\"subscribe %d channels\", subscribeChannels.length);\n                    self.subscribe(subscribeChannels);\n                }\n                const psubscribeChannels = condition.subscriber.channels(\"psubscribe\");\n                if (psubscribeChannels.length) {\n                    debug(\"psubscribe %d channels\", psubscribeChannels.length);\n                    self.psubscribe(psubscribeChannels);\n                }\n                const ssubscribeChannels = condition.subscriber.channels(\"ssubscribe\");\n                if (ssubscribeChannels.length) {\n                    debug(\"ssubscribe %d channels\", ssubscribeChannels.length);\n                    self.ssubscribe(ssubscribeChannels);\n                }\n            }\n        }\n        if (self.prevCommandQueue) {\n            if (self.options.autoResendUnfulfilledCommands) {\n                debug(\"resend %d unfulfilled commands\", self.prevCommandQueue.length);\n                while (self.prevCommandQueue.length > 0) {\n                    const item = self.prevCommandQueue.shift();\n                    if (item.select !== self.condition.select &&\n                        item.command.name !== \"select\") {\n                        self.select(item.select);\n                    }\n                    self.sendCommand(item.command, item.stream);\n                }\n            }\n            else {\n                self.prevCommandQueue = null;\n            }\n        }\n        if (self.offlineQueue.length) {\n            debug(\"send %d commands in offline queue\", self.offlineQueue.length);\n            const offlineQueue = self.offlineQueue;\n            self.resetOfflineQueue();\n            while (offlineQueue.length > 0) {\n                const item = offlineQueue.shift();\n                if (item.select !== self.condition.select &&\n                    item.command.name !== \"select\") {\n                    self.select(item.select);\n                }\n                self.sendCommand(item.command, item.stream);\n            }\n        }\n        if (self.condition.select !== finalSelect) {\n            debug(\"connect to db [%d]\", finalSelect);\n            self.select(finalSelect);\n        }\n    };\n}\nexports.readyHandler = readyHandler;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvcmVkaXMvZXZlbnRfaGFuZGxlci5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RCxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxvQkFBb0IsR0FBRyxzQkFBc0I7QUFDM0YsdUJBQXVCLG1CQUFPLENBQUMsMEdBQWM7QUFDN0Msa0JBQWtCLG1CQUFPLENBQUMsc0dBQVk7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsMEdBQVc7QUFDcEMsZ0JBQWdCLG1CQUFPLENBQUMsd0dBQVU7QUFDbEMsc0JBQXNCLG1CQUFPLENBQUMsOEdBQWdCO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLHdCQUF3QjtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxnQkFBZ0IsdUJBQXVCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGNBQWM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvcmVkaXMvZXZlbnRfaGFuZGxlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMucmVhZHlIYW5kbGVyID0gZXhwb3J0cy5lcnJvckhhbmRsZXIgPSBleHBvcnRzLmNsb3NlSGFuZGxlciA9IGV4cG9ydHMuY29ubmVjdEhhbmRsZXIgPSB2b2lkIDA7XG5jb25zdCByZWRpc19lcnJvcnNfMSA9IHJlcXVpcmUoXCJyZWRpcy1lcnJvcnNcIik7XG5jb25zdCBDb21tYW5kXzEgPSByZXF1aXJlKFwiLi4vQ29tbWFuZFwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi4vdXRpbHNcIik7XG5jb25zdCBEYXRhSGFuZGxlcl8xID0gcmVxdWlyZShcIi4uL0RhdGFIYW5kbGVyXCIpO1xuY29uc3QgZGVidWcgPSAoMCwgdXRpbHNfMS5EZWJ1ZykoXCJjb25uZWN0aW9uXCIpO1xuZnVuY3Rpb24gY29ubmVjdEhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwiY29ubmVjdFwiKTtcbiAgICAgICAgc2VsZi5yZXNldENvbW1hbmRRdWV1ZSgpO1xuICAgICAgICAvLyBBVVRIIGNvbW1hbmQgc2hvdWxkIGJlIHByb2Nlc3NlZCBiZWZvcmUgYW55IG90aGVyIGNvbW1hbmRzXG4gICAgICAgIGxldCBmbHVzaGVkID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IHsgY29ubmVjdGlvbkVwb2NoIH0gPSBzZWxmO1xuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uYXV0aCkge1xuICAgICAgICAgICAgc2VsZi5hdXRoKHNlbGYuY29uZGl0aW9uLmF1dGgsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkVwb2NoICE9PSBzZWxmLmNvbm5lY3Rpb25FcG9jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJubyBwYXNzd29yZCBpcyBzZXRcIikgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJbV0FSTl0gUmVkaXMgc2VydmVyIGRvZXMgbm90IHJlcXVpcmUgYSBwYXNzd29yZCwgYnV0IGEgcGFzc3dvcmQgd2FzIHN1cHBsaWVkLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChlcnIubWVzc2FnZS5pbmRleE9mKFwid2l0aG91dCBhbnkgcGFzc3dvcmQgY29uZmlndXJlZCBmb3IgdGhlIGRlZmF1bHQgdXNlclwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIltXQVJOXSBUaGlzIFJlZGlzIHNlcnZlcidzIGBkZWZhdWx0YCB1c2VyIGRvZXMgbm90IHJlcXVpcmUgYSBwYXNzd29yZCwgYnV0IGEgcGFzc3dvcmQgd2FzIHN1cHBsaWVkXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGVyci5tZXNzYWdlLmluZGV4T2YoXCJ3cm9uZyBudW1iZXIgb2YgYXJndW1lbnRzIGZvciAnYXV0aCcgY29tbWFuZFwiKSAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihgW0VSUk9SXSBUaGUgc2VydmVyIHJldHVybmVkIFwid3JvbmcgbnVtYmVyIG9mIGFyZ3VtZW50cyBmb3IgJ2F1dGgnIGNvbW1hbmRcIi4gWW91IGFyZSBwcm9iYWJseSBwYXNzaW5nIGJvdGggdXNlcm5hbWUgYW5kIHBhc3N3b3JkIHRvIFJlZGlzIHZlcnNpb24gNSBvciBiZWxvdy4gWW91IHNob3VsZCBvbmx5IHBhc3MgdGhlICdwYXNzd29yZCcgb3B0aW9uIGZvciBSZWRpcyB2ZXJzaW9uIDUgYW5kIHVuZGVyLmApO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmx1c2hlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY292ZXJGcm9tRmF0YWxFcnJvcihlcnIsIGVycik7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uc2VsZWN0KSB7XG4gICAgICAgICAgICBzZWxmLnNlbGVjdChzZWxmLmNvbmRpdGlvbi5zZWxlY3QpLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgbm9kZSBpcyBpbiBjbHVzdGVyIG1vZGUsIHNlbGVjdCBpcyBkaXNhbGxvd2VkLlxuICAgICAgICAgICAgICAgIC8vIEluIHRoaXMgY2FzZSwgcmVjb25uZWN0IHdvbid0IGhlbHAuXG4gICAgICAgICAgICAgICAgc2VsZi5zaWxlbnRFbWl0KFwiZXJyb3JcIiwgZXJyKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICghc2VsZi5vcHRpb25zLmVuYWJsZVJlYWR5Q2hlY2spIHtcbiAgICAgICAgICAgIGV4cG9ydHMucmVhZHlIYW5kbGVyKHNlbGYpKCk7XG4gICAgICAgIH1cbiAgICAgICAgLypcbiAgICAgICAgICBObyBuZWVkIHRvIGtlZXAgdGhlIHJlZmVyZW5jZSBvZiBEYXRhSGFuZGxlciBoZXJlXG4gICAgICAgICAgYmVjYXVzZSB3ZSBkb24ndCBuZWVkIHRvIGRvIHRoZSBjbGVhbnVwLlxuICAgICAgICAgIGBTdHJlYW0jZW5kKClgIHdpbGwgcmVtb3ZlIGFsbCBsaXN0ZW5lcnMgZm9yIHVzLlxuICAgICAgICAqL1xuICAgICAgICBuZXcgRGF0YUhhbmRsZXJfMS5kZWZhdWx0KHNlbGYsIHtcbiAgICAgICAgICAgIHN0cmluZ051bWJlcnM6IHNlbGYub3B0aW9ucy5zdHJpbmdOdW1iZXJzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5lbmFibGVSZWFkeUNoZWNrKSB7XG4gICAgICAgICAgICBzZWxmLl9yZWFkeUNoZWNrKGZ1bmN0aW9uIChlcnIsIGluZm8pIHtcbiAgICAgICAgICAgICAgICBpZiAoY29ubmVjdGlvbkVwb2NoICE9PSBzZWxmLmNvbm5lY3Rpb25FcG9jaCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFmbHVzaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnJlY292ZXJGcm9tRmF0YWxFcnJvcihuZXcgRXJyb3IoXCJSZWFkeSBjaGVjayBmYWlsZWQ6IFwiICsgZXJyLm1lc3NhZ2UpLCBlcnIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25uZWN0b3IuY2hlY2soaW5mbykpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cG9ydHMucmVhZHlIYW5kbGVyKHNlbGYpKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLmRpc2Nvbm5lY3QodHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLmNvbm5lY3RIYW5kbGVyID0gY29ubmVjdEhhbmRsZXI7XG5mdW5jdGlvbiBhYm9ydEVycm9yKGNvbW1hbmQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgcmVkaXNfZXJyb3JzXzEuQWJvcnRFcnJvcihcIkNvbW1hbmQgYWJvcnRlZCBkdWUgdG8gY29ubmVjdGlvbiBjbG9zZVwiKTtcbiAgICBlcnIuY29tbWFuZCA9IHtcbiAgICAgICAgbmFtZTogY29tbWFuZC5uYW1lLFxuICAgICAgICBhcmdzOiBjb21tYW5kLmFyZ3MsXG4gICAgfTtcbiAgICByZXR1cm4gZXJyO1xufVxuLy8gSWYgYSBjb250aWd1b3VzIHNldCBvZiBwaXBlbGluZSBjb21tYW5kcyBzdGFydHMgZnJvbSBpbmRleCB6ZXJvIHRoZW4gdGhleVxuLy8gY2FuIGJlIHNhZmVseSByZWF0dGVtcHRlZC4gSWYgaG93ZXZlciB3ZSBoYXZlIGEgY2hhaW4gb2YgcGlwZWxpbmVkIGNvbW1hbmRzXG4vLyBzdGFydGluZyBhdCBpbmRleCAxIG9yIG1vcmUgaXQgbWVhbnMgd2UgcmVjZWl2ZWQgYSBwYXJ0aWFsIHJlc3BvbnNlIGJlZm9yZVxuLy8gdGhlIGNvbm5lY3Rpb24gY2xvc2UgYW5kIHRob3NlIHBpcGVsaW5lZCBjb21tYW5kcyBtdXN0IGJlIGFib3J0ZWQuIEZvclxuLy8gZXhhbXBsZSwgaWYgdGhlIHF1ZXVlIGxvb2tzIGxpa2UgdGhpczogWzIsIDMsIDQsIDAsIDEsIDJdIHRoZW4gYWZ0ZXJcbi8vIGFib3J0aW5nIGFuZCBwdXJnaW5nIHdlJ2xsIGhhdmUgYSBxdWV1ZSB0aGF0IGxvb2tzIGxpa2UgdGhpczogWzAsIDEsIDJdXG5mdW5jdGlvbiBhYm9ydEluY29tcGxldGVQaXBlbGluZXMoY29tbWFuZFF1ZXVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGxldCBleHBlY3RlZEluZGV4ID0gMDtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGNvbW1hbmRRdWV1ZS5sZW5ndGg7KSB7XG4gICAgICAgIGNvbnN0IGNvbW1hbmQgPSAoX2EgPSBjb21tYW5kUXVldWUucGVla0F0KGkpKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29tbWFuZDtcbiAgICAgICAgY29uc3QgcGlwZWxpbmVJbmRleCA9IGNvbW1hbmQucGlwZWxpbmVJbmRleDtcbiAgICAgICAgaWYgKHBpcGVsaW5lSW5kZXggPT09IHVuZGVmaW5lZCB8fCBwaXBlbGluZUluZGV4ID09PSAwKSB7XG4gICAgICAgICAgICBleHBlY3RlZEluZGV4ID0gMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocGlwZWxpbmVJbmRleCAhPT0gdW5kZWZpbmVkICYmIHBpcGVsaW5lSW5kZXggIT09IGV4cGVjdGVkSW5kZXgrKykge1xuICAgICAgICAgICAgY29tbWFuZFF1ZXVlLnJlbW92ZShpLCAxKTtcbiAgICAgICAgICAgIGNvbW1hbmQucmVqZWN0KGFib3J0RXJyb3IoY29tbWFuZCkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaSsrO1xuICAgIH1cbn1cbi8vIElmIG9ubHkgYSBwYXJ0aWFsIHRyYW5zYWN0aW9uIHJlc3VsdCB3YXMgcmVjZWl2ZWQgYmVmb3JlIGNvbm5lY3Rpb24gY2xvc2UsXG4vLyB3ZSBoYXZlIHRvIGFib3J0IGFueSB0cmFuc2FjdGlvbiBmcmFnbWVudHMgdGhhdCBtYXkgaGF2ZSBlbmRlZCB1cCBpbiB0aGVcbi8vIG9mZmxpbmUgcXVldWVcbmZ1bmN0aW9uIGFib3J0VHJhbnNhY3Rpb25GcmFnbWVudHMoY29tbWFuZFF1ZXVlKSB7XG4gICAgdmFyIF9hO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgY29tbWFuZFF1ZXVlLmxlbmd0aDspIHtcbiAgICAgICAgY29uc3QgY29tbWFuZCA9IChfYSA9IGNvbW1hbmRRdWV1ZS5wZWVrQXQoaSkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb21tYW5kO1xuICAgICAgICBpZiAoY29tbWFuZC5uYW1lID09PSBcIm11bHRpXCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb21tYW5kLm5hbWUgPT09IFwiZXhlY1wiKSB7XG4gICAgICAgICAgICBjb21tYW5kUXVldWUucmVtb3ZlKGksIDEpO1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QoYWJvcnRFcnJvcihjb21tYW5kKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29tbWFuZC5pblRyYW5zYWN0aW9uKSB7XG4gICAgICAgICAgICBjb21tYW5kUXVldWUucmVtb3ZlKGksIDEpO1xuICAgICAgICAgICAgY29tbWFuZC5yZWplY3QoYWJvcnRFcnJvcihjb21tYW5kKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpKys7XG4gICAgICAgIH1cbiAgICB9XG59XG5mdW5jdGlvbiBjbG9zZUhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnN0IHByZXZTdGF0dXMgPSBzZWxmLnN0YXR1cztcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJjbG9zZVwiKTtcbiAgICAgICAgaWYgKHNlbGYuY29tbWFuZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgYWJvcnRJbmNvbXBsZXRlUGlwZWxpbmVzKHNlbGYuY29tbWFuZFF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5vZmZsaW5lUXVldWUubGVuZ3RoKSB7XG4gICAgICAgICAgICBhYm9ydFRyYW5zYWN0aW9uRnJhZ21lbnRzKHNlbGYub2ZmbGluZVF1ZXVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJldlN0YXR1cyA9PT0gXCJyZWFkeVwiKSB7XG4gICAgICAgICAgICBpZiAoIXNlbGYucHJldkNvbmRpdGlvbikge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldkNvbmRpdGlvbiA9IHNlbGYuY29uZGl0aW9uO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGYuY29tbWFuZFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHNlbGYucHJldkNvbW1hbmRRdWV1ZSA9IHNlbGYuY29tbWFuZFF1ZXVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm1hbnVhbGx5Q2xvc2luZykge1xuICAgICAgICAgICAgc2VsZi5tYW51YWxseUNsb3NpbmcgPSBmYWxzZTtcbiAgICAgICAgICAgIGRlYnVnKFwic2tpcCByZWNvbm5lY3Rpbmcgc2luY2UgdGhlIGNvbm5lY3Rpb24gaXMgbWFudWFsbHkgY2xvc2VkLlwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc2VsZi5vcHRpb25zLnJldHJ5U3RyYXRlZ3kgIT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICAgICAgZGVidWcoXCJza2lwIHJlY29ubmVjdGluZyBiZWNhdXNlIGByZXRyeVN0cmF0ZWd5YCBpcyBub3QgYSBmdW5jdGlvblwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJldHJ5RGVsYXkgPSBzZWxmLm9wdGlvbnMucmV0cnlTdHJhdGVneSgrK3NlbGYucmV0cnlBdHRlbXB0cyk7XG4gICAgICAgIGlmICh0eXBlb2YgcmV0cnlEZWxheSAhPT0gXCJudW1iZXJcIikge1xuICAgICAgICAgICAgZGVidWcoXCJza2lwIHJlY29ubmVjdGluZyBiZWNhdXNlIGByZXRyeVN0cmF0ZWd5YCBkb2Vzbid0IHJldHVybiBhIG51bWJlclwiKTtcbiAgICAgICAgICAgIHJldHVybiBjbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGRlYnVnKFwicmVjb25uZWN0IGluICVzbXNcIiwgcmV0cnlEZWxheSk7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwicmVjb25uZWN0aW5nXCIsIHJldHJ5RGVsYXkpO1xuICAgICAgICBzZWxmLnJlY29ubmVjdFRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHNlbGYucmVjb25uZWN0VGltZW91dCA9IG51bGw7XG4gICAgICAgICAgICBzZWxmLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9LCByZXRyeURlbGF5KTtcbiAgICAgICAgY29uc3QgeyBtYXhSZXRyaWVzUGVyUmVxdWVzdCB9ID0gc2VsZi5vcHRpb25zO1xuICAgICAgICBpZiAodHlwZW9mIG1heFJldHJpZXNQZXJSZXF1ZXN0ID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgICAgICBpZiAobWF4UmV0cmllc1BlclJlcXVlc3QgPCAwKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJtYXhSZXRyaWVzUGVyUmVxdWVzdCBpcyBuZWdhdGl2ZSwgaWdub3JpbmcuLi5cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBjb25zdCByZW1haW5kZXIgPSBzZWxmLnJldHJ5QXR0ZW1wdHMgJSAobWF4UmV0cmllc1BlclJlcXVlc3QgKyAxKTtcbiAgICAgICAgICAgICAgICBpZiAocmVtYWluZGVyID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicmVhY2ggbWF4UmV0cmllc1BlclJlcXVlc3QgbGltaXRhdGlvbiwgZmx1c2hpbmcgY29tbWFuZCBxdWV1ZS4uLlwiKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5mbHVzaFF1ZXVlKG5ldyBlcnJvcnNfMS5NYXhSZXRyaWVzUGVyUmVxdWVzdEVycm9yKG1heFJldHJpZXNQZXJSZXF1ZXN0KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBmdW5jdGlvbiBjbG9zZSgpIHtcbiAgICAgICAgc2VsZi5zZXRTdGF0dXMoXCJlbmRcIik7XG4gICAgICAgIHNlbGYuZmx1c2hRdWV1ZShuZXcgRXJyb3IodXRpbHNfMS5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cpKTtcbiAgICB9XG59XG5leHBvcnRzLmNsb3NlSGFuZGxlciA9IGNsb3NlSGFuZGxlcjtcbmZ1bmN0aW9uIGVycm9ySGFuZGxlcihzZWxmKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIChlcnJvcikge1xuICAgICAgICBkZWJ1ZyhcImVycm9yOiAlc1wiLCBlcnJvcik7XG4gICAgICAgIHNlbGYuc2lsZW50RW1pdChcImVycm9yXCIsIGVycm9yKTtcbiAgICB9O1xufVxuZXhwb3J0cy5lcnJvckhhbmRsZXIgPSBlcnJvckhhbmRsZXI7XG5mdW5jdGlvbiByZWFkeUhhbmRsZXIoc2VsZikge1xuICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNlbGYuc2V0U3RhdHVzKFwicmVhZHlcIik7XG4gICAgICAgIHNlbGYucmV0cnlBdHRlbXB0cyA9IDA7XG4gICAgICAgIGlmIChzZWxmLm9wdGlvbnMubW9uaXRvcikge1xuICAgICAgICAgICAgc2VsZi5jYWxsKFwibW9uaXRvclwiKS50aGVuKCgpID0+IHNlbGYuc2V0U3RhdHVzKFwibW9uaXRvcmluZ1wiKSwgKGVycm9yKSA9PiBzZWxmLmVtaXQoXCJlcnJvclwiLCBlcnJvcikpO1xuICAgICAgICAgICAgY29uc3QgeyBzZW5kQ29tbWFuZCB9ID0gc2VsZjtcbiAgICAgICAgICAgIHNlbGYuc2VuZENvbW1hbmQgPSBmdW5jdGlvbiAoY29tbWFuZCkge1xuICAgICAgICAgICAgICAgIGlmIChDb21tYW5kXzEuZGVmYXVsdC5jaGVja0ZsYWcoXCJWQUxJRF9JTl9NT05JVE9SX01PREVcIiwgY29tbWFuZC5uYW1lKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gc2VuZENvbW1hbmQuY2FsbChzZWxmLCBjb21tYW5kKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29tbWFuZC5yZWplY3QobmV3IEVycm9yKFwiQ29ubmVjdGlvbiBpcyBpbiBtb25pdG9yaW5nIG1vZGUsIGNhbid0IHByb2Nlc3MgY29tbWFuZHMuXCIpKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gY29tbWFuZC5wcm9taXNlO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHNlbGYub25jZShcImNsb3NlXCIsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgc2VsZi5zZW5kQ29tbWFuZDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZpbmFsU2VsZWN0ID0gc2VsZi5wcmV2Q29uZGl0aW9uXG4gICAgICAgICAgICA/IHNlbGYucHJldkNvbmRpdGlvbi5zZWxlY3RcbiAgICAgICAgICAgIDogc2VsZi5jb25kaXRpb24uc2VsZWN0O1xuICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmNvbm5lY3Rpb25OYW1lKSB7XG4gICAgICAgICAgICBkZWJ1ZyhcInNldCB0aGUgY29ubmVjdGlvbiBuYW1lIFslc11cIiwgc2VsZi5vcHRpb25zLmNvbm5lY3Rpb25OYW1lKTtcbiAgICAgICAgICAgIHNlbGYuY2xpZW50KFwic2V0bmFtZVwiLCBzZWxmLm9wdGlvbnMuY29ubmVjdGlvbk5hbWUpLmNhdGNoKHV0aWxzXzEubm9vcCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYub3B0aW9ucy5yZWFkT25seSkge1xuICAgICAgICAgICAgZGVidWcoXCJzZXQgdGhlIGNvbm5lY3Rpb24gdG8gcmVhZG9ubHkgbW9kZVwiKTtcbiAgICAgICAgICAgIHNlbGYucmVhZG9ubHkoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLnByZXZDb25kaXRpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbmRpdGlvbiA9IHNlbGYucHJldkNvbmRpdGlvbjtcbiAgICAgICAgICAgIHNlbGYucHJldkNvbmRpdGlvbiA9IG51bGw7XG4gICAgICAgICAgICBpZiAoY29uZGl0aW9uLnN1YnNjcmliZXIgJiYgc2VsZi5vcHRpb25zLmF1dG9SZXN1YnNjcmliZSkge1xuICAgICAgICAgICAgICAgIC8vIFdlIHJlLXNlbGVjdCB0aGUgcHJldmlvdXMgZGIgZmlyc3Qgc2luY2VcbiAgICAgICAgICAgICAgICAvLyBgU0VMRUNUYCBjb21tYW5kIGlzIG5vdCB2YWxpZCBpbiBzdWIgbW9kZS5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZi5jb25kaXRpb24uc2VsZWN0ICE9PSBmaW5hbFNlbGVjdCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcImNvbm5lY3QgdG8gZGIgWyVkXVwiLCBmaW5hbFNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc2VsZWN0KGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3Qgc3Vic2NyaWJlQ2hhbm5lbHMgPSBjb25kaXRpb24uc3Vic2NyaWJlci5jaGFubmVscyhcInN1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwic3Vic2NyaWJlICVkIGNoYW5uZWxzXCIsIHN1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3Vic2NyaWJlKHN1YnNjcmliZUNoYW5uZWxzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgcHN1YnNjcmliZUNoYW5uZWxzID0gY29uZGl0aW9uLnN1YnNjcmliZXIuY2hhbm5lbHMoXCJwc3Vic2NyaWJlXCIpO1xuICAgICAgICAgICAgICAgIGlmIChwc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlYnVnKFwicHN1YnNjcmliZSAlZCBjaGFubmVsc1wiLCBwc3Vic2NyaWJlQ2hhbm5lbHMubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAgICAgc2VsZi5wc3Vic2NyaWJlKHBzdWJzY3JpYmVDaGFubmVscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHNzdWJzY3JpYmVDaGFubmVscyA9IGNvbmRpdGlvbi5zdWJzY3JpYmVyLmNoYW5uZWxzKFwic3N1YnNjcmliZVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoc3N1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICBkZWJ1ZyhcInNzdWJzY3JpYmUgJWQgY2hhbm5lbHNcIiwgc3N1YnNjcmliZUNoYW5uZWxzLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuc3N1YnNjcmliZShzc3Vic2NyaWJlQ2hhbm5lbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoc2VsZi5wcmV2Q29tbWFuZFF1ZXVlKSB7XG4gICAgICAgICAgICBpZiAoc2VsZi5vcHRpb25zLmF1dG9SZXNlbmRVbmZ1bGZpbGxlZENvbW1hbmRzKSB7XG4gICAgICAgICAgICAgICAgZGVidWcoXCJyZXNlbmQgJWQgdW5mdWxmaWxsZWQgY29tbWFuZHNcIiwgc2VsZi5wcmV2Q29tbWFuZFF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICAgICAgd2hpbGUgKHNlbGYucHJldkNvbW1hbmRRdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzZWxmLnByZXZDb21tYW5kUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGl0ZW0uc2VsZWN0ICE9PSBzZWxmLmNvbmRpdGlvbi5zZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGl0ZW0uY29tbWFuZC5uYW1lICE9PSBcInNlbGVjdFwiKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgc2VsZi5zZW5kQ29tbWFuZChpdGVtLmNvbW1hbmQsIGl0ZW0uc3RyZWFtKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBzZWxmLnByZXZDb21tYW5kUXVldWUgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChzZWxmLm9mZmxpbmVRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGRlYnVnKFwic2VuZCAlZCBjb21tYW5kcyBpbiBvZmZsaW5lIHF1ZXVlXCIsIHNlbGYub2ZmbGluZVF1ZXVlLmxlbmd0aCk7XG4gICAgICAgICAgICBjb25zdCBvZmZsaW5lUXVldWUgPSBzZWxmLm9mZmxpbmVRdWV1ZTtcbiAgICAgICAgICAgIHNlbGYucmVzZXRPZmZsaW5lUXVldWUoKTtcbiAgICAgICAgICAgIHdoaWxlIChvZmZsaW5lUXVldWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBvZmZsaW5lUXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBpZiAoaXRlbS5zZWxlY3QgIT09IHNlbGYuY29uZGl0aW9uLnNlbGVjdCAmJlxuICAgICAgICAgICAgICAgICAgICBpdGVtLmNvbW1hbmQubmFtZSAhPT0gXCJzZWxlY3RcIikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLnNlbGVjdChpdGVtLnNlbGVjdCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHNlbGYuc2VuZENvbW1hbmQoaXRlbS5jb21tYW5kLCBpdGVtLnN0cmVhbSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNlbGYuY29uZGl0aW9uLnNlbGVjdCAhPT0gZmluYWxTZWxlY3QpIHtcbiAgICAgICAgICAgIGRlYnVnKFwiY29ubmVjdCB0byBkYiBbJWRdXCIsIGZpbmFsU2VsZWN0KTtcbiAgICAgICAgICAgIHNlbGYuc2VsZWN0KGZpbmFsU2VsZWN0KTtcbiAgICAgICAgfVxuICAgIH07XG59XG5leHBvcnRzLnJlYWR5SGFuZGxlciA9IHJlYWR5SGFuZGxlcjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/redis/event_handler.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/transaction.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/transaction.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.addTransactionSupport = void 0;\nconst utils_1 = __webpack_require__(/*! ./utils */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\");\nconst standard_as_callback_1 = __webpack_require__(/*! standard-as-callback */ \"(rsc)/../../node_modules/.pnpm/standard-as-callback@2.1.0/node_modules/standard-as-callback/built/index.js\");\nconst Pipeline_1 = __webpack_require__(/*! ./Pipeline */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Pipeline.js\");\nfunction addTransactionSupport(redis) {\n    redis.pipeline = function (commands) {\n        const pipeline = new Pipeline_1.default(this);\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        return pipeline;\n    };\n    const { multi } = redis;\n    redis.multi = function (commands, options) {\n        if (typeof options === \"undefined\" && !Array.isArray(commands)) {\n            options = commands;\n            commands = null;\n        }\n        if (options && options.pipeline === false) {\n            return multi.call(this);\n        }\n        const pipeline = new Pipeline_1.default(this);\n        // @ts-expect-error\n        pipeline.multi();\n        if (Array.isArray(commands)) {\n            pipeline.addBatch(commands);\n        }\n        const exec = pipeline.exec;\n        pipeline.exec = function (callback) {\n            // Wait for the cluster to be connected, since we need nodes information before continuing\n            if (this.isCluster && !this.redis.slots.length) {\n                if (this.redis.status === \"wait\")\n                    this.redis.connect().catch(utils_1.noop);\n                return (0, standard_as_callback_1.default)(new Promise((resolve, reject) => {\n                    this.redis.delayUntilReady((err) => {\n                        if (err) {\n                            reject(err);\n                            return;\n                        }\n                        this.exec(pipeline).then(resolve, reject);\n                    });\n                }), callback);\n            }\n            if (this._transactions > 0) {\n                exec.call(pipeline);\n            }\n            // Returns directly when the pipeline\n            // has been called multiple times (retries).\n            if (this.nodeifiedPromise) {\n                return exec.call(pipeline);\n            }\n            const promise = exec.call(pipeline);\n            return (0, standard_as_callback_1.default)(promise.then(function (result) {\n                const execResult = result[result.length - 1];\n                if (typeof execResult === \"undefined\") {\n                    throw new Error(\"Pipeline cannot be used to send any commands when the `exec()` has been called on it.\");\n                }\n                if (execResult[0]) {\n                    execResult[0].previousErrors = [];\n                    for (let i = 0; i < result.length - 1; ++i) {\n                        if (result[i][0]) {\n                            execResult[0].previousErrors.push(result[i][0]);\n                        }\n                    }\n                    throw execResult[0];\n                }\n                return (0, utils_1.wrapMultiResult)(execResult[1]);\n            }), callback);\n        };\n        // @ts-expect-error\n        const { execBuffer } = pipeline;\n        // @ts-expect-error\n        pipeline.execBuffer = function (callback) {\n            if (this._transactions > 0) {\n                execBuffer.call(pipeline);\n            }\n            return pipeline.exec(callback);\n        };\n        return pipeline;\n    };\n    const { exec } = redis;\n    redis.exec = function (callback) {\n        return (0, standard_as_callback_1.default)(exec.call(this).then(function (results) {\n            if (Array.isArray(results)) {\n                results = (0, utils_1.wrapMultiResult)(results);\n            }\n            return results;\n        }), callback);\n    };\n}\nexports.addTransactionSupport = addTransactionSupport;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdHJhbnNhY3Rpb24uanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsNkJBQTZCO0FBQzdCLGdCQUFnQixtQkFBTyxDQUFDLHVHQUFTO0FBQ2pDLCtCQUErQixtQkFBTyxDQUFDLHdJQUFzQjtBQUM3RCxtQkFBbUIsbUJBQU8sQ0FBQyx1R0FBWTtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyx1QkFBdUI7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGdCQUFnQixhQUFhO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksT0FBTztBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLDZCQUE2QiIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdHJhbnNhY3Rpb24uanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZFRyYW5zYWN0aW9uU3VwcG9ydCA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzXzEgPSByZXF1aXJlKFwiLi91dGlsc1wiKTtcbmNvbnN0IHN0YW5kYXJkX2FzX2NhbGxiYWNrXzEgPSByZXF1aXJlKFwic3RhbmRhcmQtYXMtY2FsbGJhY2tcIik7XG5jb25zdCBQaXBlbGluZV8xID0gcmVxdWlyZShcIi4vUGlwZWxpbmVcIik7XG5mdW5jdGlvbiBhZGRUcmFuc2FjdGlvblN1cHBvcnQocmVkaXMpIHtcbiAgICByZWRpcy5waXBlbGluZSA9IGZ1bmN0aW9uIChjb21tYW5kcykge1xuICAgICAgICBjb25zdCBwaXBlbGluZSA9IG5ldyBQaXBlbGluZV8xLmRlZmF1bHQodGhpcyk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgcGlwZWxpbmUuYWRkQmF0Y2goY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBwaXBlbGluZTtcbiAgICB9O1xuICAgIGNvbnN0IHsgbXVsdGkgfSA9IHJlZGlzO1xuICAgIHJlZGlzLm11bHRpID0gZnVuY3Rpb24gKGNvbW1hbmRzLCBvcHRpb25zKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gXCJ1bmRlZmluZWRcIiAmJiAhQXJyYXkuaXNBcnJheShjb21tYW5kcykpIHtcbiAgICAgICAgICAgIG9wdGlvbnMgPSBjb21tYW5kcztcbiAgICAgICAgICAgIGNvbW1hbmRzID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLnBpcGVsaW5lID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcmV0dXJuIG11bHRpLmNhbGwodGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcGlwZWxpbmUgPSBuZXcgUGlwZWxpbmVfMS5kZWZhdWx0KHRoaXMpO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHBpcGVsaW5lLm11bHRpKCk7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGNvbW1hbmRzKSkge1xuICAgICAgICAgICAgcGlwZWxpbmUuYWRkQmF0Y2goY29tbWFuZHMpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4ZWMgPSBwaXBlbGluZS5leGVjO1xuICAgICAgICBwaXBlbGluZS5leGVjID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAvLyBXYWl0IGZvciB0aGUgY2x1c3RlciB0byBiZSBjb25uZWN0ZWQsIHNpbmNlIHdlIG5lZWQgbm9kZXMgaW5mb3JtYXRpb24gYmVmb3JlIGNvbnRpbnVpbmdcbiAgICAgICAgICAgIGlmICh0aGlzLmlzQ2x1c3RlciAmJiAhdGhpcy5yZWRpcy5zbG90cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZWRpcy5zdGF0dXMgPT09IFwid2FpdFwiKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlZGlzLmNvbm5lY3QoKS5jYXRjaCh1dGlsc18xLm5vb3ApO1xuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVkaXMuZGVsYXlVbnRpbFJlYWR5KChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWplY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4ZWMocGlwZWxpbmUpLnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfSksIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZXhlYy5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJldHVybnMgZGlyZWN0bHkgd2hlbiB0aGUgcGlwZWxpbmVcbiAgICAgICAgICAgIC8vIGhhcyBiZWVuIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyAocmV0cmllcykuXG4gICAgICAgICAgICBpZiAodGhpcy5ub2RlaWZpZWRQcm9taXNlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGV4ZWMuY2FsbChwaXBlbGluZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCBwcm9taXNlID0gZXhlYy5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShwcm9taXNlLnRoZW4oZnVuY3Rpb24gKHJlc3VsdCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGV4ZWNSZXN1bHQgPSByZXN1bHRbcmVzdWx0Lmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZXhlY1Jlc3VsdCA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJQaXBlbGluZSBjYW5ub3QgYmUgdXNlZCB0byBzZW5kIGFueSBjb21tYW5kcyB3aGVuIHRoZSBgZXhlYygpYCBoYXMgYmVlbiBjYWxsZWQgb24gaXQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAoZXhlY1Jlc3VsdFswXSkge1xuICAgICAgICAgICAgICAgICAgICBleGVjUmVzdWx0WzBdLnByZXZpb3VzRXJyb3JzID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcmVzdWx0Lmxlbmd0aCAtIDE7ICsraSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdFtpXVswXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGV4ZWNSZXN1bHRbMF0ucHJldmlvdXNFcnJvcnMucHVzaChyZXN1bHRbaV1bMF0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRocm93IGV4ZWNSZXN1bHRbMF07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybiAoMCwgdXRpbHNfMS53cmFwTXVsdGlSZXN1bHQpKGV4ZWNSZXN1bHRbMV0pO1xuICAgICAgICAgICAgfSksIGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvclxuICAgICAgICBjb25zdCB7IGV4ZWNCdWZmZXIgfSA9IHBpcGVsaW5lO1xuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIHBpcGVsaW5lLmV4ZWNCdWZmZXIgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLl90cmFuc2FjdGlvbnMgPiAwKSB7XG4gICAgICAgICAgICAgICAgZXhlY0J1ZmZlci5jYWxsKHBpcGVsaW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBwaXBlbGluZS5leGVjKGNhbGxiYWNrKTtcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHBpcGVsaW5lO1xuICAgIH07XG4gICAgY29uc3QgeyBleGVjIH0gPSByZWRpcztcbiAgICByZWRpcy5leGVjID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHJldHVybiAoMCwgc3RhbmRhcmRfYXNfY2FsbGJhY2tfMS5kZWZhdWx0KShleGVjLmNhbGwodGhpcykudGhlbihmdW5jdGlvbiAocmVzdWx0cykge1xuICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocmVzdWx0cykpIHtcbiAgICAgICAgICAgICAgICByZXN1bHRzID0gKDAsIHV0aWxzXzEud3JhcE11bHRpUmVzdWx0KShyZXN1bHRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiByZXN1bHRzO1xuICAgICAgICB9KSwgY2FsbGJhY2spO1xuICAgIH07XG59XG5leHBvcnRzLmFkZFRyYW5zYWN0aW9uU3VwcG9ydCA9IGFkZFRyYW5zYWN0aW9uU3VwcG9ydDtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/transaction.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/Commander.js":
/*!********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/Commander.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst commands_1 = __webpack_require__(/*! @ioredis/commands */ \"(rsc)/../../node_modules/.pnpm/@ioredis+commands@1.2.0/node_modules/@ioredis/commands/built/index.js\");\nconst autoPipelining_1 = __webpack_require__(/*! ../autoPipelining */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/autoPipelining.js\");\nconst Command_1 = __webpack_require__(/*! ../Command */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Command.js\");\nconst Script_1 = __webpack_require__(/*! ../Script */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/Script.js\");\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nclass Commander {\n    constructor() {\n        this.options = {};\n        /**\n         * @ignore\n         */\n        this.scriptsSet = {};\n        /**\n         * @ignore\n         */\n        this.addedBuiltinSet = new Set();\n    }\n    /**\n     * Return supported builtin commands\n     */\n    getBuiltinCommands() {\n        return commands.slice(0);\n    }\n    /**\n     * Create a builtin command\n     */\n    createBuiltinCommand(commandName) {\n        return {\n            string: generateFunction(null, commandName, \"utf8\"),\n            buffer: generateFunction(null, commandName, null),\n        };\n    }\n    /**\n     * Create add builtin command\n     */\n    addBuiltinCommand(commandName) {\n        this.addedBuiltinSet.add(commandName);\n        this[commandName] = generateFunction(commandName, commandName, \"utf8\");\n        this[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n    }\n    /**\n     * Define a custom command using lua script\n     */\n    defineCommand(name, definition) {\n        const script = new Script_1.default(definition.lua, definition.numberOfKeys, this.options.keyPrefix, definition.readOnly);\n        this.scriptsSet[name] = script;\n        this[name] = generateScriptingFunction(name, name, script, \"utf8\");\n        this[name + \"Buffer\"] = generateScriptingFunction(name + \"Buffer\", name, script, null);\n    }\n    /**\n     * @ignore\n     */\n    sendCommand(command, stream, node) {\n        throw new Error('\"sendCommand\" is not implemented');\n    }\n}\nconst commands = commands_1.list.filter((command) => command !== \"monitor\");\ncommands.push(\"sentinel\");\ncommands.forEach(function (commandName) {\n    Commander.prototype[commandName] = generateFunction(commandName, commandName, \"utf8\");\n    Commander.prototype[commandName + \"Buffer\"] = generateFunction(commandName + \"Buffer\", commandName, null);\n});\nCommander.prototype.call = generateFunction(\"call\", \"utf8\");\nCommander.prototype.callBuffer = generateFunction(\"callBuffer\", null);\n// @ts-expect-error\nCommander.prototype.send_command = Commander.prototype.call;\nfunction generateFunction(functionName, _commandName, _encoding) {\n    if (typeof _encoding === \"undefined\") {\n        _encoding = _commandName;\n        _commandName = null;\n    }\n    return function (...args) {\n        const commandName = (_commandName || args.shift());\n        let callback = args[args.length - 1];\n        if (typeof callback === \"function\") {\n            args.pop();\n        }\n        else {\n            callback = undefined;\n        }\n        const options = {\n            errorStack: this.options.showFriendlyErrorStack ? new Error() : undefined,\n            keyPrefix: this.options.keyPrefix,\n            replyEncoding: _encoding,\n        };\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return this.sendCommand(\n            // @ts-expect-error\n            new Command_1.default(commandName, args, options, callback));\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, \n        // @ts-expect-error\n        args, callback);\n    };\n}\nfunction generateScriptingFunction(functionName, commandName, script, encoding) {\n    return function (...args) {\n        const callback = typeof args[args.length - 1] === \"function\" ? args.pop() : undefined;\n        const options = {\n            replyEncoding: encoding,\n        };\n        if (this.options.showFriendlyErrorStack) {\n            options.errorStack = new Error();\n        }\n        // No auto pipeline, use regular command sending\n        if (!(0, autoPipelining_1.shouldUseAutoPipelining)(this, functionName, commandName)) {\n            return script.execute(this, args, options, callback);\n        }\n        // Create a new pipeline and make sure it's scheduled\n        return (0, autoPipelining_1.executeWithAutoPipelining)(this, functionName, commandName, args, callback);\n    };\n}\nexports[\"default\"] = Commander;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvQ29tbWFuZGVyLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixtQkFBTyxDQUFDLCtIQUFtQjtBQUM5Qyx5QkFBeUIsbUJBQU8sQ0FBQyxvSEFBbUI7QUFDcEQsa0JBQWtCLG1CQUFPLENBQUMsc0dBQVk7QUFDdEMsaUJBQWlCLG1CQUFPLENBQUMsb0dBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWUiLCJzb3VyY2VzIjpbIi9Vc2Vycy9qb3NodWFqYW5zZXZhbnJlbnNidXJnL0Rlc2t0b3AvNC4gQ29kZS9wb2RjYXN0LXBsYXRmb3JtL25vZGVfbW9kdWxlcy8ucG5wbS9pb3JlZGlzQDUuNi4xL25vZGVfbW9kdWxlcy9pb3JlZGlzL2J1aWx0L3V0aWxzL0NvbW1hbmRlci5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmNvbnN0IGNvbW1hbmRzXzEgPSByZXF1aXJlKFwiQGlvcmVkaXMvY29tbWFuZHNcIik7XG5jb25zdCBhdXRvUGlwZWxpbmluZ18xID0gcmVxdWlyZShcIi4uL2F1dG9QaXBlbGluaW5nXCIpO1xuY29uc3QgQ29tbWFuZF8xID0gcmVxdWlyZShcIi4uL0NvbW1hbmRcIik7XG5jb25zdCBTY3JpcHRfMSA9IHJlcXVpcmUoXCIuLi9TY3JpcHRcIik7XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG5jbGFzcyBDb21tYW5kZXIge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLm9wdGlvbnMgPSB7fTtcbiAgICAgICAgLyoqXG4gICAgICAgICAqIEBpZ25vcmVcbiAgICAgICAgICovXG4gICAgICAgIHRoaXMuc2NyaXB0c1NldCA9IHt9O1xuICAgICAgICAvKipcbiAgICAgICAgICogQGlnbm9yZVxuICAgICAgICAgKi9cbiAgICAgICAgdGhpcy5hZGRlZEJ1aWx0aW5TZXQgPSBuZXcgU2V0KCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJldHVybiBzdXBwb3J0ZWQgYnVpbHRpbiBjb21tYW5kc1xuICAgICAqL1xuICAgIGdldEJ1aWx0aW5Db21tYW5kcygpIHtcbiAgICAgICAgcmV0dXJuIGNvbW1hbmRzLnNsaWNlKDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBidWlsdGluIGNvbW1hbmRcbiAgICAgKi9cbiAgICBjcmVhdGVCdWlsdGluQ29tbWFuZChjb21tYW5kTmFtZSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RyaW5nOiBnZW5lcmF0ZUZ1bmN0aW9uKG51bGwsIGNvbW1hbmROYW1lLCBcInV0ZjhcIiksXG4gICAgICAgICAgICBidWZmZXI6IGdlbmVyYXRlRnVuY3Rpb24obnVsbCwgY29tbWFuZE5hbWUsIG51bGwpLFxuICAgICAgICB9O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYWRkIGJ1aWx0aW4gY29tbWFuZFxuICAgICAqL1xuICAgIGFkZEJ1aWx0aW5Db21tYW5kKGNvbW1hbmROYW1lKSB7XG4gICAgICAgIHRoaXMuYWRkZWRCdWlsdGluU2V0LmFkZChjb21tYW5kTmFtZSk7XG4gICAgICAgIHRoaXNbY29tbWFuZE5hbWVdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSwgY29tbWFuZE5hbWUsIFwidXRmOFwiKTtcbiAgICAgICAgdGhpc1tjb21tYW5kTmFtZSArIFwiQnVmZmVyXCJdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSArIFwiQnVmZmVyXCIsIGNvbW1hbmROYW1lLCBudWxsKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGVmaW5lIGEgY3VzdG9tIGNvbW1hbmQgdXNpbmcgbHVhIHNjcmlwdFxuICAgICAqL1xuICAgIGRlZmluZUNvbW1hbmQobmFtZSwgZGVmaW5pdGlvbikge1xuICAgICAgICBjb25zdCBzY3JpcHQgPSBuZXcgU2NyaXB0XzEuZGVmYXVsdChkZWZpbml0aW9uLmx1YSwgZGVmaW5pdGlvbi5udW1iZXJPZktleXMsIHRoaXMub3B0aW9ucy5rZXlQcmVmaXgsIGRlZmluaXRpb24ucmVhZE9ubHkpO1xuICAgICAgICB0aGlzLnNjcmlwdHNTZXRbbmFtZV0gPSBzY3JpcHQ7XG4gICAgICAgIHRoaXNbbmFtZV0gPSBnZW5lcmF0ZVNjcmlwdGluZ0Z1bmN0aW9uKG5hbWUsIG5hbWUsIHNjcmlwdCwgXCJ1dGY4XCIpO1xuICAgICAgICB0aGlzW25hbWUgKyBcIkJ1ZmZlclwiXSA9IGdlbmVyYXRlU2NyaXB0aW5nRnVuY3Rpb24obmFtZSArIFwiQnVmZmVyXCIsIG5hbWUsIHNjcmlwdCwgbnVsbCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEBpZ25vcmVcbiAgICAgKi9cbiAgICBzZW5kQ29tbWFuZChjb21tYW5kLCBzdHJlYW0sIG5vZGUpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdcInNlbmRDb21tYW5kXCIgaXMgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxufVxuY29uc3QgY29tbWFuZHMgPSBjb21tYW5kc18xLmxpc3QuZmlsdGVyKChjb21tYW5kKSA9PiBjb21tYW5kICE9PSBcIm1vbml0b3JcIik7XG5jb21tYW5kcy5wdXNoKFwic2VudGluZWxcIik7XG5jb21tYW5kcy5mb3JFYWNoKGZ1bmN0aW9uIChjb21tYW5kTmFtZSkge1xuICAgIENvbW1hbmRlci5wcm90b3R5cGVbY29tbWFuZE5hbWVdID0gZ2VuZXJhdGVGdW5jdGlvbihjb21tYW5kTmFtZSwgY29tbWFuZE5hbWUsIFwidXRmOFwiKTtcbiAgICBDb21tYW5kZXIucHJvdG90eXBlW2NvbW1hbmROYW1lICsgXCJCdWZmZXJcIl0gPSBnZW5lcmF0ZUZ1bmN0aW9uKGNvbW1hbmROYW1lICsgXCJCdWZmZXJcIiwgY29tbWFuZE5hbWUsIG51bGwpO1xufSk7XG5Db21tYW5kZXIucHJvdG90eXBlLmNhbGwgPSBnZW5lcmF0ZUZ1bmN0aW9uKFwiY2FsbFwiLCBcInV0ZjhcIik7XG5Db21tYW5kZXIucHJvdG90eXBlLmNhbGxCdWZmZXIgPSBnZW5lcmF0ZUZ1bmN0aW9uKFwiY2FsbEJ1ZmZlclwiLCBudWxsKTtcbi8vIEB0cy1leHBlY3QtZXJyb3JcbkNvbW1hbmRlci5wcm90b3R5cGUuc2VuZF9jb21tYW5kID0gQ29tbWFuZGVyLnByb3RvdHlwZS5jYWxsO1xuZnVuY3Rpb24gZ2VuZXJhdGVGdW5jdGlvbihmdW5jdGlvbk5hbWUsIF9jb21tYW5kTmFtZSwgX2VuY29kaW5nKSB7XG4gICAgaWYgKHR5cGVvZiBfZW5jb2RpbmcgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgX2VuY29kaW5nID0gX2NvbW1hbmROYW1lO1xuICAgICAgICBfY29tbWFuZE5hbWUgPSBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gKC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgY29tbWFuZE5hbWUgPSAoX2NvbW1hbmROYW1lIHx8IGFyZ3Muc2hpZnQoKSk7XG4gICAgICAgIGxldCBjYWxsYmFjayA9IGFyZ3NbYXJncy5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB1bmRlZmluZWQ7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIGVycm9yU3RhY2s6IHRoaXMub3B0aW9ucy5zaG93RnJpZW5kbHlFcnJvclN0YWNrID8gbmV3IEVycm9yKCkgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBrZXlQcmVmaXg6IHRoaXMub3B0aW9ucy5rZXlQcmVmaXgsXG4gICAgICAgICAgICByZXBseUVuY29kaW5nOiBfZW5jb2RpbmcsXG4gICAgICAgIH07XG4gICAgICAgIC8vIE5vIGF1dG8gcGlwZWxpbmUsIHVzZSByZWd1bGFyIGNvbW1hbmQgc2VuZGluZ1xuICAgICAgICBpZiAoISgwLCBhdXRvUGlwZWxpbmluZ18xLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nKSh0aGlzLCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2VuZENvbW1hbmQoXG4gICAgICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgICAgICBuZXcgQ29tbWFuZF8xLmRlZmF1bHQoY29tbWFuZE5hbWUsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgbmV3IHBpcGVsaW5lIGFuZCBtYWtlIHN1cmUgaXQncyBzY2hlZHVsZWRcbiAgICAgICAgcmV0dXJuICgwLCBhdXRvUGlwZWxpbmluZ18xLmV4ZWN1dGVXaXRoQXV0b1BpcGVsaW5pbmcpKHRoaXMsIGZ1bmN0aW9uTmFtZSwgY29tbWFuZE5hbWUsIFxuICAgICAgICAvLyBAdHMtZXhwZWN0LWVycm9yXG4gICAgICAgIGFyZ3MsIGNhbGxiYWNrKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gZ2VuZXJhdGVTY3JpcHRpbmdGdW5jdGlvbihmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lLCBzY3JpcHQsIGVuY29kaW5nKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uICguLi5hcmdzKSB7XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSA9PT0gXCJmdW5jdGlvblwiID8gYXJncy5wb3AoKSA6IHVuZGVmaW5lZDtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIHJlcGx5RW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnNob3dGcmllbmRseUVycm9yU3RhY2spIHtcbiAgICAgICAgICAgIG9wdGlvbnMuZXJyb3JTdGFjayA9IG5ldyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8vIE5vIGF1dG8gcGlwZWxpbmUsIHVzZSByZWd1bGFyIGNvbW1hbmQgc2VuZGluZ1xuICAgICAgICBpZiAoISgwLCBhdXRvUGlwZWxpbmluZ18xLnNob3VsZFVzZUF1dG9QaXBlbGluaW5nKSh0aGlzLCBmdW5jdGlvbk5hbWUsIGNvbW1hbmROYW1lKSkge1xuICAgICAgICAgICAgcmV0dXJuIHNjcmlwdC5leGVjdXRlKHRoaXMsIGFyZ3MsIG9wdGlvbnMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgcGlwZWxpbmUgYW5kIG1ha2Ugc3VyZSBpdCdzIHNjaGVkdWxlZFxuICAgICAgICByZXR1cm4gKDAsIGF1dG9QaXBlbGluaW5nXzEuZXhlY3V0ZVdpdGhBdXRvUGlwZWxpbmluZykodGhpcywgZnVuY3Rpb25OYW1lLCBjb21tYW5kTmFtZSwgYXJncywgY2FsbGJhY2spO1xuICAgIH07XG59XG5leHBvcnRzLmRlZmF1bHQgPSBDb21tYW5kZXI7XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/Commander.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/applyMixin.js":
/*!*********************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/applyMixin.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction applyMixin(derivedConstructor, mixinConstructor) {\n    Object.getOwnPropertyNames(mixinConstructor.prototype).forEach((name) => {\n        Object.defineProperty(derivedConstructor.prototype, name, Object.getOwnPropertyDescriptor(mixinConstructor.prototype, name));\n    });\n}\nexports[\"default\"] = applyMixin;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvYXBwbHlNaXhpbi5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiLDhDQUE2QyxFQUFFLGFBQWEsRUFBQztBQUM3RDtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvYXBwbHlNaXhpbi5qcyJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmZ1bmN0aW9uIGFwcGx5TWl4aW4oZGVyaXZlZENvbnN0cnVjdG9yLCBtaXhpbkNvbnN0cnVjdG9yKSB7XG4gICAgT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMobWl4aW5Db25zdHJ1Y3Rvci5wcm90b3R5cGUpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGRlcml2ZWRDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIG5hbWUsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobWl4aW5Db25zdHJ1Y3Rvci5wcm90b3R5cGUsIG5hbWUpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGFwcGx5TWl4aW47XG4iXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/applyMixin.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/debug.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/debug.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.genRedactedString = exports.getStringValue = exports.MAX_ARGUMENT_LENGTH = void 0;\nconst debug_1 = __webpack_require__(/*! debug */ \"(rsc)/../../node_modules/.pnpm/debug@4.4.1/node_modules/debug/src/index.js\");\nconst MAX_ARGUMENT_LENGTH = 200;\nexports.MAX_ARGUMENT_LENGTH = MAX_ARGUMENT_LENGTH;\nconst NAMESPACE_PREFIX = \"ioredis\";\n/**\n * helper function that tried to get a string value for\n * arbitrary \"debug\" arg\n */\nfunction getStringValue(v) {\n    if (v === null) {\n        return;\n    }\n    switch (typeof v) {\n        case \"boolean\":\n            return;\n        case \"number\":\n            return;\n        case \"object\":\n            if (Buffer.isBuffer(v)) {\n                return v.toString(\"hex\");\n            }\n            if (Array.isArray(v)) {\n                return v.join(\",\");\n            }\n            try {\n                return JSON.stringify(v);\n            }\n            catch (e) {\n                return;\n            }\n        case \"string\":\n            return v;\n    }\n}\nexports.getStringValue = getStringValue;\n/**\n * helper function that redacts a string representation of a \"debug\" arg\n */\nfunction genRedactedString(str, maxLen) {\n    const { length } = str;\n    return length <= maxLen\n        ? str\n        : str.slice(0, maxLen) + ' ... <REDACTED full-length=\"' + length + '\">';\n}\nexports.genRedactedString = genRedactedString;\n/**\n * a wrapper for the `debug` module, used to generate\n * \"debug functions\" that trim the values in their output\n */\nfunction genDebugFunction(namespace) {\n    const fn = (0, debug_1.default)(`${NAMESPACE_PREFIX}:${namespace}`);\n    function wrappedDebug(...args) {\n        if (!fn.enabled) {\n            return; // no-op\n        }\n        // we skip the first arg because that is the message\n        for (let i = 1; i < args.length; i++) {\n            const str = getStringValue(args[i]);\n            if (typeof str === \"string\" && str.length > MAX_ARGUMENT_LENGTH) {\n                args[i] = genRedactedString(str, MAX_ARGUMENT_LENGTH);\n            }\n        }\n        return fn.apply(null, args);\n    }\n    Object.defineProperties(wrappedDebug, {\n        namespace: {\n            get() {\n                return fn.namespace;\n            },\n        },\n        enabled: {\n            get() {\n                return fn.enabled;\n            },\n        },\n        destroy: {\n            get() {\n                return fn.destroy;\n            },\n        },\n        log: {\n            get() {\n                return fn.log;\n            },\n            set(l) {\n                fn.log = l;\n            },\n        },\n    });\n    return wrappedDebug;\n}\nexports[\"default\"] = genDebugFunction;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvZGVidWcuanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QseUJBQXlCLEdBQUcsc0JBQXNCLEdBQUcsMkJBQTJCO0FBQ2hGLGdCQUFnQixtQkFBTyxDQUFDLHlGQUFPO0FBQy9CO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxTQUFTO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsaUJBQWlCLEdBQUcsVUFBVTtBQUNyRTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQSx3QkFBd0IsaUJBQWlCO0FBQ3pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQSxrQkFBZSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvZGVidWcuanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdlblJlZGFjdGVkU3RyaW5nID0gZXhwb3J0cy5nZXRTdHJpbmdWYWx1ZSA9IGV4cG9ydHMuTUFYX0FSR1VNRU5UX0xFTkdUSCA9IHZvaWQgMDtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiZGVidWdcIik7XG5jb25zdCBNQVhfQVJHVU1FTlRfTEVOR1RIID0gMjAwO1xuZXhwb3J0cy5NQVhfQVJHVU1FTlRfTEVOR1RIID0gTUFYX0FSR1VNRU5UX0xFTkdUSDtcbmNvbnN0IE5BTUVTUEFDRV9QUkVGSVggPSBcImlvcmVkaXNcIjtcbi8qKlxuICogaGVscGVyIGZ1bmN0aW9uIHRoYXQgdHJpZWQgdG8gZ2V0IGEgc3RyaW5nIHZhbHVlIGZvclxuICogYXJiaXRyYXJ5IFwiZGVidWdcIiBhcmdcbiAqL1xuZnVuY3Rpb24gZ2V0U3RyaW5nVmFsdWUodikge1xuICAgIGlmICh2ID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgc3dpdGNoICh0eXBlb2Ygdikge1xuICAgICAgICBjYXNlIFwiYm9vbGVhblwiOlxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBjYXNlIFwibnVtYmVyXCI6XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGlmIChCdWZmZXIuaXNCdWZmZXIodikpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdi50b1N0cmluZyhcImhleFwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KHYpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHYuam9pbihcIixcIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICBjYXNlIFwic3RyaW5nXCI6XG4gICAgICAgICAgICByZXR1cm4gdjtcbiAgICB9XG59XG5leHBvcnRzLmdldFN0cmluZ1ZhbHVlID0gZ2V0U3RyaW5nVmFsdWU7XG4vKipcbiAqIGhlbHBlciBmdW5jdGlvbiB0aGF0IHJlZGFjdHMgYSBzdHJpbmcgcmVwcmVzZW50YXRpb24gb2YgYSBcImRlYnVnXCIgYXJnXG4gKi9cbmZ1bmN0aW9uIGdlblJlZGFjdGVkU3RyaW5nKHN0ciwgbWF4TGVuKSB7XG4gICAgY29uc3QgeyBsZW5ndGggfSA9IHN0cjtcbiAgICByZXR1cm4gbGVuZ3RoIDw9IG1heExlblxuICAgICAgICA/IHN0clxuICAgICAgICA6IHN0ci5zbGljZSgwLCBtYXhMZW4pICsgJyAuLi4gPFJFREFDVEVEIGZ1bGwtbGVuZ3RoPVwiJyArIGxlbmd0aCArICdcIj4nO1xufVxuZXhwb3J0cy5nZW5SZWRhY3RlZFN0cmluZyA9IGdlblJlZGFjdGVkU3RyaW5nO1xuLyoqXG4gKiBhIHdyYXBwZXIgZm9yIHRoZSBgZGVidWdgIG1vZHVsZSwgdXNlZCB0byBnZW5lcmF0ZVxuICogXCJkZWJ1ZyBmdW5jdGlvbnNcIiB0aGF0IHRyaW0gdGhlIHZhbHVlcyBpbiB0aGVpciBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2VuRGVidWdGdW5jdGlvbihuYW1lc3BhY2UpIHtcbiAgICBjb25zdCBmbiA9ICgwLCBkZWJ1Z18xLmRlZmF1bHQpKGAke05BTUVTUEFDRV9QUkVGSVh9OiR7bmFtZXNwYWNlfWApO1xuICAgIGZ1bmN0aW9uIHdyYXBwZWREZWJ1ZyguLi5hcmdzKSB7XG4gICAgICAgIGlmICghZm4uZW5hYmxlZCkge1xuICAgICAgICAgICAgcmV0dXJuOyAvLyBuby1vcFxuICAgICAgICB9XG4gICAgICAgIC8vIHdlIHNraXAgdGhlIGZpcnN0IGFyZyBiZWNhdXNlIHRoYXQgaXMgdGhlIG1lc3NhZ2VcbiAgICAgICAgZm9yIChsZXQgaSA9IDE7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBzdHIgPSBnZXRTdHJpbmdWYWx1ZShhcmdzW2ldKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygc3RyID09PSBcInN0cmluZ1wiICYmIHN0ci5sZW5ndGggPiBNQVhfQVJHVU1FTlRfTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tpXSA9IGdlblJlZGFjdGVkU3RyaW5nKHN0ciwgTUFYX0FSR1VNRU5UX0xFTkdUSCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZuLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh3cmFwcGVkRGVidWcsIHtcbiAgICAgICAgbmFtZXNwYWNlOiB7XG4gICAgICAgICAgICBnZXQoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZuLm5hbWVzcGFjZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGVuYWJsZWQ6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uZW5hYmxlZDtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGRlc3Ryb3k6IHtcbiAgICAgICAgICAgIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZm4uZGVzdHJveTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0sXG4gICAgICAgIGxvZzoge1xuICAgICAgICAgICAgZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmbi5sb2c7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgc2V0KGwpIHtcbiAgICAgICAgICAgICAgICBmbi5sb2cgPSBsO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSxcbiAgICB9KTtcbiAgICByZXR1cm4gd3JhcHBlZERlYnVnO1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gZ2VuRGVidWdGdW5jdGlvbjtcbiJdLCJuYW1lcyI6W10sImlnbm9yZUxpc3QiOlswXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/debug.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js":
/*!****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.noop = exports.defaults = exports.Debug = exports.zipMap = exports.CONNECTION_CLOSED_ERROR_MSG = exports.shuffle = exports.sample = exports.resolveTLSProfile = exports.parseURL = exports.optimizeErrorStack = exports.toArg = exports.convertMapToArray = exports.convertObjectToArray = exports.timeout = exports.packObject = exports.isInt = exports.wrapMultiResult = exports.convertBufferToString = void 0;\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst lodash_1 = __webpack_require__(/*! ./lodash */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/lodash.js\");\nObject.defineProperty(exports, \"defaults\", ({ enumerable: true, get: function () { return lodash_1.defaults; } }));\nObject.defineProperty(exports, \"noop\", ({ enumerable: true, get: function () { return lodash_1.noop; } }));\nconst debug_1 = __webpack_require__(/*! ./debug */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/debug.js\");\nexports.Debug = debug_1.default;\nconst TLSProfiles_1 = __webpack_require__(/*! ../constants/TLSProfiles */ \"(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/constants/TLSProfiles.js\");\n/**\n * Convert a buffer to string, supports buffer array\n *\n * @example\n * ```js\n * const input = [Buffer.from('foo'), [Buffer.from('bar')]]\n * const res = convertBufferToString(input, 'utf8')\n * expect(res).to.eql(['foo', ['bar']])\n * ```\n */\nfunction convertBufferToString(value, encoding) {\n    if (value instanceof Buffer) {\n        return value.toString(encoding);\n    }\n    if (Array.isArray(value)) {\n        const length = value.length;\n        const res = Array(length);\n        for (let i = 0; i < length; ++i) {\n            res[i] =\n                value[i] instanceof Buffer && encoding === \"utf8\"\n                    ? value[i].toString()\n                    : convertBufferToString(value[i], encoding);\n        }\n        return res;\n    }\n    return value;\n}\nexports.convertBufferToString = convertBufferToString;\n/**\n * Convert a list of results to node-style\n *\n * @example\n * ```js\n * const input = ['a', 'b', new Error('c'), 'd']\n * const output = exports.wrapMultiResult(input)\n * expect(output).to.eql([[null, 'a'], [null, 'b'], [new Error('c')], [null, 'd'])\n * ```\n */\nfunction wrapMultiResult(arr) {\n    // When using WATCH/EXEC transactions, the EXEC will return\n    // a null instead of an array\n    if (!arr) {\n        return null;\n    }\n    const result = [];\n    const length = arr.length;\n    for (let i = 0; i < length; ++i) {\n        const item = arr[i];\n        if (item instanceof Error) {\n            result.push([item]);\n        }\n        else {\n            result.push([null, item]);\n        }\n    }\n    return result;\n}\nexports.wrapMultiResult = wrapMultiResult;\n/**\n * Detect if the argument is a int\n * @example\n * ```js\n * > isInt('123')\n * true\n * > isInt('123.3')\n * false\n * > isInt('1x')\n * false\n * > isInt(123)\n * true\n * > isInt(true)\n * false\n * ```\n */\nfunction isInt(value) {\n    const x = parseFloat(value);\n    return !isNaN(value) && (x | 0) === x;\n}\nexports.isInt = isInt;\n/**\n * Pack an array to an Object\n *\n * @example\n * ```js\n * > packObject(['a', 'b', 'c', 'd'])\n * { a: 'b', c: 'd' }\n * ```\n */\nfunction packObject(array) {\n    const result = {};\n    const length = array.length;\n    for (let i = 1; i < length; i += 2) {\n        result[array[i - 1]] = array[i];\n    }\n    return result;\n}\nexports.packObject = packObject;\n/**\n * Return a callback with timeout\n */\nfunction timeout(callback, timeout) {\n    let timer = null;\n    const run = function () {\n        if (timer) {\n            clearTimeout(timer);\n            timer = null;\n            callback.apply(this, arguments);\n        }\n    };\n    timer = setTimeout(run, timeout, new Error(\"timeout\"));\n    return run;\n}\nexports.timeout = timeout;\n/**\n * Convert an object to an array\n * @example\n * ```js\n * > convertObjectToArray({ a: '1' })\n * ['a', '1']\n * ```\n */\nfunction convertObjectToArray(obj) {\n    const result = [];\n    const keys = Object.keys(obj); // Object.entries requires node 7+\n    for (let i = 0, l = keys.length; i < l; i++) {\n        result.push(keys[i], obj[keys[i]]);\n    }\n    return result;\n}\nexports.convertObjectToArray = convertObjectToArray;\n/**\n * Convert a map to an array\n * @example\n * ```js\n * > convertMapToArray(new Map([[1, '2']]))\n * [1, '2']\n * ```\n */\nfunction convertMapToArray(map) {\n    const result = [];\n    let pos = 0;\n    map.forEach(function (value, key) {\n        result[pos] = key;\n        result[pos + 1] = value;\n        pos += 2;\n    });\n    return result;\n}\nexports.convertMapToArray = convertMapToArray;\n/**\n * Convert a non-string arg to a string\n */\nfunction toArg(arg) {\n    if (arg === null || typeof arg === \"undefined\") {\n        return \"\";\n    }\n    return String(arg);\n}\nexports.toArg = toArg;\n/**\n * Optimize error stack\n *\n * @param error actually error\n * @param friendlyStack the stack that more meaningful\n * @param filterPath only show stacks with the specified path\n */\nfunction optimizeErrorStack(error, friendlyStack, filterPath) {\n    const stacks = friendlyStack.split(\"\\n\");\n    let lines = \"\";\n    let i;\n    for (i = 1; i < stacks.length; ++i) {\n        if (stacks[i].indexOf(filterPath) === -1) {\n            break;\n        }\n    }\n    for (let j = i; j < stacks.length; ++j) {\n        lines += \"\\n\" + stacks[j];\n    }\n    if (error.stack) {\n        const pos = error.stack.indexOf(\"\\n\");\n        error.stack = error.stack.slice(0, pos) + lines;\n    }\n    return error;\n}\nexports.optimizeErrorStack = optimizeErrorStack;\n/**\n * Parse the redis protocol url\n */\nfunction parseURL(url) {\n    if (isInt(url)) {\n        return { port: url };\n    }\n    let parsed = (0, url_1.parse)(url, true, true);\n    if (!parsed.slashes && url[0] !== \"/\") {\n        url = \"//\" + url;\n        parsed = (0, url_1.parse)(url, true, true);\n    }\n    const options = parsed.query || {};\n    const result = {};\n    if (parsed.auth) {\n        const index = parsed.auth.indexOf(\":\");\n        result.username = index === -1 ? parsed.auth : parsed.auth.slice(0, index);\n        result.password = index === -1 ? \"\" : parsed.auth.slice(index + 1);\n    }\n    if (parsed.pathname) {\n        if (parsed.protocol === \"redis:\" || parsed.protocol === \"rediss:\") {\n            if (parsed.pathname.length > 1) {\n                result.db = parsed.pathname.slice(1);\n            }\n        }\n        else {\n            result.path = parsed.pathname;\n        }\n    }\n    if (parsed.host) {\n        result.host = parsed.hostname;\n    }\n    if (parsed.port) {\n        result.port = parsed.port;\n    }\n    if (typeof options.family === \"string\") {\n        const intFamily = Number.parseInt(options.family, 10);\n        if (!Number.isNaN(intFamily)) {\n            result.family = intFamily;\n        }\n    }\n    (0, lodash_1.defaults)(result, options);\n    return result;\n}\nexports.parseURL = parseURL;\n/**\n * Resolve TLS profile shortcut in connection options\n */\nfunction resolveTLSProfile(options) {\n    let tls = options === null || options === void 0 ? void 0 : options.tls;\n    if (typeof tls === \"string\")\n        tls = { profile: tls };\n    const profile = TLSProfiles_1.default[tls === null || tls === void 0 ? void 0 : tls.profile];\n    if (profile) {\n        tls = Object.assign({}, profile, tls);\n        delete tls.profile;\n        options = Object.assign({}, options, { tls });\n    }\n    return options;\n}\nexports.resolveTLSProfile = resolveTLSProfile;\n/**\n * Get a random element from `array`\n */\nfunction sample(array, from = 0) {\n    const length = array.length;\n    if (from >= length) {\n        return null;\n    }\n    return array[from + Math.floor(Math.random() * (length - from))];\n}\nexports.sample = sample;\n/**\n * Shuffle the array using the Fisher-Yates Shuffle.\n * This method will mutate the original array.\n */\nfunction shuffle(array) {\n    let counter = array.length;\n    // While there are elements in the array\n    while (counter > 0) {\n        // Pick a random index\n        const index = Math.floor(Math.random() * counter);\n        // Decrease counter by 1\n        counter--;\n        // And swap the last element with it\n        [array[counter], array[index]] = [array[index], array[counter]];\n    }\n    return array;\n}\nexports.shuffle = shuffle;\n/**\n * Error message for connection being disconnected\n */\nexports.CONNECTION_CLOSED_ERROR_MSG = \"Connection is closed.\";\nfunction zipMap(keys, values) {\n    const map = new Map();\n    keys.forEach((key, index) => {\n        map.set(key, values[index]);\n    });\n    return map;\n}\nexports.zipMap = zipMap;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7QUFDYiw4Q0FBNkMsRUFBRSxhQUFhLEVBQUM7QUFDN0QsWUFBWSxHQUFHLGdCQUFnQixHQUFHLGFBQWEsR0FBRyxjQUFjLEdBQUcsbUNBQW1DLEdBQUcsZUFBZSxHQUFHLGNBQWMsR0FBRyx5QkFBeUIsR0FBRyxnQkFBZ0IsR0FBRywwQkFBMEIsR0FBRyxhQUFhLEdBQUcseUJBQXlCLEdBQUcsNEJBQTRCLEdBQUcsZUFBZSxHQUFHLGtCQUFrQixHQUFHLGFBQWEsR0FBRyx1QkFBdUIsR0FBRyw2QkFBNkI7QUFDalosY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCLGlCQUFpQixtQkFBTyxDQUFDLHlHQUFVO0FBQ25DLDRDQUEyQyxFQUFFLHFDQUFxQyw2QkFBNkIsRUFBQztBQUNoSCx3Q0FBdUMsRUFBRSxxQ0FBcUMseUJBQXlCLEVBQUM7QUFDeEcsZ0JBQWdCLG1CQUFPLENBQUMsdUdBQVM7QUFDakMsYUFBYTtBQUNiLHNCQUFzQixtQkFBTyxDQUFDLGtJQUEwQjtBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFlBQVk7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsUUFBUTtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DO0FBQ25DLHFDQUFxQyxPQUFPO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFtQjtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQSxrQ0FBa0MsYUFBYSxLQUFLO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsY0FBYyIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvaW5kZXguanMiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm5vb3AgPSBleHBvcnRzLmRlZmF1bHRzID0gZXhwb3J0cy5EZWJ1ZyA9IGV4cG9ydHMuemlwTWFwID0gZXhwb3J0cy5DT05ORUNUSU9OX0NMT1NFRF9FUlJPUl9NU0cgPSBleHBvcnRzLnNodWZmbGUgPSBleHBvcnRzLnNhbXBsZSA9IGV4cG9ydHMucmVzb2x2ZVRMU1Byb2ZpbGUgPSBleHBvcnRzLnBhcnNlVVJMID0gZXhwb3J0cy5vcHRpbWl6ZUVycm9yU3RhY2sgPSBleHBvcnRzLnRvQXJnID0gZXhwb3J0cy5jb252ZXJ0TWFwVG9BcnJheSA9IGV4cG9ydHMuY29udmVydE9iamVjdFRvQXJyYXkgPSBleHBvcnRzLnRpbWVvdXQgPSBleHBvcnRzLnBhY2tPYmplY3QgPSBleHBvcnRzLmlzSW50ID0gZXhwb3J0cy53cmFwTXVsdGlSZXN1bHQgPSBleHBvcnRzLmNvbnZlcnRCdWZmZXJUb1N0cmluZyA9IHZvaWQgMDtcbmNvbnN0IHVybF8xID0gcmVxdWlyZShcInVybFwiKTtcbmNvbnN0IGxvZGFzaF8xID0gcmVxdWlyZShcIi4vbG9kYXNoXCIpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGVmYXVsdHNcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGxvZGFzaF8xLmRlZmF1bHRzOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwibm9vcFwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gbG9kYXNoXzEubm9vcDsgfSB9KTtcbmNvbnN0IGRlYnVnXzEgPSByZXF1aXJlKFwiLi9kZWJ1Z1wiKTtcbmV4cG9ydHMuRGVidWcgPSBkZWJ1Z18xLmRlZmF1bHQ7XG5jb25zdCBUTFNQcm9maWxlc18xID0gcmVxdWlyZShcIi4uL2NvbnN0YW50cy9UTFNQcm9maWxlc1wiKTtcbi8qKlxuICogQ29udmVydCBhIGJ1ZmZlciB0byBzdHJpbmcsIHN1cHBvcnRzIGJ1ZmZlciBhcnJheVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogY29uc3QgaW5wdXQgPSBbQnVmZmVyLmZyb20oJ2ZvbycpLCBbQnVmZmVyLmZyb20oJ2JhcicpXV1cbiAqIGNvbnN0IHJlcyA9IGNvbnZlcnRCdWZmZXJUb1N0cmluZyhpbnB1dCwgJ3V0ZjgnKVxuICogZXhwZWN0KHJlcykudG8uZXFsKFsnZm9vJywgWydiYXInXV0pXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY29udmVydEJ1ZmZlclRvU3RyaW5nKHZhbHVlLCBlbmNvZGluZykge1xuICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gdmFsdWUudG9TdHJpbmcoZW5jb2RpbmcpO1xuICAgIH1cbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgY29uc3QgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBjb25zdCByZXMgPSBBcnJheShsZW5ndGgpO1xuICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgICByZXNbaV0gPVxuICAgICAgICAgICAgICAgIHZhbHVlW2ldIGluc3RhbmNlb2YgQnVmZmVyICYmIGVuY29kaW5nID09PSBcInV0ZjhcIlxuICAgICAgICAgICAgICAgICAgICA/IHZhbHVlW2ldLnRvU3RyaW5nKClcbiAgICAgICAgICAgICAgICAgICAgOiBjb252ZXJ0QnVmZmVyVG9TdHJpbmcodmFsdWVbaV0sIGVuY29kaW5nKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG59XG5leHBvcnRzLmNvbnZlcnRCdWZmZXJUb1N0cmluZyA9IGNvbnZlcnRCdWZmZXJUb1N0cmluZztcbi8qKlxuICogQ29udmVydCBhIGxpc3Qgb2YgcmVzdWx0cyB0byBub2RlLXN0eWxlXG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiBjb25zdCBpbnB1dCA9IFsnYScsICdiJywgbmV3IEVycm9yKCdjJyksICdkJ11cbiAqIGNvbnN0IG91dHB1dCA9IGV4cG9ydHMud3JhcE11bHRpUmVzdWx0KGlucHV0KVxuICogZXhwZWN0KG91dHB1dCkudG8uZXFsKFtbbnVsbCwgJ2EnXSwgW251bGwsICdiJ10sIFtuZXcgRXJyb3IoJ2MnKV0sIFtudWxsLCAnZCddKVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHdyYXBNdWx0aVJlc3VsdChhcnIpIHtcbiAgICAvLyBXaGVuIHVzaW5nIFdBVENIL0VYRUMgdHJhbnNhY3Rpb25zLCB0aGUgRVhFQyB3aWxsIHJldHVyblxuICAgIC8vIGEgbnVsbCBpbnN0ZWFkIG9mIGFuIGFycmF5XG4gICAgaWYgKCFhcnIpIHtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIGNvbnN0IGxlbmd0aCA9IGFyci5sZW5ndGg7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBpdGVtID0gYXJyW2ldO1xuICAgICAgICBpZiAoaXRlbSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChbaXRlbV0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goW251bGwsIGl0ZW1dKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy53cmFwTXVsdGlSZXN1bHQgPSB3cmFwTXVsdGlSZXN1bHQ7XG4vKipcbiAqIERldGVjdCBpZiB0aGUgYXJndW1lbnQgaXMgYSBpbnRcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogPiBpc0ludCgnMTIzJylcbiAqIHRydWVcbiAqID4gaXNJbnQoJzEyMy4zJylcbiAqIGZhbHNlXG4gKiA+IGlzSW50KCcxeCcpXG4gKiBmYWxzZVxuICogPiBpc0ludCgxMjMpXG4gKiB0cnVlXG4gKiA+IGlzSW50KHRydWUpXG4gKiBmYWxzZVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIGlzSW50KHZhbHVlKSB7XG4gICAgY29uc3QgeCA9IHBhcnNlRmxvYXQodmFsdWUpO1xuICAgIHJldHVybiAhaXNOYU4odmFsdWUpICYmICh4IHwgMCkgPT09IHg7XG59XG5leHBvcnRzLmlzSW50ID0gaXNJbnQ7XG4vKipcbiAqIFBhY2sgYW4gYXJyYXkgdG8gYW4gT2JqZWN0XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiA+IHBhY2tPYmplY3QoWydhJywgJ2InLCAnYycsICdkJ10pXG4gKiB7IGE6ICdiJywgYzogJ2QnIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBwYWNrT2JqZWN0KGFycmF5KSB7XG4gICAgY29uc3QgcmVzdWx0ID0ge307XG4gICAgY29uc3QgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgIGZvciAobGV0IGkgPSAxOyBpIDwgbGVuZ3RoOyBpICs9IDIpIHtcbiAgICAgICAgcmVzdWx0W2FycmF5W2kgLSAxXV0gPSBhcnJheVtpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFja09iamVjdCA9IHBhY2tPYmplY3Q7XG4vKipcbiAqIFJldHVybiBhIGNhbGxiYWNrIHdpdGggdGltZW91dFxuICovXG5mdW5jdGlvbiB0aW1lb3V0KGNhbGxiYWNrLCB0aW1lb3V0KSB7XG4gICAgbGV0IHRpbWVyID0gbnVsbDtcbiAgICBjb25zdCBydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHRpbWVyID0gc2V0VGltZW91dChydW4sIHRpbWVvdXQsIG5ldyBFcnJvcihcInRpbWVvdXRcIikpO1xuICAgIHJldHVybiBydW47XG59XG5leHBvcnRzLnRpbWVvdXQgPSB0aW1lb3V0O1xuLyoqXG4gKiBDb252ZXJ0IGFuIG9iamVjdCB0byBhbiBhcnJheVxuICogQGV4YW1wbGVcbiAqIGBgYGpzXG4gKiA+IGNvbnZlcnRPYmplY3RUb0FycmF5KHsgYTogJzEnIH0pXG4gKiBbJ2EnLCAnMSddXG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gY29udmVydE9iamVjdFRvQXJyYXkob2JqKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3Qga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7IC8vIE9iamVjdC5lbnRyaWVzIHJlcXVpcmVzIG5vZGUgNytcbiAgICBmb3IgKGxldCBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleXNbaV0sIG9ialtrZXlzW2ldXSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbnZlcnRPYmplY3RUb0FycmF5ID0gY29udmVydE9iamVjdFRvQXJyYXk7XG4vKipcbiAqIENvbnZlcnQgYSBtYXAgdG8gYW4gYXJyYXlcbiAqIEBleGFtcGxlXG4gKiBgYGBqc1xuICogPiBjb252ZXJ0TWFwVG9BcnJheShuZXcgTWFwKFtbMSwgJzInXV0pKVxuICogWzEsICcyJ11cbiAqIGBgYFxuICovXG5mdW5jdGlvbiBjb252ZXJ0TWFwVG9BcnJheShtYXApIHtcbiAgICBjb25zdCByZXN1bHQgPSBbXTtcbiAgICBsZXQgcG9zID0gMDtcbiAgICBtYXAuZm9yRWFjaChmdW5jdGlvbiAodmFsdWUsIGtleSkge1xuICAgICAgICByZXN1bHRbcG9zXSA9IGtleTtcbiAgICAgICAgcmVzdWx0W3BvcyArIDFdID0gdmFsdWU7XG4gICAgICAgIHBvcyArPSAyO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmNvbnZlcnRNYXBUb0FycmF5ID0gY29udmVydE1hcFRvQXJyYXk7XG4vKipcbiAqIENvbnZlcnQgYSBub24tc3RyaW5nIGFyZyB0byBhIHN0cmluZ1xuICovXG5mdW5jdGlvbiB0b0FyZyhhcmcpIHtcbiAgICBpZiAoYXJnID09PSBudWxsIHx8IHR5cGVvZiBhcmcgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgfVxuICAgIHJldHVybiBTdHJpbmcoYXJnKTtcbn1cbmV4cG9ydHMudG9BcmcgPSB0b0FyZztcbi8qKlxuICogT3B0aW1pemUgZXJyb3Igc3RhY2tcbiAqXG4gKiBAcGFyYW0gZXJyb3IgYWN0dWFsbHkgZXJyb3JcbiAqIEBwYXJhbSBmcmllbmRseVN0YWNrIHRoZSBzdGFjayB0aGF0IG1vcmUgbWVhbmluZ2Z1bFxuICogQHBhcmFtIGZpbHRlclBhdGggb25seSBzaG93IHN0YWNrcyB3aXRoIHRoZSBzcGVjaWZpZWQgcGF0aFxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZUVycm9yU3RhY2soZXJyb3IsIGZyaWVuZGx5U3RhY2ssIGZpbHRlclBhdGgpIHtcbiAgICBjb25zdCBzdGFja3MgPSBmcmllbmRseVN0YWNrLnNwbGl0KFwiXFxuXCIpO1xuICAgIGxldCBsaW5lcyA9IFwiXCI7XG4gICAgbGV0IGk7XG4gICAgZm9yIChpID0gMTsgaSA8IHN0YWNrcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBpZiAoc3RhY2tzW2ldLmluZGV4T2YoZmlsdGVyUGF0aCkgPT09IC0xKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaTsgaiA8IHN0YWNrcy5sZW5ndGg7ICsraikge1xuICAgICAgICBsaW5lcyArPSBcIlxcblwiICsgc3RhY2tzW2pdO1xuICAgIH1cbiAgICBpZiAoZXJyb3Iuc3RhY2spIHtcbiAgICAgICAgY29uc3QgcG9zID0gZXJyb3Iuc3RhY2suaW5kZXhPZihcIlxcblwiKTtcbiAgICAgICAgZXJyb3Iuc3RhY2sgPSBlcnJvci5zdGFjay5zbGljZSgwLCBwb3MpICsgbGluZXM7XG4gICAgfVxuICAgIHJldHVybiBlcnJvcjtcbn1cbmV4cG9ydHMub3B0aW1pemVFcnJvclN0YWNrID0gb3B0aW1pemVFcnJvclN0YWNrO1xuLyoqXG4gKiBQYXJzZSB0aGUgcmVkaXMgcHJvdG9jb2wgdXJsXG4gKi9cbmZ1bmN0aW9uIHBhcnNlVVJMKHVybCkge1xuICAgIGlmIChpc0ludCh1cmwpKSB7XG4gICAgICAgIHJldHVybiB7IHBvcnQ6IHVybCB9O1xuICAgIH1cbiAgICBsZXQgcGFyc2VkID0gKDAsIHVybF8xLnBhcnNlKSh1cmwsIHRydWUsIHRydWUpO1xuICAgIGlmICghcGFyc2VkLnNsYXNoZXMgJiYgdXJsWzBdICE9PSBcIi9cIikge1xuICAgICAgICB1cmwgPSBcIi8vXCIgKyB1cmw7XG4gICAgICAgIHBhcnNlZCA9ICgwLCB1cmxfMS5wYXJzZSkodXJsLCB0cnVlLCB0cnVlKTtcbiAgICB9XG4gICAgY29uc3Qgb3B0aW9ucyA9IHBhcnNlZC5xdWVyeSB8fCB7fTtcbiAgICBjb25zdCByZXN1bHQgPSB7fTtcbiAgICBpZiAocGFyc2VkLmF1dGgpIHtcbiAgICAgICAgY29uc3QgaW5kZXggPSBwYXJzZWQuYXV0aC5pbmRleE9mKFwiOlwiKTtcbiAgICAgICAgcmVzdWx0LnVzZXJuYW1lID0gaW5kZXggPT09IC0xID8gcGFyc2VkLmF1dGggOiBwYXJzZWQuYXV0aC5zbGljZSgwLCBpbmRleCk7XG4gICAgICAgIHJlc3VsdC5wYXNzd29yZCA9IGluZGV4ID09PSAtMSA/IFwiXCIgOiBwYXJzZWQuYXV0aC5zbGljZShpbmRleCArIDEpO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBhdGhuYW1lKSB7XG4gICAgICAgIGlmIChwYXJzZWQucHJvdG9jb2wgPT09IFwicmVkaXM6XCIgfHwgcGFyc2VkLnByb3RvY29sID09PSBcInJlZGlzczpcIikge1xuICAgICAgICAgICAgaWYgKHBhcnNlZC5wYXRobmFtZS5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LmRiID0gcGFyc2VkLnBhdGhuYW1lLnNsaWNlKDEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnBhdGggPSBwYXJzZWQucGF0aG5hbWU7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHBhcnNlZC5ob3N0KSB7XG4gICAgICAgIHJlc3VsdC5ob3N0ID0gcGFyc2VkLmhvc3RuYW1lO1xuICAgIH1cbiAgICBpZiAocGFyc2VkLnBvcnQpIHtcbiAgICAgICAgcmVzdWx0LnBvcnQgPSBwYXJzZWQucG9ydDtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZhbWlseSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBjb25zdCBpbnRGYW1pbHkgPSBOdW1iZXIucGFyc2VJbnQob3B0aW9ucy5mYW1pbHksIDEwKTtcbiAgICAgICAgaWYgKCFOdW1iZXIuaXNOYU4oaW50RmFtaWx5KSkge1xuICAgICAgICAgICAgcmVzdWx0LmZhbWlseSA9IGludEZhbWlseTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAoMCwgbG9kYXNoXzEuZGVmYXVsdHMpKHJlc3VsdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucGFyc2VVUkwgPSBwYXJzZVVSTDtcbi8qKlxuICogUmVzb2x2ZSBUTFMgcHJvZmlsZSBzaG9ydGN1dCBpbiBjb25uZWN0aW9uIG9wdGlvbnNcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRMU1Byb2ZpbGUob3B0aW9ucykge1xuICAgIGxldCB0bHMgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMudGxzO1xuICAgIGlmICh0eXBlb2YgdGxzID09PSBcInN0cmluZ1wiKVxuICAgICAgICB0bHMgPSB7IHByb2ZpbGU6IHRscyB9O1xuICAgIGNvbnN0IHByb2ZpbGUgPSBUTFNQcm9maWxlc18xLmRlZmF1bHRbdGxzID09PSBudWxsIHx8IHRscyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGxzLnByb2ZpbGVdO1xuICAgIGlmIChwcm9maWxlKSB7XG4gICAgICAgIHRscyA9IE9iamVjdC5hc3NpZ24oe30sIHByb2ZpbGUsIHRscyk7XG4gICAgICAgIGRlbGV0ZSB0bHMucHJvZmlsZTtcbiAgICAgICAgb3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHsgdGxzIH0pO1xuICAgIH1cbiAgICByZXR1cm4gb3B0aW9ucztcbn1cbmV4cG9ydHMucmVzb2x2ZVRMU1Byb2ZpbGUgPSByZXNvbHZlVExTUHJvZmlsZTtcbi8qKlxuICogR2V0IGEgcmFuZG9tIGVsZW1lbnQgZnJvbSBgYXJyYXlgXG4gKi9cbmZ1bmN0aW9uIHNhbXBsZShhcnJheSwgZnJvbSA9IDApIHtcbiAgICBjb25zdCBsZW5ndGggPSBhcnJheS5sZW5ndGg7XG4gICAgaWYgKGZyb20gPj0gbGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXlbZnJvbSArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChsZW5ndGggLSBmcm9tKSldO1xufVxuZXhwb3J0cy5zYW1wbGUgPSBzYW1wbGU7XG4vKipcbiAqIFNodWZmbGUgdGhlIGFycmF5IHVzaW5nIHRoZSBGaXNoZXItWWF0ZXMgU2h1ZmZsZS5cbiAqIFRoaXMgbWV0aG9kIHdpbGwgbXV0YXRlIHRoZSBvcmlnaW5hbCBhcnJheS5cbiAqL1xuZnVuY3Rpb24gc2h1ZmZsZShhcnJheSkge1xuICAgIGxldCBjb3VudGVyID0gYXJyYXkubGVuZ3RoO1xuICAgIC8vIFdoaWxlIHRoZXJlIGFyZSBlbGVtZW50cyBpbiB0aGUgYXJyYXlcbiAgICB3aGlsZSAoY291bnRlciA+IDApIHtcbiAgICAgICAgLy8gUGljayBhIHJhbmRvbSBpbmRleFxuICAgICAgICBjb25zdCBpbmRleCA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIGNvdW50ZXIpO1xuICAgICAgICAvLyBEZWNyZWFzZSBjb3VudGVyIGJ5IDFcbiAgICAgICAgY291bnRlci0tO1xuICAgICAgICAvLyBBbmQgc3dhcCB0aGUgbGFzdCBlbGVtZW50IHdpdGggaXRcbiAgICAgICAgW2FycmF5W2NvdW50ZXJdLCBhcnJheVtpbmRleF1dID0gW2FycmF5W2luZGV4XSwgYXJyYXlbY291bnRlcl1dO1xuICAgIH1cbiAgICByZXR1cm4gYXJyYXk7XG59XG5leHBvcnRzLnNodWZmbGUgPSBzaHVmZmxlO1xuLyoqXG4gKiBFcnJvciBtZXNzYWdlIGZvciBjb25uZWN0aW9uIGJlaW5nIGRpc2Nvbm5lY3RlZFxuICovXG5leHBvcnRzLkNPTk5FQ1RJT05fQ0xPU0VEX0VSUk9SX01TRyA9IFwiQ29ubmVjdGlvbiBpcyBjbG9zZWQuXCI7XG5mdW5jdGlvbiB6aXBNYXAoa2V5cywgdmFsdWVzKSB7XG4gICAgY29uc3QgbWFwID0gbmV3IE1hcCgpO1xuICAgIGtleXMuZm9yRWFjaCgoa2V5LCBpbmRleCkgPT4ge1xuICAgICAgICBtYXAuc2V0KGtleSwgdmFsdWVzW2luZGV4XSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIG1hcDtcbn1cbmV4cG9ydHMuemlwTWFwID0gemlwTWFwO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/index.js\n");

/***/ }),

/***/ "(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/lodash.js":
/*!*****************************************************************************************!*\
  !*** ../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/lodash.js ***!
  \*****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.isArguments = exports.defaults = exports.noop = void 0;\nconst defaults = __webpack_require__(/*! lodash.defaults */ \"(rsc)/../../node_modules/.pnpm/lodash.defaults@4.2.0/node_modules/lodash.defaults/index.js\");\nexports.defaults = defaults;\nconst isArguments = __webpack_require__(/*! lodash.isarguments */ \"(rsc)/../../node_modules/.pnpm/lodash.isarguments@3.1.0/node_modules/lodash.isarguments/index.js\");\nexports.isArguments = isArguments;\nfunction noop() { }\nexports.noop = noop;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi4vLi4vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvbG9kYXNoLmpzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2IsOENBQTZDLEVBQUUsYUFBYSxFQUFDO0FBQzdELG1CQUFtQixHQUFHLGdCQUFnQixHQUFHLFlBQVk7QUFDckQsaUJBQWlCLG1CQUFPLENBQUMsbUhBQWlCO0FBQzFDLGdCQUFnQjtBQUNoQixvQkFBb0IsbUJBQU8sQ0FBQyw0SEFBb0I7QUFDaEQsbUJBQW1CO0FBQ25CO0FBQ0EsWUFBWSIsInNvdXJjZXMiOlsiL1VzZXJzL2pvc2h1YWphbnNldmFucmVuc2J1cmcvRGVza3RvcC80LiBDb2RlL3BvZGNhc3QtcGxhdGZvcm0vbm9kZV9tb2R1bGVzLy5wbnBtL2lvcmVkaXNANS42LjEvbm9kZV9tb2R1bGVzL2lvcmVkaXMvYnVpbHQvdXRpbHMvbG9kYXNoLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc0FyZ3VtZW50cyA9IGV4cG9ydHMuZGVmYXVsdHMgPSBleHBvcnRzLm5vb3AgPSB2b2lkIDA7XG5jb25zdCBkZWZhdWx0cyA9IHJlcXVpcmUoXCJsb2Rhc2guZGVmYXVsdHNcIik7XG5leHBvcnRzLmRlZmF1bHRzID0gZGVmYXVsdHM7XG5jb25zdCBpc0FyZ3VtZW50cyA9IHJlcXVpcmUoXCJsb2Rhc2guaXNhcmd1bWVudHNcIik7XG5leHBvcnRzLmlzQXJndW1lbnRzID0gaXNBcmd1bWVudHM7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5leHBvcnRzLm5vb3AgPSBub29wO1xuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/../../node_modules/.pnpm/ioredis@5.6.1/node_modules/ioredis/built/utils/lodash.js\n");

/***/ })

};
;